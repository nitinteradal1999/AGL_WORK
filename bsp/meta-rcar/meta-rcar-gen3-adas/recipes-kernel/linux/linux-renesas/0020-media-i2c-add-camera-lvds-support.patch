From cbdb072287135c8b215ce80c1a79514932961ea5 Mon Sep 17 00:00:00 2001
From: Vladimir Barinov <vladimir.barinov@cogentembedded.com>
Date: Thu, 24 Sep 2020 01:16:20 +0300
Subject: [PATCH 13/76] media: i2c: add camera lvds support

This adds GMSL1/GMSL2/FPDLink3 video support

Signed-off-by: Vladimir Barinov <vladimir.barinov@cogentembedded.com>

Updated original patch for Linux 5.10:
 * updated Kconfig;
 * used i2c_new_dummy_device instead of i2c_new_dummy;
 * moved g_mbus_config from v4l2_ctrl_ops to get_mbus_config
   v4l2_subdev_pad_ops;
 * disabled community drivers/media/i2c/max9286.c driver.

Signed-off-by: Valentine Barshak <valentine.barshak@cogentembedded.com>
---
 drivers/media/i2c/Kconfig                 |   26 +-
 drivers/media/i2c/Makefile                |    6 +-
 drivers/media/i2c/fpdlink/Kconfig         |   15 +
 drivers/media/i2c/fpdlink/Makefile        |    2 +
 drivers/media/i2c/fpdlink/ub9x4.c         |  927 +++++++++++++++++
 drivers/media/i2c/fpdlink/ub9x4.h         |   19 +
 drivers/media/i2c/gmsl/Kconfig            |   47 +
 drivers/media/i2c/gmsl/Makefile           |    5 +
 drivers/media/i2c/gmsl/common.h           |  508 +++++++++
 drivers/media/i2c/gmsl/max9286.c          | 1120 ++++++++++++++++++++
 drivers/media/i2c/gmsl/max9286_debug.h    |   89 ++
 drivers/media/i2c/gmsl/max9288.c          |  915 ++++++++++++++++
 drivers/media/i2c/gmsl/max9295.h          |   39 +
 drivers/media/i2c/gmsl/max9296.c          | 1596 ++++++++++++++++++++++++++++
 drivers/media/i2c/gmsl/max9296.h          |  306 ++++++
 drivers/media/i2c/gmsl/max9296_debug.h    |  462 +++++++++
 drivers/media/i2c/gmsl/max96712.c         | 1604 +++++++++++++++++++++++++++++
 drivers/media/i2c/gmsl/max96712.h         |  288 ++++++
 drivers/media/i2c/gmsl/max96712_debug.h   |  362 +++++++
 drivers/media/i2c/imagers/Kconfig         |   13 +
 drivers/media/i2c/imagers/Makefile        |   10 +
 drivers/media/i2c/imagers/ap0101.c        |  639 ++++++++++++
 drivers/media/i2c/imagers/ap0101.h        |   36 +
 drivers/media/i2c/imagers/ap0201.c        |  607 +++++++++++
 drivers/media/i2c/imagers/ap0201.h        |   36 +
 drivers/media/i2c/imagers/dummy.c         |  504 +++++++++
 drivers/media/i2c/imagers/isx016.c        |  550 ++++++++++
 drivers/media/i2c/imagers/isx016.h        |   27 +
 drivers/media/i2c/imagers/isx019.c        |  608 +++++++++++
 drivers/media/i2c/imagers/isx019.h        |   30 +
 drivers/media/i2c/imagers/ov10635.c       |  702 +++++++++++++
 drivers/media/i2c/imagers/ov10635.h       | 1143 ++++++++++++++++++++
 drivers/media/i2c/imagers/ov10635_debug.h |   54 +
 drivers/media/i2c/imagers/ov2311.c        |  588 +++++++++++
 drivers/media/i2c/imagers/ov2311.h        |  217 ++++
 drivers/media/i2c/imagers/ov490.c         | 1075 +++++++++++++++++++
 drivers/media/i2c/imagers/ov490.h         |  101 ++
 drivers/media/i2c/imagers/ov495.c         |  622 +++++++++++
 drivers/media/i2c/imagers/ov495.h         |   23 +
 39 files changed, 15908 insertions(+), 13 deletions(-)
 create mode 100644 drivers/media/i2c/fpdlink/Kconfig
 create mode 100644 drivers/media/i2c/fpdlink/Makefile
 create mode 100644 drivers/media/i2c/fpdlink/ub9x4.c
 create mode 100644 drivers/media/i2c/fpdlink/ub9x4.h
 create mode 100644 drivers/media/i2c/gmsl/Kconfig
 create mode 100644 drivers/media/i2c/gmsl/Makefile
 create mode 100644 drivers/media/i2c/gmsl/common.h
 create mode 100644 drivers/media/i2c/gmsl/max9286.c
 create mode 100644 drivers/media/i2c/gmsl/max9286_debug.h
 create mode 100644 drivers/media/i2c/gmsl/max9288.c
 create mode 100644 drivers/media/i2c/gmsl/max9295.h
 create mode 100644 drivers/media/i2c/gmsl/max9296.c
 create mode 100644 drivers/media/i2c/gmsl/max9296.h
 create mode 100644 drivers/media/i2c/gmsl/max9296_debug.h
 create mode 100644 drivers/media/i2c/gmsl/max96712.c
 create mode 100644 drivers/media/i2c/gmsl/max96712.h
 create mode 100644 drivers/media/i2c/gmsl/max96712_debug.h
 create mode 100644 drivers/media/i2c/imagers/Kconfig
 create mode 100644 drivers/media/i2c/imagers/Makefile
 create mode 100644 drivers/media/i2c/imagers/ap0101.c
 create mode 100644 drivers/media/i2c/imagers/ap0101.h
 create mode 100644 drivers/media/i2c/imagers/ap0201.c
 create mode 100644 drivers/media/i2c/imagers/ap0201.h
 create mode 100644 drivers/media/i2c/imagers/dummy.c
 create mode 100644 drivers/media/i2c/imagers/isx016.c
 create mode 100644 drivers/media/i2c/imagers/isx016.h
 create mode 100644 drivers/media/i2c/imagers/isx019.c
 create mode 100644 drivers/media/i2c/imagers/isx019.h
 create mode 100644 drivers/media/i2c/imagers/ov10635.c
 create mode 100644 drivers/media/i2c/imagers/ov10635.h
 create mode 100644 drivers/media/i2c/imagers/ov10635_debug.h
 create mode 100644 drivers/media/i2c/imagers/ov2311.c
 create mode 100644 drivers/media/i2c/imagers/ov2311.h
 create mode 100644 drivers/media/i2c/imagers/ov490.c
 create mode 100644 drivers/media/i2c/imagers/ov490.h
 create mode 100644 drivers/media/i2c/imagers/ov495.c
 create mode 100644 drivers/media/i2c/imagers/ov495.h

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index 0589bba..c6a6999 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -464,18 +464,16 @@ config VIDEO_VPX3220
 	  To compile this driver as a module, choose M here: the
 	  module will be called vpx3220.
 
-config VIDEO_MAX9286
-	tristate "Maxim MAX9286 GMSL deserializer support"
-	depends on I2C && I2C_MUX
-	depends on OF_GPIO
-	select V4L2_FWNODE
-	select VIDEO_V4L2_SUBDEV_API
-	select MEDIA_CONTROLLER
-	help
-	  This driver supports the Maxim MAX9286 GMSL deserializer.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called max9286.
+#config VIDEO_MAX9286
+#	tristate "Maxim MAX9286 GMSL deserializer support"
+#	depends on I2C && I2C_MUX
+#	depends on OF_GPIO
+#	select V4L2_FWNODE
+#	help
+#	  This driver supports the Maxim MAX9286 GMSL deserializer.
+#
+#	  To compile this driver as a module, choose M here: the
+#	  module will be called max9286.
 
 comment "Video and audio decoders"
 
@@ -1346,4 +1344,8 @@ config VIDEO_LM3646
 	  flash, torch LEDs.
 endmenu
 
+source "drivers/media/i2c/gmsl/Kconfig"
+source "drivers/media/i2c/fpdlink/Kconfig"
+source "drivers/media/i2c/imagers/Kconfig"
+
 endif # VIDEO_V4L2
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 5dccb72..debc332 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -7,6 +7,10 @@ obj-$(CONFIG_VIDEO_ET8EK8)	+= et8ek8/
 obj-$(CONFIG_VIDEO_CX25840) += cx25840/
 obj-$(CONFIG_VIDEO_M5MOLS)	+= m5mols/
 
+obj-y				+= imagers/
+obj-y				+= gmsl/
+obj-y				+= fpdlink/
+
 obj-$(CONFIG_VIDEO_APTINA_PLL) += aptina-pll.o
 obj-$(CONFIG_VIDEO_TVAUDIO) += tvaudio.o
 obj-$(CONFIG_VIDEO_TDA7432) += tda7432.o
@@ -120,7 +124,7 @@ obj-$(CONFIG_VIDEO_IMX274)	+= imx274.o
 obj-$(CONFIG_VIDEO_IMX290)	+= imx290.o
 obj-$(CONFIG_VIDEO_IMX319)	+= imx319.o
 obj-$(CONFIG_VIDEO_IMX355)	+= imx355.o
-obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
+#obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
 rdacm20-camera_module-objs	:= rdacm20.o max9271.o
 obj-$(CONFIG_VIDEO_RDACM20)	+= rdacm20-camera_module.o
 obj-$(CONFIG_VIDEO_ST_MIPID02) += st-mipid02.o
diff --git a/drivers/media/i2c/fpdlink/Kconfig b/drivers/media/i2c/fpdlink/Kconfig
new file mode 100644
index 0000000..2687507
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/Kconfig
@@ -0,0 +1,15 @@
+#
+# GMSL video device configuration
+#
+
+config VIDEO_UB9X4
+	tristate "TI DS90UB960 FPDLink3 deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a Texas Instruments DS90UB960/UB954/UB964 FPDLink3
+	  deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ub9x4.
diff --git a/drivers/media/i2c/fpdlink/Makefile b/drivers/media/i2c/fpdlink/Makefile
new file mode 100644
index 0000000..3a694ed
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/Makefile
@@ -0,0 +1,2 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_VIDEO_UB9X4)	+= ub9x4.o
diff --git a/drivers/media/i2c/fpdlink/ub9x4.c b/drivers/media/i2c/fpdlink/ub9x4.c
new file mode 100644
index 0000000..26f69b9
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/ub9x4.c
@@ -0,0 +1,927 @@
+/*
+ * TI DS90UB954/960/964 FPDLinkIII driver
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-clk.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "ub9x4.h"
+#include "../gmsl/common.h"
+
+#define UB9X4_N_LINKS		4
+
+enum ub9x4_pads {
+	UB9X4_SINK_LINK0,
+	UB9X4_SINK_LINK1,
+	UB9X4_SINK_LINK2,
+	UB9X4_SINK_LINK3,
+	UB9X4_SOURCE,
+	UB9X4_N_PADS,
+};
+
+struct ub9x4_sink {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+};
+
+#define asd_to_ub9x4_sink(_asd) \
+	container_of(_asd, struct ub9x4_sink, asd)
+
+struct ub9x4_priv {
+	struct i2c_client	*client;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[UB9X4_N_PADS];
+
+	struct i2c_mux_core	*mux;
+
+	struct ub9x4_sink	sinks[UB9X4_N_LINKS];
+	struct v4l2_async_subdev *subdevs[UB9X4_N_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			des_addr;
+	int			n_links;
+	int			links_mask;
+	int			lanes;
+	int			csi_rate;
+	char			forwarding_mode[16];
+	int			fs_time;
+	int			fps_numerator;
+	int			fps_denominator;
+	int			is_coax;
+	int			dvp_bus;
+	int			dvp_lsb;
+	int			hsync;
+	int			vsync;
+	int			poc_delay;
+	atomic_t		use_count;
+	int			ser_addr[4];
+	char			chip_id[6];
+	int			ser_id;
+	int			vc_map;
+	int			csi_map;
+	int			gpio[4];
+	struct regulator	*poc_reg[4]; /* PoC power supply */
+	struct v4l2_clk		*ref_clk; /* ref clock */
+	struct notifier_block	reboot_notifier;
+};
+
+static int ser_id;
+module_param(ser_id, int, 0644);
+MODULE_PARM_DESC(ser_id, "  Serializer ID (default: UB913)");
+
+static int is_stp;
+module_param(is_stp, int, 0644);
+MODULE_PARM_DESC(is_stp, "  STP cable (default: Coax cable)");
+
+static int dvp_bus = 8;
+module_param(dvp_bus, int, 0644);
+MODULE_PARM_DESC(dvp_bus, "  DVP/CSI over FPDLink (default: DVP 8-bit)");
+
+static int dvp_lsb = 0;
+module_param(dvp_lsb, int, 0644);
+MODULE_PARM_DESC(dvp_lsb, "  DVP 8-bit LSB/MSB selection (default: DVP 8-bit MSB)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int poc_delay;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 0 ms)");
+
+static int vc_map = 0x3210;
+module_param(vc_map, int, 0644);
+MODULE_PARM_DESC(vc_map, " CSI VC MAP (default: 0xe4 - linear map VCx=LINKx)");
+
+static int csi_map = 0;
+module_param(csi_map, int, 0644);
+MODULE_PARM_DESC(csi_map, " CSI TX MAP (default: 0 - forwarding of all links to CSI0)");
+
+static int gpio0 = 0, gpio1 = 0, gpio2 = 0, gpio3 = 0;
+module_param(gpio0, int, 0644);
+MODULE_PARM_DESC(gpio0, "  GPIO0 function select (default: GPIO0 low level)");
+module_param(gpio1, int, 0644);
+MODULE_PARM_DESC(gpio1, "  GPIO1 function select (default: GPIO1 low level)");
+module_param(gpio2, int, 0644);
+MODULE_PARM_DESC(gpio2, "  GPIO2 function select (default: GPIO2 low level)");
+module_param(gpio3, int, 0644);
+MODULE_PARM_DESC(gpio3, "  GPIO3 function select (default: GPIO3 low level)");
+
+static void ub9x4_read_chipid(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+
+	/* Chip ID */
+	reg8_read(client, 0xf1, &priv->chip_id[0]);
+	reg8_read(client, 0xf2, &priv->chip_id[1]);
+	reg8_read(client, 0xf3, &priv->chip_id[2]);
+	reg8_read(client, 0xf4, &priv->chip_id[3]);
+	reg8_read(client, 0xf5, &priv->chip_id[4]);
+	priv->chip_id[5] = '\0';
+}
+
+static void ub9x4_initial_setup(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+
+	/* Initial setup */
+	client->addr = priv->des_addr;				/* ub9x4 I2C */
+	reg8_write(client, 0x0d, 0xb9);				/* VDDIO 3.3V */
+	switch (priv->csi_rate) {
+	case 1600: /* REFCLK = 25MHZ */
+	case 1500: /* REFCLK = 23MHZ */
+	case 1450: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x00);			/* CSI rate 1.5/1.6Gbps */
+		break;
+	case 1200: /* REFCLK = 25MHZ */
+	case 1100: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x01);			/* CSI rate 1.1/1.2Gbps */
+		break;
+	case 800: /* REFCLK = 25MHZ */
+	case 700: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x02);			/* CSI rate 700/800Mbps */
+		break;
+	case 400: /* REFCLK = 25MHZ */
+	case 350: /* REFCLK = 22.5MHZ */
+		reg8_write(client, 0x1f, 0x03);			/* CSI rate 350/400Mbps */
+		break;
+	default:
+		dev_err(&client->dev, "unsupported CSI rate %d\n", priv->csi_rate);
+	}
+
+	switch (priv->csi_rate) {
+	case 1600:
+	case 1200:
+	case 800:
+	case 400:
+		/* FrameSync setup for REFCLK=25MHz,   FPS=30: period_counts=1/FPS/12mks=1/30/12e-6=2777 -> HI=2, LO=2775 */
+		priv->fs_time = 2790;
+		break;
+	case 1500:
+		/* FrameSync setup for REFCLK=23MHz, FPS=30: period_counts=1/FPS/13.043mks=1/30/13.043e-6=2556 -> HI=2, LO=2554 */
+		priv->fs_time = 2570;
+		break;
+	case 1450:
+	case 1100:
+	case 700:
+	case 350:
+		/* FrameSync setup for REFCLK=22.5MHz, FPS=30: period_counts=1/FPS/13.333mks=1/30/13.333e-6=2500 -> HI=2, LO=2498 */
+		priv->fs_time = 2513;
+		break;
+	default:
+		priv->fs_time = 0;
+		dev_err(&client->dev, "unsupported CSI rate %d\n", priv->csi_rate);
+	}
+
+	if (strcmp(priv->forwarding_mode, "round-robin") == 0) {
+		reg8_write(client, 0x21, 0x03);			/* Round Robin forwarding enable for CSI0/CSI1 */
+	} else if (strcmp(priv->forwarding_mode, "synchronized") == 0) {
+		reg8_write(client, 0x21, 0x54);			/* Basic Syncronized forwarding enable (FrameSync must be enabled!!) for CSI0/CSI1 */
+	}
+
+	reg8_write(client, 0x32, 0x03);				/* Select TX for CSI0/CSI1, RX for CSI0 */
+	reg8_write(client, 0x33, ((priv->lanes - 1) ^ 0x3) << 4); /* disable CSI output, set CSI lane count, non-continuous CSI mode */
+	reg8_write(client, 0x20, 0xf0 | priv->csi_map);		/* disable port forwarding */
+#if 0
+	/* FrameSync setup for REFCLK=25MHz,   FPS=30: period_counts=1/2/FPS*25MHz  =1/2/30*25Mhz  =416666 -> FS_TIME=416666 */
+	/* FrameSync setup for REFCLK=22.5MHz, FPS=30: period_counts=1/2/FPS*22.5Mhz=1/2/30*22.5Mhz=375000 -> FS_TIME=375000 */
+// #define FS_TIME (priv->csi_rate == 1450 ? 376000 : 417666)
+ #define FS_TIME (priv->csi_rate == 1450 ? 385000 : 428000) // FPS=29.2 (new vendor's firmware AWB restriction?)
+	reg8_write(client, 0x1a, FS_TIME >> 16);		/* FrameSync time 24bit */
+	reg8_write(client, 0x1b, (FS_TIME >> 8) & 0xff);
+	reg8_write(client, 0x1c, FS_TIME & 0xff);
+	reg8_write(client, 0x18, 0x43);				/* Enable FrameSync, 50/50 mode, Frame clock from 25MHz */
+#else
+	reg8_write(client, 0x19, 2 >> 8);			/* FrameSync high time MSB */
+	reg8_write(client, 0x1a, 2 & 0xff);			/* FrameSync high time LSB */
+	reg8_write(client, 0x1b, priv->fs_time >> 8);		/* FrameSync low time MSB */
+	reg8_write(client, 0x1c, priv->fs_time & 0xff);		/* FrameSync low time LSB */
+	reg8_write(client, 0x18, 0x00);				/* Disable FrameSync - must be enabled after all cameras are set up */
+#endif
+}
+
+static void ub9x4_fpdlink3_setup(struct i2c_client *client, int idx)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	u8 port_config = 0x78;
+	u8 port_config2 = 0;
+
+	/* FPDLinkIII setup */
+	client->addr = priv->des_addr;				/* ub9x4 I2C */
+	reg8_write(client, 0x4c, (idx << 4) | (1 << idx));	/* Select RX port number */
+	usleep_range(2000, 2500);
+
+	switch (priv->ser_id) {
+	case UB913_ID:
+		reg8_write(client, 0x58, 0x58);			/* Back channel: Freq=2.5Mbps */
+		break;
+	case UB953_ID:
+		reg8_write(client, 0x58, 0x5e);			/* Back channel: Freq=50Mbps */
+		break;
+	default:
+		break;
+	}
+
+	reg8_write(client, 0x5c, priv->ser_addr[idx] << 1);	/* UB9X3 I2C addr */
+//	reg8_write(client, 0x5d, 0x30 << 1);			/* SENSOR I2C native - must be set by sensor driver */
+//	reg8_write(client, 0x65, (0x60 + idx) << 1);		/* SENSOR I2C translated - must be set by sensor driver */
+
+	if (priv->is_coax)
+		port_config |= 0x04;				/* Coax */
+	else
+		port_config |= 0x00;				/* STP */
+
+	switch (priv->dvp_bus) {
+	case 8:
+		port_config2 |= (priv->dvp_lsb ? 0xC0 : 0x80);	/* RAW10 as 8-bit prosessing using LSB/MSB bits  */
+		/* fall through */
+	case 10:
+		port_config |= 0x03;				/* DVP over FPDLink (UB913 compatible) RAW10/RAW8 */
+		break;
+	case 12:
+		port_config |= 0x02;				/* DVP over FPDLink (UB913 compatible) RAW12 */
+		break;
+	default:
+		port_config |= 0x00;				/* CSI over FPDLink (UB953 compatible) */
+	}
+
+	if (priv->vsync)
+		port_config2 |= 0x01;				/* VSYNC acive low */
+	if (priv->hsync)
+		port_config2 |= 0x02;				/* HSYNC acive low */
+
+	reg8_write(client, 0x6d, port_config);
+	reg8_write(client, 0x7c, port_config2);
+	reg8_write(client, 0x70, ((priv->vc_map >> (idx * 4)) << 6) | 0x1e); /* CSI data type: yuv422 8-bit, assign VC */
+	reg8_write(client, 0x71, ((priv->vc_map >> (idx * 4)) << 6) | 0x2c); /* CSI data type: RAW12, assign VC */
+	reg8_write(client, 0xbc, 0x00);				/* Setup minimal time between FV and LV to 3 PCLKs */
+	reg8_write(client, 0x72, priv->vc_map >> (idx * 4));	/* CSI VC MAP */
+}
+
+static int ub9x4_initialize(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	int i, ret, timeout;
+	u8 port_sts1[4] = {0, 0, 0, 0}, port_sts2[4] = {0, 0, 0, 0};
+
+	dev_info(&client->dev, "LINKs=%d, LANES=%d, FORWARDING=%s, CABLE=%s, ID=%s\n",
+			       priv->n_links, priv->lanes, priv->forwarding_mode, priv->is_coax ? "coax" : "stp", priv->chip_id);
+
+	ub9x4_initial_setup(client);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i])) {
+			ret = regulator_enable(priv->poc_reg[i]); /* POC power on */
+			if (ret) {
+				dev_err(&client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ub9x4_fpdlink3_setup(client, i);
+	}
+
+	client->addr = priv->des_addr;
+
+	/* check lock status */
+	for (timeout = 500 / priv->n_links; timeout > 0; timeout--) {
+		for (i = 0; i < priv->n_links; i++) {
+			if ((port_sts1[i] & 0x1) && (port_sts2[i] & 0x4))
+				continue;
+
+			reg8_write(client, 0x4c, (i << 4) | (1 << i));	/* Select RX port number */
+			usleep_range(1000, 1500);
+			reg8_read(client, 0x4d, &port_sts1[i]);		/* Lock status */
+			reg8_read(client, 0x4e, &port_sts2[i]);		/* Freq stable */
+		}
+	}
+
+	if (!timeout)
+		dev_info(&client->dev, "Receiver lock status [%d,%d,%d,%d]\n",
+				       (port_sts1[0] & 0x1) && (port_sts2[0] & 0x4),
+				       (port_sts1[1] & 0x1) && (port_sts2[1] & 0x4),
+				       (port_sts1[2] & 0x1) && (port_sts2[2] & 0x4),
+				       (port_sts1[3] & 0x1) && (port_sts2[3] & 0x4));
+
+	if (priv->poc_delay)
+		mdelay(100);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!((port_sts1[i] & 0x1) && (port_sts2[i] & 0x4)))
+			continue;
+
+		reg8_write(client, 0x4c, (i << 4) | (1 << i));			/* Select RX port number */
+		usleep_range(1000, 1500);
+
+		/*
+		 * Enable only FSIN for remote gpio, all permanent states (0 or 1) setup on serializer side:
+		 * this avoids intermittent remote gpio noise (f.e. reset or spuriouse fsin) caused by
+		 * unstable/bad link, hence unstable backchannel
+		 */
+		client->addr = priv->ser_addr[i];				/* UB9X3 I2C addr */
+		switch (priv->ser_id) {
+		case UB913_ID:
+			reg8_write(client, 0x0d, 0x55);				/* Enable remote GPIO0/1 */
+			reg8_write(client, 0x11, 0x10);				/* I2C high pulse width */
+			reg8_write(client, 0x12, 0x10);				/* I2C low pulse width */
+			break;
+		case UB953_ID:
+			reg8_write(client, 0x0d, (priv->gpio[0] & 0x1) << 0 |
+						 (priv->gpio[1] & 0x1) << 1 |
+						 (priv->gpio[2] & 0x1) << 2 |
+						 (priv->gpio[3] & 0x1) << 3 |
+						 (priv->gpio[0] & 0x2) << 3 |
+						 (priv->gpio[1] & 0x2) << 4 |
+						 (priv->gpio[2] & 0x2) << 5 |
+						 (priv->gpio[3] & 0x2) << 6);	/* Enable FSIN remote GPIOs and set local constant gpios */
+			reg8_write(client, 0x0e, (!!priv->gpio[0] << 4) |
+						 (!!priv->gpio[1] << 5) |
+						 (!!priv->gpio[2] << 6) |
+						 (!!priv->gpio[3] << 7));	/* Enable serializer GPIOs only for output */
+			reg8_write(client, 0x0b, 0x10);				/* I2C high pulse width */
+			reg8_write(client, 0x0c, 0x10);				/* I2C low pulse width */
+			break;
+		}
+		client->addr = priv->des_addr;
+
+		reg8_write(client, 0x6e, 0x88 | (priv->gpio[1] << 4) | priv->gpio[0]); /* Remote GPIO1/GPIO0 setup */
+		reg8_write(client, 0x6f, 0x88 | (priv->gpio[3] << 4) | priv->gpio[2]); /* Remote GPIO3/GPIO2 setup */
+
+		priv->links_mask |= BIT(i);
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+	}
+
+	return 0;
+}
+
+static int ub9x4_post_initialize(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+
+	reg8_write(client, 0x33, ((priv->lanes - 1) ^ 0x3) << 4 | 0x1); /* enable CSI output, set CSI lane count, non-continuous CSI mode */
+	reg8_write(client, 0x18, 0x01);					/* Enable FrameSync, HI/LO mode, Frame clock from port0 */
+//	reg8_write(client, 0x18, 0x80);					/* Enable FrameSync, Frame clock is external */
+
+	return 0;
+}
+
+static int ub9x4_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	if (enable) {
+		if (atomic_inc_return(&priv->use_count) == 1)
+			reg8_write(client, 0x20, 0x00 | priv->csi_map); /* enable port forwarding to CSI */
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0)
+			reg8_write(client, 0x20, 0xf0 | priv->csi_map); /* disable port forwarding to CSI */
+	}
+
+	return 0;
+}
+
+static int ub9x4_g_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *ival)
+{
+	return 0;
+}
+
+static int ub9x4_s_frame_interval(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_frame_interval *ival)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	struct v4l2_fract *tpf = &ival->interval;
+
+	if (priv->fps_denominator != tpf->denominator ||
+	    priv->fps_numerator != tpf->numerator) {
+		int f_time;
+
+		f_time = priv->fs_time * 30 * tpf->numerator / tpf->denominator;
+		reg8_write(client, 0x1b, f_time >> 8);			/* FrameSync low time MSB */
+		reg8_write(client, 0x1c, f_time & 0xff);		/* FrameSync low time LSB */
+
+		priv->fps_denominator = tpf->denominator;
+		priv->fps_numerator = tpf->numerator;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops ub9x4_video_ops = {
+	.s_stream = ub9x4_s_stream,
+	.g_frame_interval = ub9x4_g_frame_interval,
+	.s_frame_interval = ub9x4_s_frame_interval,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ub9x4_g_register(struct v4l2_subdev *sd,
+				      struct v4l2_dbg_register *reg)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	int ret;
+	u8 val = 0;
+
+	ret = reg8_read(client, (u8)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u8);
+
+	return 0;
+}
+
+static int ub9x4_s_register(struct v4l2_subdev *sd,
+				      const struct v4l2_dbg_register *reg)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	return reg8_write(client, (u8)reg->reg, (u8)reg->val);
+}
+#endif
+
+static int ub9x4_reboot_notifier(struct notifier_block *nb, unsigned long event, void *buf)
+{
+	struct ub9x4_priv *priv = container_of(nb, struct ub9x4_priv, reboot_notifier);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct v4l2_subdev_core_ops ub9x4_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ub9x4_g_register,
+	.s_register = ub9x4_s_register,
+#endif
+};
+
+static struct v4l2_subdev_ops ub9x4_subdev_ops = {
+	.core = &ub9x4_subdev_core_ops,
+	.video = &ub9x4_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int ub9x4_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int ub9x4_i2c_mux_init(struct ub9x4_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->n_links, 0, I2C_MUX_LOCKED,
+				  ub9x4_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int ub9x4_notify_bound(struct v4l2_async_notifier *notifier,
+			      struct v4l2_subdev *subdev,
+			      struct v4l2_async_subdev *asd)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct ub9x4_sink *sink = asd_to_ub9x4_sink(asd);
+	int sink_pad = sink - &priv->sinks[0];
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, sink->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	sink->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void ub9x4_notify_unbind(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct ub9x4_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct ub9x4_sink *sink = asd_to_ub9x4_sink(asd);
+
+	sink->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations ub9x4_notify_ops = {
+	.bound = ub9x4_notify_bound,
+	.unbind = ub9x4_notify_unbind,
+};
+
+static int ub9x4_v4l2_init(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+	long pixel_rate;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+
+	priv->notifier.ops = &ub9x4_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ub9x4_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Only YUV422 bpp=16 supported atm, decode to pixel_rate from fixed csi_rate */
+	pixel_rate = priv->csi_rate / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  pixel_rate, pixel_rate, 1, pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[UB9X4_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[UB9X4_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[UB9X4_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[UB9X4_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[UB9X4_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, UB9X4_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, UB9X4_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int ub9x4_parse_dt(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	int err, i;
+	int sensor_delay;
+	struct property *prop;
+	u8 val = 0;
+	struct gpio_desc *pwdn_gpio;
+	u32 addrs[4], naddrs;
+
+	i = of_property_match_string(np, "reg-names", "ub9x4");
+	if (i >= 0)
+		of_property_read_u32_index(np, "reg", i, (unsigned int *)&client->addr);
+	priv->des_addr = client->addr;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+	priv->n_links = naddrs;
+	memcpy(priv->ser_addr, addrs, naddrs * sizeof(u32));
+
+	priv->ref_clk = v4l2_clk_get(&client->dev, "ref_clk");
+	if (!IS_ERR(priv->ref_clk)) {
+		dev_info(&client->dev, "ref_clk = %luKHz", v4l2_clk_get_rate(priv->ref_clk) / 1000);
+		v4l2_clk_enable(priv->ref_clk);
+	}
+
+	pwdn_gpio = devm_gpiod_get(&client->dev, "shutdown", GPIOD_OUT_HIGH);
+	if (!IS_ERR(pwdn_gpio)) {
+		mdelay(5);
+		gpiod_direction_output(pwdn_gpio, 0);
+		mdelay(5);
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->poc_reg[i] = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->poc_reg[i]) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+
+	reg8_read(client, 0x00, &val); /* read ub9x4 ID: self i2c address */
+	if (val != (priv->des_addr << 1))
+		return -ENODEV;
+
+	ub9x4_read_chipid(client);
+
+	if (!of_property_read_u32(np, "ti,sensor_delay", &sensor_delay))
+		mdelay(sensor_delay);
+	if (of_property_read_string(np, "ti,forwarding-mode", (const char **)&priv->forwarding_mode))
+		strncpy(priv->forwarding_mode, "round-robin", 16);
+	if (of_property_read_bool(np, "ti,stp"))
+		priv->is_coax = 0;
+	else
+		priv->is_coax = 1;
+	if (of_property_read_u32(np, "ti,dvp_bus", &priv->dvp_bus))
+		priv->dvp_bus = 8;
+	if (of_property_read_bool(np, "ti,dvp_lsb"))
+		priv->dvp_lsb = 1;
+	else
+		priv->dvp_lsb = 0;
+	if (of_property_read_u32(np, "ti,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "ti,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "ti,ser_id", &priv->ser_id))
+		priv->ser_id = UB913_ID;
+	if (of_property_read_u32(np, "ti,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 10;
+	if (of_property_read_u32(np, "ti,csi-rate", &priv->csi_rate))
+		priv->csi_rate = 1450;
+	if (of_property_read_u32(np, "ti,vc-map", &priv->vc_map))
+		priv->vc_map = 0x3210;
+	for (i = 0; i < 4; i++) {
+		char name[10];
+
+		sprintf(name, "ti,gpio%d", i);
+		if (of_property_read_u32(np, name, &priv->gpio[i]))
+			priv->gpio[i] = 0;
+	}
+
+	/*
+	 * CSI forwarding of all links is to CSI0 by default.
+	 * Decide if any link will be forwarded to CSI1 instead CSI0
+	 */
+	prop = of_find_property(np, "ti,csi1-links", NULL);
+	if (prop) {
+		const __be32 *link = NULL;
+		u32 v;
+
+		for (i = 0; i < 4; i++) {
+			link = of_prop_next_u32(prop, link, &v);
+			if (!link)
+				break;
+			priv->csi_map |= BIT(v);
+		}
+	} else {
+		priv->csi_map = 0;
+	}
+
+	/* module params override dts */
+	if (is_stp)
+		priv->is_coax = 0;
+	if (dvp_bus != 8)
+		priv->dvp_bus = dvp_bus;
+	if (dvp_lsb)
+		priv->dvp_lsb = dvp_lsb;
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (ser_id)
+		priv->ser_id = ser_id;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (vc_map != 0x3210)
+		priv->vc_map = vc_map;
+	if (csi_map)
+		priv->csi_map = csi_map;
+	if (gpio0)
+		priv->gpio[0] = gpio0;
+	if (gpio1)
+		priv->gpio[1] = gpio1;
+	if (gpio2)
+		priv->gpio[2] = gpio2;
+	if (gpio3)
+		priv->gpio[3] = gpio3;
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct ub9x4_sink *sink;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > UB9X4_N_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+				of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == UB9X4_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		sink = &priv->sinks[ep.port];
+		sink->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!sink->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		sink->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		sink->asd.match.fwnode = sink->fwnode;
+
+		priv->subdevs[ep.port] = &sink->asd;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int ub9x4_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ub9x4_priv *priv;
+	int err;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+	priv->fps_numerator = 1;
+	priv->fps_denominator = 30;
+
+	err = ub9x4_parse_dt(client);
+	if (err)
+		goto out;
+
+	err = ub9x4_i2c_mux_init(priv);
+	if (err) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	err = ub9x4_initialize(client);
+	if (err < 0)
+		goto out;
+
+	err = ub9x4_v4l2_init(client);
+	if (err < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+	ub9x4_post_initialize(client);
+
+	priv->reboot_notifier.notifier_call = ub9x4_reboot_notifier;
+	err = register_reboot_notifier(&priv->reboot_notifier);
+	if (err)
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+
+out:
+	return err;
+}
+
+static int ub9x4_remove(struct i2c_client *client)
+{
+	struct ub9x4_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	unregister_reboot_notifier(&priv->reboot_notifier);
+
+	i2c_mux_del_adapters(priv->mux);
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id ub9x4_dt_ids[] = {
+	{ .compatible = "ti,ub9x4" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ub9x4_dt_ids);
+
+static const struct i2c_device_id ub9x4_id[] = {
+	{ "ub9x4", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ub9x4_id);
+
+static struct i2c_driver ub9x4_i2c_driver = {
+	.driver = {
+		.name = "ub9x4",
+		.of_match_table = of_match_ptr(ub9x4_dt_ids),
+	},
+	.probe = ub9x4_probe,
+	.remove = ub9x4_remove,
+	.id_table = ub9x4_id,
+};
+
+module_i2c_driver(ub9x4_i2c_driver);
+
+MODULE_DESCRIPTION("FPDLinkIII driver for ds90ub9x4");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/fpdlink/ub9x4.h b/drivers/media/i2c/fpdlink/ub9x4.h
new file mode 100644
index 0000000..e89aa9a
--- /dev/null
+++ b/drivers/media/i2c/fpdlink/ub9x4.h
@@ -0,0 +1,19 @@
+/*
+ * TI FPDLinkIII driver include file
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#ifndef _UB9X4_H
+#define _UB9X4_H
+
+#define UB913_ID	0x58
+#define UB953_ID	0x30 /* or starapped to 0x32 */
+#define UB9X4_ID	0x00 /* strapped */
+
+#endif /* _UB9X4_H */
diff --git a/drivers/media/i2c/gmsl/Kconfig b/drivers/media/i2c/gmsl/Kconfig
new file mode 100644
index 0000000..6af5895
--- /dev/null
+++ b/drivers/media/i2c/gmsl/Kconfig
@@ -0,0 +1,47 @@
+#
+# GMSL video device configuration
+#
+
+config VIDEO_MAX9286
+	tristate "MAXIM MAX9286 GMSL deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a MAXIM MAX9286 GMSL deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called max9286.
+
+config VIDEO_MAX9288
+	tristate "MAXIM MAX9288 GMSL deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a MAXIM MAX9288 GMSL deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called max9288.
+
+config VIDEO_MAX9296
+	tristate "MAXIM MAX9296 GMSL2 deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a MAXIM MAX9296 GMSL2 deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called max9296.
+
+config VIDEO_MAX96712
+	tristate "MAXIM MAX96712 GMSL2 deserializer support"
+	depends on I2C && I2C_MUX
+	depends on VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a MAXIM MAX96712 GMSL2 deserializer driver
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called max96712.
diff --git a/drivers/media/i2c/gmsl/Makefile b/drivers/media/i2c/gmsl/Makefile
new file mode 100644
index 0000000..2424f19
--- /dev/null
+++ b/drivers/media/i2c/gmsl/Makefile
@@ -0,0 +1,5 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_VIDEO_MAX9286)	+= max9286.o
+obj-$(CONFIG_VIDEO_MAX9288)	+= max9288.o
+obj-$(CONFIG_VIDEO_MAX9296)	+= max9296.o
+obj-$(CONFIG_VIDEO_MAX96712)	+= max96712.o
diff --git a/drivers/media/i2c/gmsl/common.h b/drivers/media/i2c/gmsl/common.h
new file mode 100644
index 0000000..8418431
--- /dev/null
+++ b/drivers/media/i2c/gmsl/common.h
@@ -0,0 +1,508 @@
+/*
+ * MAXIM GMSL common header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/i2c-mux.h>
+#include "max9295.h"
+
+#define MAX9271_ID			0x09
+#define MAX9286_ID			0x40
+#define MAX9288_ID			0x2A
+#define MAX9290_ID			0x2C
+#define MAX9295A_ID			0x91
+#define MAX9295B_ID			0x93
+#define MAX9296A_ID			0x94
+#define MAX96705_ID			0x41
+#define MAX96706_ID			0x4A
+#define MAX96707_ID			0x45 /* MAX96715: same but lack of HS pin */
+#define MAX96708_ID			0x4C
+#define MAX96712_ID			0x20
+
+#define UB960_ID			0x00 /* strapped */
+
+#define BROADCAST			0x6f
+
+#define REG8_NUM_RETRIES		1 /* number of read/write retries */
+#define REG16_NUM_RETRIES		10 /* number of read/write retries */
+
+static inline char* chip_name(int id)
+{
+	switch (id) {
+	case MAX9271_ID:
+		return "MAX9271";
+	case MAX9286_ID:
+		return "MAX9286";
+	case MAX9288_ID:
+		return "MAX9288";
+	case MAX9290_ID:
+		return "MAX9290";
+	case MAX9295A_ID:
+		return "MAX9295A";
+	case MAX9295B_ID:
+		return "MAX9295B";
+	case MAX9296A_ID:
+		return "MAX9296A";
+	case MAX96705_ID:
+		return "MAX96705";
+	case MAX96706_ID:
+		return "MAX96706";
+	case MAX96707_ID:
+		return "MAX96707";
+	case MAX96712_ID:
+		return "MAX96712";
+	default:
+		return "serializer";
+	}
+}
+
+enum gmsl_mode {
+	MODE_GMSL1 = 1,
+	MODE_GMSL2,
+};
+
+#define MAXIM_I2C_I2C_SPEED_837KHZ	(0x7 << 2) /* 837kbps */
+#define MAXIM_I2C_I2C_SPEED_533KHZ	(0x6 << 2) /* 533kbps */
+#define MAXIM_I2C_I2C_SPEED_339KHZ	(0x5 << 2) /* 339 kbps */
+#define MAXIM_I2C_I2C_SPEED_173KHZ	(0x4 << 2) /* 174kbps */
+#define MAXIM_I2C_I2C_SPEED_105KHZ	(0x3 << 2) /* 105 kbps */
+#define MAXIM_I2C_I2C_SPEED_085KHZ	(0x2 << 2) /* 84.7 kbps */
+#define MAXIM_I2C_I2C_SPEED_028KHZ	(0x1 << 2) /* 28.3 kbps */
+#define MAXIM_I2C_I2C_SPEED		MAXIM_I2C_I2C_SPEED_339KHZ
+
+#define MIPI_DT_GENERIC			0x10
+#define MIPI_DT_GENERIC_1		0x11
+#define MIPI_DT_EMB			0x12
+#define MIPI_DT_YUV8			0x1e
+#define MIPI_DT_YUV10			0x1f
+#define MIPI_DT_RGB565			0x22
+#define MIPI_DT_RGB666			0x23
+#define MIPI_DT_RGB888			0x24
+#define MIPI_DT_RAW8			0x2a
+#define MIPI_DT_RAW10			0x2b
+#define MIPI_DT_RAW12			0x2c
+#define MIPI_DT_RAW14			0x2d
+#define MIPI_DT_RAW16			0x2e
+#define MIPI_DT_RAW20			0x2f
+#define MIPI_DT_YUV12			0x30
+
+static inline int mipi_dt_to_bpp(unsigned int dt)
+{
+	switch (dt) {
+		case 0x2a:
+		case 0x10 ... 0x12:
+		case 0x31 ... 0x37:
+			return 0x08;
+		case 0x2b:
+			return 0x0a;
+		case 0x2c:
+			return 0x0c;
+		case 0x0d:
+			return 0x0e;
+		case 0x22:
+		case 0x1e:
+		case 0x2e:
+			return 0x10;
+		case 0x23:
+			return 0x12;
+		case 0x1f:
+		case 0x2f:
+			return 0x14;
+		case 0x24:
+		case 0x30:
+			return 0x18;
+		default:
+			return 0x08;
+	}
+}
+
+static inline int reg8_read(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_read_byte_data(client, reg);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ret;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write(struct i2c_client *client, u8 reg, u8 val)
+{
+	int ret, retries;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_write_byte_data(client, reg, val);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg8_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read(struct i2c_client *client, u16 reg, u8 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 1);
+			if (ret == 1)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = buf[0];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write(struct i2c_client *client, u16 reg, u8 val)
+{
+	int ret, retries;
+	u8 buf[3] = {reg >> 8, reg & 0xff, val};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 3);
+		if (ret == 3)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2;
+		reg16_read(client, reg, &val2);
+		if (val != val2)
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x "
+				"0x%x->0x%x\n", client->addr, reg, val, val2);
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read16(struct i2c_client *client, u16 reg, u16 *val)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, buf, 2);
+			if (ret == 2)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	} else {
+		*val = ((u16)buf[0] << 8) | buf[1];
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write16(struct i2c_client *client, u16 reg, u16 val)
+{
+	int ret, retries;
+	u8 buf[4] = {reg >> 8, reg & 0xff, val >> 8, val & 0xff};
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 4);
+		if (ret == 4)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x: %d\n",
+			client->addr, reg, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_read_n(struct i2c_client *client, u16 reg, u8 *val, int n)
+{
+	int ret, retries;
+	u8 buf[2] = {reg >> 8, reg & 0xff};
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2);
+		if (ret == 2) {
+			ret = i2c_master_recv(client, val, n);
+			if (ret == n)
+				break;
+		}
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x registers 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg16_write_n(struct i2c_client *client, u16 reg, const u8* val, int n)
+{
+	int ret, retries;
+	u8 buf[8];
+
+	buf[0] = reg >> 8;
+	buf[1] = reg & 0xff;
+	memcpy(&buf[2], val, n);
+
+	for (retries = REG16_NUM_RETRIES; retries; retries--) {
+		ret = i2c_master_send(client, buf, 2 + n);
+		if (ret == 2 + n)
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x-0x%x: %d\n",
+			client->addr, reg, reg + n, ret);
+	} else {
+#ifdef WRITE_VERIFY
+		u8 val2[n];
+		ret = reg16_read_n(client, reg, val2, n);
+		if (ret < 0)
+			return ret;
+
+		if (memcmp(val, val2, n)) {
+			dev_err(&client->dev,
+				"write verify mismatch: chip 0x%x reg=0x%x-0x%x "
+				"'%*phN'->'%*phN'\n", client->addr, reg, reg + n,
+				n, val, n, val2);
+				ret = -EBADE;
+		}
+#endif
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_read_addr(struct i2c_client *client, int addr, u8 reg, u8 *val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_READ, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"read fail: chip 0x%x register 0x%x: %d\n",
+			addr, reg, ret);
+	} else {
+		*val = data.byte;
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static inline int reg8_write_addr(struct i2c_client *client, u8 addr, u8 reg, u8 val)
+{
+	int ret, retries;
+	union i2c_smbus_data data;
+
+	data.byte = val;
+
+	for (retries = REG8_NUM_RETRIES; retries; retries--) {
+		ret = i2c_smbus_xfer(client->adapter, addr, client->flags,
+				     I2C_SMBUS_WRITE, reg, I2C_SMBUS_BYTE_DATA, &data);
+		if (!(ret < 0))
+			break;
+	}
+
+	if (ret < 0) {
+		dev_dbg(&client->dev,
+			"write fail: chip 0x%x register 0x%x value 0x%0x: %d\n",
+			addr, reg, val, ret);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+
+static inline int reg16_write_addr(struct i2c_client *client, int chip, u16 reg, u8 val)
+{
+	struct i2c_msg msg[1];
+	u8 wbuf[3];
+	int ret;
+
+	msg->addr = chip;
+	msg->flags = 0;
+	msg->len = 3;
+	msg->buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+	wbuf[2] = val;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x wr 0x%04x (0x%02x): %d\n",
+			chip, reg, val, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static inline int reg16_read_addr(struct i2c_client *client, int chip, u16 reg, int *val)
+{
+	struct i2c_msg msg[2];
+	u8 wbuf[2];
+	u8 rbuf[1];
+	int ret;
+
+	msg[0].addr = chip;
+	msg[0].flags = 0;
+	msg[0].len = 2;
+	msg[0].buf = wbuf;
+	wbuf[0] = reg >> 8;
+	wbuf[1] = reg & 0xff;
+
+	msg[1].addr = chip;
+	msg[1].flags = I2C_M_RD;
+	msg[1].len = 1;
+	msg[1].buf = rbuf;
+
+	ret = i2c_transfer(client->adapter, msg, 2);
+	if (ret < 0) {
+		dev_dbg(&client->dev, "i2c fail: chip 0x%02x rd 0x%04x: %d\n", chip, reg, ret);
+		return ret;
+	}
+
+	*val = rbuf[0];
+
+	return 0;
+}
+
+#define __reg8_read(addr, reg, val)		reg8_read_addr(priv->client, addr, reg, val)
+#define __reg8_write(addr, reg, val)		reg8_write_addr(priv->client, addr, reg, val)
+#define __reg16_read(addr, reg, val)		reg16_read_addr(priv->client, addr, reg, val)
+#define __reg16_write(addr, reg, val)		reg16_write_addr(priv->client, addr, reg, val)
+
+/* copy this struct from drivers/i2c/i2c-mux.c for getting muxc from adapter private data */
+struct i2c_mux_priv {
+	struct i2c_adapter adap;
+	struct i2c_algorithm algo;
+	struct i2c_mux_core *muxc;
+	u32 chan_id;
+};
+
+static inline int get_des_id(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9286"))
+		return MAX9286_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9288"))
+		return MAX9288_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max9296"))
+		return MAX9296A_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96706"))
+		return MAX96706_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "max96712"))
+		return MAX96712_ID;
+	if (!strcmp(mux_priv->muxc->dev->driver->name, "ub9x4"))
+		return UB960_ID;
+
+	return -EINVAL;
+}
+
+static inline int get_des_addr(struct i2c_client *client)
+{
+	struct i2c_mux_priv *mux_priv = client->adapter->algo_data;
+
+	return to_i2c_client(mux_priv->muxc->dev)->addr;
+}
+
+static inline void setup_i2c_translator(struct i2c_client *client, int ser_addr, int sensor_addr)
+{
+	int gmsl_mode = MODE_GMSL2;
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX96706_ID:
+		reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		/* parse gmsl mode from deserializer */
+		reg16_read_addr(client, get_des_addr(client), 6, &gmsl_mode);
+		gmsl_mode = !!(gmsl_mode & BIT(7)) + 1;
+
+		if (gmsl_mode == MODE_GMSL1) {
+			reg8_write_addr(client, ser_addr, 0x09, client->addr << 1);	/* Sensor translated I2C address */
+			reg8_write_addr(client, ser_addr, 0x0A, sensor_addr << 1);	/* Sensor native I2C address */
+		}
+		if (gmsl_mode == MODE_GMSL2) {
+			reg16_write_addr(client, ser_addr, MAX9295_I2C2, client->addr << 1); /* Sensor translated I2C address */
+			reg16_write_addr(client, ser_addr, MAX9295_I2C3, sensor_addr << 1); /* Sensor native I2C address */
+		}
+		break;
+	case UB960_ID:
+		reg8_write_addr(client, get_des_addr(client), 0x65, client->addr << 1);	/* Sensor translated I2C address */
+		reg8_write_addr(client, get_des_addr(client), 0x5d, sensor_addr << 1);	/* Sensor native I2C address */
+		break;
+	}
+	usleep_range(2000, 2500);
+}
diff --git a/drivers/media/i2c/gmsl/max9286.c b/drivers/media/i2c/gmsl/max9286.c
new file mode 100644
index 0000000..223bedd0
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9286.c
@@ -0,0 +1,1120 @@
+/*
+ * MAXIM max9286 GMSL driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+
+#define MAX9286_N_LINKS		4
+
+enum max9286_pads {
+	MAX9286_SINK_LINK0,
+	MAX9286_SINK_LINK1,
+	MAX9286_SINK_LINK2,
+	MAX9286_SINK_LINK3,
+	MAX9286_SOURCE,
+	MAX9286_N_PADS,
+};
+
+struct max9286_sink {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+};
+
+#define asd_to_max9286_sink(_asd) \
+	container_of(_asd, struct max9286_sink, asd)
+
+struct max9286_priv {
+	struct i2c_client	*client;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[MAX9286_N_PADS];
+
+	struct i2c_mux_core	*mux;
+
+	struct max9286_sink	sinks[MAX9286_N_LINKS];
+	struct v4l2_async_subdev *subdevs[MAX9286_N_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			des_addr;
+	int			des_quirk_addr; /* second MAX9286 on the same I2C bus */
+	int			n_links;
+	int			links_mask;
+	int			lanes;
+	long			pixel_rate;
+	const char		*fsync_mode;
+	int			fsync_period;
+	int			pclk;
+	char			pclk_rising_edge;
+	int			gpio_resetb;
+	int			active_low_resetb;
+	int			him;
+	int			hsync;
+	int			vsync;
+	int			timeout;
+	int			poc_delay;
+	int			bws;
+	int			dbl;
+	int			dt;
+	int			hsgen;
+	u64			crossbar;
+	char			cb[16];
+	int			hts;
+	int			vts;
+	int			hts_delay;
+	atomic_t		use_count;
+	u32			csi2_outord;
+	u32			switchin;
+	int			ser_addr[4];
+	int			ser_id;
+	struct regulator	*poc_reg[4]; /* PoC power supply */
+	struct notifier_block	reboot_notifier;
+	/* link statistic */
+	int			prbserr[4];
+	int			deterr[4];
+	int			correrr[4];
+};
+
+#include "max9286_debug.h"
+
+static char fsync_mode_default[20] = "automatic"; /* manual, automatic, semi-automatic, external */
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int poc_trig;
+module_param(poc_trig, int, 0644);
+MODULE_PARM_DESC(poc_trig, " Use PoC triggering during reverse channel setup. Useful on systems with dedicated PoC and unstable ser-des lock");
+
+static int him;
+module_param(him, int, 0644);
+MODULE_PARM_DESC(him, " Use High-Immunity mode (default: leagacy mode)");
+
+static int fsync_period;
+module_param(fsync_period, int, 0644);
+MODULE_PARM_DESC(fsync_period, " Frame sync period (default: 3.2MHz)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int gpio_resetb;
+module_param(gpio_resetb, int, 0644);
+MODULE_PARM_DESC(gpio_resetb, " Serializer GPIO reset (default: 0 - not used)");
+
+static int active_low_resetb;
+module_param(active_low_resetb, int, 0644);
+MODULE_PARM_DESC(active_low_resetb, " Serializer GPIO reset level (default: 0 - active high)");
+
+static int timeout_n = 100;
+module_param(timeout_n, int, 0644);
+MODULE_PARM_DESC(timeout_n, " Timeout of link detection (default: 100 retries)");
+
+static int poc_delay = 50;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 50 ms)");
+
+static int bws;
+module_param(bws, int, 0644);
+MODULE_PARM_DESC(bws, " BWS mode (default: 0 - 24-bit gmsl packets)");
+
+static int dbl = 1;
+module_param(dbl, int, 0644);
+MODULE_PARM_DESC(dbl, " DBL mode (default: 1 - DBL mode enabled)");
+
+static int dt = 3;
+module_param(dt, int, 0644);
+MODULE_PARM_DESC(dt, " DataType (default: 3 - YUV8), 0 - RGB888, 5 - RAW8, 6 - RAW10, 7 - RAW12, 8 - RAW14");
+
+static int hsgen;
+module_param(hsgen, int, 0644);
+MODULE_PARM_DESC(hsgen, " Enable HS embedded generator (default: 0 - disabled)");
+
+static int pclk = 100;
+module_param(pclk, int, 0644);
+MODULE_PARM_DESC(pclk, " PCLK rate (default: 100MHz)");
+
+static int switchin = 0;
+module_param(switchin, int, 0644);
+MODULE_PARM_DESC(switchin, " COAX SWITCH IN+ and IN- (default: 0 - not switched)");
+
+static unsigned long crossbar = 0xba9876543210;
+module_param(crossbar, ulong, 0644);
+MODULE_PARM_DESC(crossbar, " Crossbar setup (default: ba9876543210 - reversed)");
+
+enum {
+	RGB888_DT = 0,
+	RGB565_DT,
+	RGB666_DT,
+	YUV8_DT, /* default */
+	YUV10_DT,
+	RAW8_DT,
+	RAW10_DT,
+	RAW12_DT,
+	RAW14_DT,
+};
+
+static int dt2bpp[9] = {
+	24,	/* RGB888 */
+	16,	/* RGB565 */
+	18,	/* RGB666 */
+	8,	/* YUV8 - default */
+	10,	/* YUV10 */
+	8,	/* RAW8/RAW16 */
+	10,	/* RAW10 */
+	12,	/* RAW12 */
+	14,	/* RAW14 */
+};
+
+static void max9286_write_remote_verify(struct i2c_client *client, int idx, u8 reg, u8 val)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int timeout;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		int tmp_addr;
+		u8 sts = 0;
+		u8 val2 = 0;
+
+		reg8_write(client, reg, val);
+
+		tmp_addr = client->addr;
+		client->addr = priv->des_addr;
+		reg8_read(client, 0x70, &sts);
+		client->addr = tmp_addr;
+		if (sts & BIT(idx)) /* if ACKed */ {
+			reg8_read(client, reg, &val2);
+			if (val2 == val)
+				break;
+		}
+
+		usleep_range(1000, 1500);
+	}
+
+	if (timeout >= 10)
+		dev_err(&client->dev, "timeout remote write acked\n");
+}
+
+static void max9286_preinit(struct i2c_client *client, int addr)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	client->addr = addr;
+	reg8_write(client, 0x0a, 0x00);		/* disable reverse control for all cams */
+	reg8_write(client, 0x00, 0x00);		/* disable all GMSL links [0:3] */
+//	usleep_range(2000, 2500);
+	reg8_write(client, 0x1b, priv->switchin); /* coax polarity (default - normal) */
+	reg8_write(client, 0x1c, (priv->him ? 0xf0 : 0x00) |
+				 (priv->bws ? 0x05 : 0x04)); /* high-immunity/legacy mode, BWS 24bit */
+}
+
+static void max9286_sensor_reset(struct i2c_client *client, int addr, int reset_on)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	if (priv->ser_id == MAX96707_ID)
+		return;
+
+	if (priv->gpio_resetb < 1 || priv->gpio_resetb > 5)
+		return;
+
+	if (priv->active_low_resetb)
+		reset_on = !reset_on;
+
+	/* sensor reset/unreset using serializer gpio */
+	client->addr = addr;
+	reg8_write(client, 0x0f, (0xfe & ~BIT(priv->gpio_resetb)) | (reset_on ? BIT(priv->gpio_resetb) : 0)); /* set GPIOn value */
+	reg8_write(client, 0x0e, 0x42 | BIT(priv->gpio_resetb)); /* set GPIOn direction output */
+}
+
+static void max9286_postinit(struct i2c_client *client, int addr)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int idx;
+
+	for (idx = 0; idx < priv->n_links; idx++) {
+		if (priv->ser_id == MAX96705_ID || priv->ser_id == MAX96707_ID)
+			continue;
+
+		client->addr = priv->des_addr;
+		reg8_write(client, 0x00, 0xe0 | BIT(idx));	/* enable GMSL link for CAMx */
+		reg8_write(client, 0x0a, 0x11 << idx);		/* enable reverse/forward control for CAMx */
+		usleep_range(5000, 5500);
+
+		client->addr = priv->ser_addr[idx];
+		max9286_sensor_reset(client, client->addr, 0);	/* sensor unreset using gpios. TODO: should be in imager driver */
+	}
+
+	client->addr = addr;
+	reg8_write(client, 0x0a, 0x00);				/* disable reverse control for all cams */
+	reg8_write(client, 0x00, 0xe0 | priv->links_mask);	/* enable GMSL link for CAMs */
+	reg8_write(client, 0x0b, priv->csi2_outord);		/* CSI2 output order */
+	reg8_write(client, 0x15, 0x9b);				/* enable CSI output, VC is set accordingly to Link number, BIT7 magic must be set */
+	reg8_write(client, 0x1b, priv->switchin | priv->links_mask); /* coax polarity, enable equalizer for CAMs */
+	reg8_write(client, 0x34, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	usleep_range(5000, 5500);
+
+	if (strcmp(priv->fsync_mode, "manual") == 0) {
+		reg8_write(client, 0x01, 0x00);			/* manual: FRAMESYNC set manually via [0x06:0x08] regs */
+	} else if (strcmp(priv->fsync_mode, "automatic") == 0) {
+		reg8_write(client, 0x01, 0x02);			/* automatic: FRAMESYNC taken from the slowest Link */
+	} else if (strcmp(priv->fsync_mode, "semi-automatic") == 0) {
+		reg8_write(client, 0x01, 0x01);			/* semi-automatic: FRAMESYNC taken from the slowest Link */
+	} else if (strcmp(priv->fsync_mode, "external") == 0) {
+		reg8_write(client, 0x01, 0xc0);			/* ECU (aka MCU) based FrameSync using GPI-to-GPO */
+	}
+}
+
+static int max9286_reverse_channel_setup(struct i2c_client *client, int idx)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	u8 val = 0, lock_sts = 0, link_sts = 0;
+	int timeout = priv->timeout;
+	char timeout_str[40];
+	int ret = 0;
+
+	/* Reverse channel enable */
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x34, 0xa2 | MAXIM_I2C_I2C_SPEED);	/* enable artificial ACKs, I2C speed set */
+	usleep_range(2000, 2500);
+	reg8_write(client, 0x00, 0xe0 | BIT(idx));		/* enable GMSL link for CAMx */
+	reg8_write(client, 0x0a, 0x11 << idx);			/* enable reverse control for CAMx */
+	usleep_range(2000, 2500);
+
+	for (;;) {
+		if (priv->him) {
+			/* HIM mode setup */
+			client->addr = 0x40;
+			reg8_write(client, 0x4d, 0xc0);
+			usleep_range(2000, 2500);
+			reg8_write(client, 0x04, 0x43);		/* wake-up, enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				reg8_write(client, 0x07, 0x04 | (priv->pclk_rising_edge ? 0 : 0x10) |
+							 (priv->dbl ? 0x80 : 0) |
+							 (priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding enabled, DBL mode, BWS 24/32-bit */
+				usleep_range(2000, 2500);
+			}
+		} else {
+			/* Legacy mode setup */
+			client->addr = priv->des_addr;
+			reg8_write(client, 0x3f, 0x4f);		/* enable custom reverse channel & first pulse length */
+			reg8_write(client, 0x3b, 0x1e);		/* first pulse length rise time changed from 300ns to 200ns, amplitude 100mV */
+			usleep_range(2000, 2500);
+
+			client->addr = 0x40;
+			reg8_write(client, 0x04, 0x43);		/* wake-up, enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			reg8_write(client, 0x08, 0x01);		/* reverse channel receiver high threshold enable */
+			reg8_write(client, 0x97, 0x5f);		/* enable reverse control channel programming (MAX96705-MAX96711 only) */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				reg8_write(client, 0x07, 0x04 | (priv->pclk_rising_edge ? 0 : 0x10) |
+							 (priv->dbl ? 0x80 : 0) |
+							 (priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding enabled, DBL mode, BWS 24/32-bit */
+				usleep_range(2000, 2500);
+			}
+
+			client->addr = priv->des_addr;
+			reg8_write(client, 0x3b, 0x19);		/* reverse channel increase amplitude 170mV to compensate high threshold enabled */
+			usleep_range(2000, 2500);
+		}
+
+		client->addr = 0x40;
+		reg8_read(client, 0x1e, &val);			/* read max9271 ID */
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID || --timeout == 0) {
+			priv->ser_id = val;
+			break;
+		}
+
+		/* Check if already initialized (after reboot/reset ?) */
+		client->addr = priv->ser_addr[idx];
+		reg8_read(client, 0x1e, &val);			/* read max9271 ID */
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			priv->ser_id = val;
+			reg8_write(client, 0x04, 0x43);		/* enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			ret = -EADDRINUSE;
+			break;
+		}
+
+		if (poc_trig) {
+			if (!IS_ERR(priv->poc_reg[idx]) && (timeout % poc_trig == 0)) {
+				regulator_disable(priv->poc_reg[idx]); /* POC power off */
+				mdelay(200);
+				ret = regulator_enable(priv->poc_reg[idx]); /* POC power on */
+				if (ret)
+					dev_err(&client->dev, "failed to enable poc regulator\n");
+				mdelay(priv->poc_delay);
+			}
+		}
+	}
+
+	max9286_sensor_reset(client, client->addr, 1);	/* sensor reset */
+
+	client->addr = priv->des_addr;			/* MAX9286-CAMx I2C */
+	reg8_read(client, 0x27, &lock_sts);		/* LOCK status */
+	reg8_read(client, 0x49, &link_sts);		/* LINK status */
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	priv->links_mask |= BIT(idx);
+	priv->csi2_outord &= ~(0x3 << (idx * 2));
+	priv->csi2_outord |= ((hweight8(priv->links_mask) - 1) << (idx * 2));
+
+out:
+	sprintf(timeout_str, "retries=%d lock_sts=%d link_sts=0x%x", priv->timeout - timeout, !!(lock_sts & 0x80), link_sts & (0x11 << idx));
+	dev_info(&client->dev, "link%d %s %sat 0x%x %s %s\n", idx, chip_name(priv->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", priv->ser_addr[idx],
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL link establish" : "",
+			       priv->timeout - timeout ? timeout_str : "");
+
+	return ret;
+}
+
+static void max9286_initial_setup(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	/* Initial setup */
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x15, 0x13);				/* disable CSI output, VC is set accordingly to Link number */
+	reg8_write(client, 0x69, 0x0f);				/* mask CSI forwarding from all links */
+	reg8_write(client, 0x12, ((priv->lanes - 1) << 6) |
+				 (priv->dbl ? 0x30 : 0) |
+				 (priv->dt & 0xf));		/* setup lanes, DBL mode, DataType */
+
+	/* Start GMSL initialization with FSYNC disabled. This is required for some odd LVDS cameras */
+	reg8_write(client, 0x01, 0xc0);				/* ECU (aka MCU) based FrameSync using GPI-to-GPO */
+	reg8_write(client, 0x06, priv->fsync_period & 0xff);
+	reg8_write(client, 0x07, (priv->fsync_period >> 8) & 0xff);
+	reg8_write(client, 0x08, priv->fsync_period >> 16);
+
+	reg8_write(client, 0x63, 0);				/* disable overlap window */
+	reg8_write(client, 0x64, 0);
+	reg8_write(client, 0x0c, 0x91 | (priv->vsync ? BIT(3) : 0) | (priv->hsync ? BIT(2) : 0)); /* enable HS/VS encoding, use D14/15 for HS/VS, invert HS/VS */
+	reg8_write(client, 0x19, 0x0c);				/* Drive HSTRAIL state for 120ns after the last payload bit */
+}
+
+static void max9286_gmsl_link_setup(struct i2c_client *client, int idx)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	/* GMSL setup */
+	client->addr = 0x40;
+	reg8_write(client, 0x0d, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	reg8_write(client, 0x07, 0x04 | (priv->pclk_rising_edge ? 0 : 0x10) |
+					(priv->dbl ? 0x80 : 0) |
+					(priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding enabled, DBL mode, BWS 24/32-bit */
+	usleep_range(2000, 2500);
+	reg8_write(client, 0x02, 0xff);				/* spread spectrum +-4%, pclk range automatic, Gbps automatic  */
+	usleep_range(2000, 2500);
+
+	if (priv->ser_id == MAX96705_ID || priv->ser_id == MAX96707_ID) {
+		switch (priv->dt) {
+		case YUV8_DT:
+			/* setup crossbar for YUV8/RAW8: reverse DVP bus */
+			reg8_write(client, 0x20, priv->cb[7]);
+			reg8_write(client, 0x21, priv->cb[6]);
+			reg8_write(client, 0x22, priv->cb[5]);
+			reg8_write(client, 0x23, priv->cb[4]);
+			reg8_write(client, 0x24, priv->cb[3]);
+			reg8_write(client, 0x25, priv->cb[2]);
+			reg8_write(client, 0x26, priv->cb[1]);
+			reg8_write(client, 0x27, priv->cb[0]);
+
+			/* this is second byte if DBL=1 */
+			reg8_write(client, 0x30, priv->cb[7] + 16);
+			reg8_write(client, 0x31, priv->cb[6] + 16);
+			reg8_write(client, 0x32, priv->cb[5] + 16);
+			reg8_write(client, 0x33, priv->cb[4] + 16);
+			reg8_write(client, 0x34, priv->cb[3] + 16);
+			reg8_write(client, 0x35, priv->cb[2] + 16);
+			reg8_write(client, 0x36, priv->cb[1] + 16);
+			reg8_write(client, 0x37, priv->cb[0] + 16);
+			break;
+		case RAW12_DT:
+			/* setup crossbar for RAW12: reverse DVP bus */
+			reg8_write(client, 0x20, priv->cb[11]);
+			reg8_write(client, 0x21, priv->cb[10]);
+			reg8_write(client, 0x22, priv->cb[9]);
+			reg8_write(client, 0x23, priv->cb[8]);
+			reg8_write(client, 0x24, priv->cb[7]);
+			reg8_write(client, 0x25, priv->cb[6]);
+			reg8_write(client, 0x26, priv->cb[5]);
+			reg8_write(client, 0x27, priv->cb[4]);
+			reg8_write(client, 0x28, priv->cb[3]);
+			reg8_write(client, 0x29, priv->cb[2]);
+			reg8_write(client, 0x2a, priv->cb[1]);
+			reg8_write(client, 0x2b, priv->cb[0]);
+
+			/* this is second byte if DBL=1 */
+			reg8_write(client, 0x30, priv->cb[11] + 16);
+			reg8_write(client, 0x31, priv->cb[10] + 16);
+			reg8_write(client, 0x32, priv->cb[9] + 16);
+			reg8_write(client, 0x33, priv->cb[8] + 16);
+			reg8_write(client, 0x34, priv->cb[7] + 16);
+			reg8_write(client, 0x35, priv->cb[6] + 16);
+			reg8_write(client, 0x36, priv->cb[5] + 16);
+			reg8_write(client, 0x37, priv->cb[4] + 16);
+			reg8_write(client, 0x38, priv->cb[3] + 16);
+			reg8_write(client, 0x39, priv->cb[2] + 16);
+			reg8_write(client, 0x3a, priv->cb[1] + 16);
+			reg8_write(client, 0x3b, priv->cb[0] + 16);
+
+			if (!priv->bws && priv->dbl)
+				dev_err(&client->dev, " BWS must be 27/32-bit for RAW12 in DBL mode\n");
+
+			break;
+		}
+
+		if (priv->hsgen) {
+			/* HS/VS pins map */
+			reg8_write(client, 0x3f, 0x10);			/* HS (NC) */
+			reg8_write(client, 0x41, 0x10);			/* DE (NC) */
+			if (priv->ser_id == MAX96705_ID)
+				reg8_write(client, 0x40, 15);		/* VS (DIN13) */
+			if (priv->ser_id == MAX96707_ID)
+				reg8_write(client, 0x40, 13);		/* VS (DIN13) */
+#if 0
+			/* following must come from imager */
+#define SENSOR_WIDTH	(1280*2)
+#define HTS		(1288*2)
+#define VTS		960
+#define HTS_DELAY	0x9
+			reg8_write(client, 0x4e, HTS_DELAY >> 16);	/* HS delay */
+			reg8_write(client, 0x4f, (HTS_DELAY >> 8) & 0xff);
+			reg8_write(client, 0x50, HTS_DELAY & 0xff);
+			reg8_write(client, 0x54, SENSOR_WIDTH >> 8);	/* HS high period */
+			reg8_write(client, 0x55, SENSOR_WIDTH & 0xff);
+			reg8_write(client, 0x56, (HTS - SENSOR_WIDTH) >> 8); /* HS low period */
+			reg8_write(client, 0x57, (HTS - SENSOR_WIDTH) & 0xff);
+			reg8_write(client, 0x58, VTS >> 8);		/* HS count */
+			reg8_write(client, 0x59, VTS & 0xff );
+#endif
+			reg8_write(client, 0x43, 0x15);			/* enable HS generator */
+		}
+	}
+
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x34, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	usleep_range(2000, 2500);
+
+	/* I2C translator setup */
+	client->addr = 0x40;
+//	reg8_write(client, 0x09, maxim_map[2][idx] << 1);	/* SENSOR I2C translated - must be set by sensor driver */
+//	reg8_write(client, 0x0A, 0x30 << 1);			/* SENSOR I2C native - must be set by sensor driver */
+	reg8_write(client, 0x0B, BROADCAST << 1);		/* broadcast I2C */
+	reg8_write(client, 0x0C, priv->ser_addr[idx] << 1);
+	/* I2C addresse change */
+	reg8_write(client, 0x01, priv->des_addr << 1);
+	reg8_write(client, 0x00, priv->ser_addr[idx] << 1);
+	usleep_range(2000, 2500);
+	/* put MAX9271 in configuration link state  */
+	client->addr = priv->ser_addr[idx];
+	reg8_write(client, 0x04, 0x43);				/* enable reverse_control/conf_link */
+	usleep_range(2000, 2500);
+}
+
+static int max9286_initialize(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int i, ret;
+
+	dev_info(&client->dev, "LINKs=%d, LANES=%d, FSYNC mode=%s, FSYNC period=%d, PCLK edge=%s\n",
+			       priv->n_links, priv->lanes, priv->fsync_mode, priv->fsync_period,
+			       priv->pclk_rising_edge ? "rising" : "falling");
+
+	if (priv->des_quirk_addr)
+		max9286_preinit(client, priv->des_quirk_addr);
+
+	max9286_preinit(client, priv->des_addr);
+	max9286_initial_setup(client);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i])) {
+			ret = regulator_enable(priv->poc_reg[i]); /* POC power on */
+			if (ret) {
+				dev_err(&client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ret = max9286_reverse_channel_setup(client, i);
+		if (ret == -ETIMEDOUT)
+			continue;
+		if (!ret)
+			max9286_gmsl_link_setup(client, i);
+
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+	}
+
+	max9286_postinit(client, priv->des_addr);
+
+	client->addr = priv->des_addr;
+
+	return 0;
+}
+
+static int max9286_post_initialize(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int idx;
+
+	for (idx = 0; idx < priv->n_links; idx++) {
+		if (!(priv->links_mask & (1 << idx)))
+			continue;
+
+		client->addr = priv->des_addr;
+		reg8_write(client, 0x0a, 0x11 << idx); /* enable reverse/forward control for CAMx */
+//		usleep_range(5000, 5500);
+
+		/* switch to GMSL serial_link for streaming video */
+		client->addr = priv->ser_addr[idx];
+		max9286_write_remote_verify(client, idx, 0x04, conf_link ? 0x43 : 0x83);
+	}
+
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x0a, (priv->links_mask << 4) | priv->links_mask); /* enable reverse/forward control for all detected CAMs */
+
+	return 0;
+}
+
+static int max9286_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	if (enable) {
+		if (atomic_inc_return(&priv->use_count) == 1)
+			reg8_write(client, 0x69, priv->links_mask ^ 0x0f); /* unmask CSI forwarding from detected links */
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0)
+			reg8_write(client, 0x69, 0x0f); /* mask CSI forwarding from all links */
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops max9286_video_ops = {
+	.s_stream	= max9286_s_stream,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int max9286_g_register(struct v4l2_subdev *sd,
+				      struct v4l2_dbg_register *reg)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	int ret;
+	u8 val = 0;
+
+	ret = reg8_read(client, (u8)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u8);
+
+	return 0;
+}
+
+static int max9286_s_register(struct v4l2_subdev *sd,
+				      const struct v4l2_dbg_register *reg)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	return reg8_write(client, (u8)reg->reg, (u8)reg->val);
+}
+#endif
+
+static int max9286_reboot_notifier(struct notifier_block *nb, unsigned long event, void *buf)
+{
+	struct max9286_priv *priv = container_of(nb, struct max9286_priv, reboot_notifier);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static struct v4l2_subdev_core_ops max9286_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register	= max9286_g_register,
+	.s_register	= max9286_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_ops max9286_subdev_ops = {
+	.core		= &max9286_subdev_core_ops,
+	.video		= &max9286_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int max9286_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int max9286_i2c_mux_init(struct max9286_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->n_links, 0, I2C_MUX_LOCKED,
+				  max9286_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int max9286_notify_bound(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9286_sink *sink = asd_to_max9286_sink(asd);
+	int sink_pad = sink - &priv->sinks[0];
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, sink->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	sink->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void max9286_notify_unbind(struct v4l2_async_notifier *notifier,
+				  struct v4l2_subdev *subdev,
+				  struct v4l2_async_subdev *asd)
+{
+	struct max9286_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9286_sink *sink = asd_to_max9286_sink(asd);
+
+	sink->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations max9286_notify_ops = {
+	.bound = max9286_notify_bound,
+	.unbind = max9286_notify_unbind,
+};
+
+static int max9286_v4l2_init(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+
+	priv->notifier.ops = &max9286_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &max9286_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* CSI2_RATE = PCLK*bpp*n_links/lanes*/
+	priv->pixel_rate = priv->pclk * 2 * dt2bpp[priv->dt] / 8 * hweight8(priv->links_mask) / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  priv->pixel_rate, priv->pixel_rate, 1, priv->pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[MAX9286_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[MAX9286_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9286_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9286_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9286_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, MAX9286_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, MAX9286_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int max9286_parse_dt(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	int err, i;
+	int sensor_delay, gpio0 = 1, gpio1 = 1;
+	u8 val = 0;
+	struct gpio_desc *pwdn_gpio;
+	u32 addrs[4], naddrs;
+
+	i = of_property_match_string(np, "reg-names", "max9286");
+	if (i >= 0)
+		of_property_read_u32_index(np, "reg", i, (unsigned int *)&client->addr);
+	priv->des_addr = client->addr;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+
+	priv->n_links = naddrs;
+	memcpy(priv->ser_addr, addrs, naddrs * sizeof(u32));
+
+	pwdn_gpio = devm_gpiod_get_optional(&client->dev, "shutdown", GPIOD_OUT_HIGH);
+	if (!IS_ERR(pwdn_gpio)) {
+		udelay(5);
+		gpiod_set_value_cansleep(pwdn_gpio, 0);
+		mdelay(10);
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->poc_reg[i] = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->poc_reg[i]) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+
+	reg8_read(client, 0x1e, &val); /* read max9286 ID */
+	if (val != MAX9286_ID)
+		return -ENODEV;
+
+	if (!of_property_read_u32(np, "maxim,gpio0", &gpio0) ||
+	    !of_property_read_u32(np, "maxim,gpio1", &gpio1))
+		reg8_write(client, 0x0f, 0x08 | (gpio1 << 1) | gpio0);
+
+	if (of_property_read_u32(np, "maxim,resetb-gpio", &priv->gpio_resetb)) {
+		priv->gpio_resetb = -1;
+	} else {
+		if (of_property_read_bool(np, "maxim,resetb-active-high"))
+			priv->active_low_resetb = 0;
+		else
+			priv->active_low_resetb = 1;
+	}
+
+	if (!of_property_read_u32(np, "maxim,sensor_delay", &sensor_delay))
+		mdelay(sensor_delay);
+	if (of_property_read_string(np, "maxim,fsync-mode", &priv->fsync_mode))
+		priv->fsync_mode = fsync_mode_default;
+	if (of_property_read_u32(np, "maxim,fsync-period", &priv->fsync_period))
+		priv->fsync_period = 3200000;			/* 96MHz/30fps */
+	priv->pclk_rising_edge = true;
+	if (of_property_read_bool(np, "maxim,pclk-falling-edge"))
+		priv->pclk_rising_edge = false;
+	if (of_property_read_u32(np, "maxim,timeout", &priv->timeout))
+		priv->timeout = 100;
+	if (of_property_read_u32(np, "maxim,i2c-quirk", &priv->des_quirk_addr))
+		priv->des_quirk_addr = 0;
+	if (of_property_read_u32(np, "maxim,him", &priv->him))
+		priv->him = 0;
+	if (of_property_read_u32(np, "maxim,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "maxim,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "maxim,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 50;
+	if (of_property_read_u32(np, "maxim,bws", &priv->bws))
+		priv->bws = 0;
+	if (of_property_read_u32(np, "maxim,dbl", &priv->dbl))
+		priv->dbl = 1;
+	if (of_property_read_u32(np, "maxim,dt", &priv->dt))
+		priv->dt = 3;
+	if (of_property_read_u32(np, "maxim,hsgen", &priv->hsgen))
+		priv->hsgen = 0;
+	if (of_property_read_u32(np, "maxim,pclk", &priv->pclk))
+		priv->pclk = pclk;
+	if (of_property_read_u32(np, "maxim,switchin", &priv->switchin))
+		priv->switchin = 0;
+	if (of_property_read_u64(np, "maxim,crossbar", &priv->crossbar))
+		priv->crossbar = crossbar;
+
+	/* module params override dts */
+	if (him)
+		priv->him = him;
+	if (fsync_period) {
+		priv->fsync_period = fsync_period;
+		strncpy(fsync_mode_default, "manual", 8);
+		priv->fsync_mode = fsync_mode_default;
+	}
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (gpio_resetb)
+		priv->gpio_resetb = gpio_resetb;
+	if (active_low_resetb)
+		priv->active_low_resetb = active_low_resetb;
+	if (timeout_n)
+		priv->timeout = timeout_n;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (bws)
+		priv->bws = bws;
+	if (!dbl)
+		priv->dbl = dbl;
+	if (dt != 3)
+		priv->dt = dt;
+	if (hsgen)
+		priv->hsgen = hsgen;
+	if (pclk != 100)
+		priv->pclk = pclk;
+	if (switchin)
+		priv->switchin = switchin;
+
+	/* parse crossbar setup */
+	for (i = 0; i < 16; i++) {
+		priv->cb[i] = priv->crossbar % 16;
+		priv->crossbar /= 16;
+	}
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct max9286_sink *sink;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > MAX9286_N_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+				of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == MAX9286_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		sink = &priv->sinks[ep.port];
+		sink->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!sink->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		sink->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		sink->asd.match.fwnode = sink->fwnode;
+
+		priv->subdevs[ep.port] = &sink->asd;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int max9286_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct max9286_priv *priv;
+	int err;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+	priv->csi2_outord = 0xff;
+
+	err = max9286_parse_dt(client);
+	if (err)
+		goto out;
+
+	err = max9286_i2c_mux_init(priv);
+	if (err) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	err = max9286_initialize(client);
+	if (err < 0)
+		goto out;
+
+	err = max9286_v4l2_init(client);
+	if (err < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+	max9286_post_initialize(client);
+
+	priv->reboot_notifier.notifier_call = max9286_reboot_notifier;
+	err = register_reboot_notifier(&priv->reboot_notifier);
+	if (err) {
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+		goto out;
+	}
+
+	err = sysfs_create_group(&client->dev.kobj, &max9286_group);
+	if (err < 0)
+		dev_err(&client->dev, "Sysfs registration failed\n");
+
+out:
+	return err;
+}
+
+static int max9286_remove(struct i2c_client *client)
+{
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	sysfs_remove_group(&client->dev.kobj,  &max9286_group);
+	unregister_reboot_notifier(&priv->reboot_notifier);
+
+	i2c_mux_del_adapters(priv->mux);
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->poc_reg[i]))
+			regulator_disable(priv->poc_reg[i]); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id max9286_dt_ids[] = {
+	{ .compatible = "maxim,max9286" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9286_dt_ids);
+
+static const struct i2c_device_id max9286_id[] = {
+	{ "max9286", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9286_id);
+
+static struct i2c_driver max9286_i2c_driver = {
+	.driver	= {
+		.name		= "max9286",
+		.of_match_table	= of_match_ptr(max9286_dt_ids),
+	},
+	.probe		= max9286_probe,
+	.remove		= max9286_remove,
+	.id_table	= max9286_id,
+};
+
+module_i2c_driver(max9286_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL driver for MAX9286");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/gmsl/max9286_debug.h b/drivers/media/i2c/gmsl/max9286_debug.h
new file mode 100644
index 0000000..ef00efd
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9286_debug.h
@@ -0,0 +1,89 @@
+/*
+ * MAXIM max9286 GMSL driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+static const char *line_status[] =
+{
+	"BAT",
+	"GND",
+	"NORMAL",
+	"OPEN"
+};
+
+static ssize_t max9286_link_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	int i = -1;
+	u8 val = 0;
+	bool lenghterr, linebuffof, hlocked, prbsok, vsyncdet, configdet, videodet;
+	int lf;
+	u8 prbserr = 0, deterr = 0, correrr = 0;
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9286_priv *priv = i2c_get_clientdata(client);
+
+	if (!sscanf(attr->attr.name, "link_%d", &i))
+		return -EINVAL;
+
+	if ((i < 0) || (i > 3))
+		return -EINVAL;
+
+	reg8_read(client, 0x20, &val);
+	lf = (val >> (2 * i)) & 0x03;
+
+	reg8_read(client, 0x21, &val);
+	hlocked = !!(val & (1 << i));
+	prbsok = !!(val & (1 << (i + 4)));
+
+	reg8_read(client, 0x22, &val);
+	lenghterr = !!(val & (1 << i));
+	linebuffof = !!(val & (1 << (i + 4)));
+
+	reg8_read(client, 0x23 + i, &prbserr);
+	priv->prbserr[i] += prbserr;
+
+	reg8_read(client, 0x27, &val);
+	vsyncdet = !!(val & (1 << i));
+
+	reg8_read(client, 0x28 + i, &deterr);
+	priv->deterr[i] += deterr;
+
+	reg8_read(client, 0x2c + i, &correrr);
+	priv->correrr[i] += correrr;
+
+	reg8_read(client, 0x49, &val);
+	configdet = !!(val & (1 << i));
+	videodet = !!(val & (1 << (i + 4)));
+
+	return sprintf(buf, "LINK:%d LF:%s HLOCKED:%d PRBSOK:%d LINBUFFOF:%d"
+		" LENGHTERR:%d VSYNCDET:%d CONFIGDET:%d VIDEODET:%d"
+		" PRBSERR:%d(%d) DETEERR:%d(%d) CORRERR:%d(%d)\n",
+		i, line_status[lf], hlocked, prbsok, lenghterr,
+		linebuffof, vsyncdet, configdet, videodet,
+		priv->prbserr[i], prbserr,
+		priv->deterr[i], deterr,
+		priv->correrr[i], correrr);
+}
+
+static DEVICE_ATTR(link_0, S_IRUGO, max9286_link_show, NULL);
+static DEVICE_ATTR(link_1, S_IRUGO, max9286_link_show, NULL);
+static DEVICE_ATTR(link_2, S_IRUGO, max9286_link_show, NULL);
+static DEVICE_ATTR(link_3, S_IRUGO, max9286_link_show, NULL);
+
+static struct attribute *max9286_attributes_links[] = {
+	&dev_attr_link_0.attr,
+	&dev_attr_link_1.attr,
+	&dev_attr_link_2.attr,
+	&dev_attr_link_3.attr,
+	NULL
+};
+
+static const struct attribute_group max9286_group = {
+	.attrs = max9286_attributes_links,
+};
diff --git a/drivers/media/i2c/gmsl/max9288.c b/drivers/media/i2c/gmsl/max9288.c
new file mode 100644
index 0000000..f53ba27
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9288.c
@@ -0,0 +1,915 @@
+/*
+ * MAXIM max9288 GMSL driver
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+
+#define MAX9288_N_LINKS		1
+
+enum max9288_pads {
+	MAX9288_SINK_LINK0,
+	MAX9288_SOURCE,
+	MAX9288_N_PADS,
+};
+
+struct max9288_sink {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+};
+
+#define asd_to_max9288_sink(_asd) \
+	container_of(_asd, struct max9288_sink, asd)
+
+struct max9288_priv {
+	struct i2c_client	*client;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[MAX9288_N_PADS];
+
+	struct i2c_mux_core	*mux;
+
+	struct max9288_sink	*sink;
+	struct v4l2_async_subdev *subdev;
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			des_addr;
+	int			lanes;
+	long			pixel_rate;
+	int			pclk;
+	char			pclk_rising_edge;
+	int			gpio_resetb;
+	int			active_low_resetb;
+	int			him;
+	int			hsync;
+	int			vsync;
+	int			timeout;
+	int			poc_delay;
+	int			bws;
+	int			dbl;
+	int			dt;
+	int			hsgen;
+	int			hts;
+	int			vts;
+	int			hts_delay;
+	int			ser_addr;
+	int			ser_id;
+	struct regulator	*poc_reg; /* PoC power supply */
+	struct notifier_block	reboot_notifier;
+};
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int poc_trig;
+module_param(poc_trig, int, 0644);
+MODULE_PARM_DESC(poc_trig, " Use PoC triggering during reverse channel setup. Useful on systems with dedicated PoC and unstable ser-des lock");
+
+static int him = 0;
+module_param(him, int, 0644);
+MODULE_PARM_DESC(him, " Use High-Immunity mode (default: leagacy mode)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int gpio_resetb;
+module_param(gpio_resetb, int, 0644);
+MODULE_PARM_DESC(gpio_resetb, " Serializer GPIO reset (default: 0 - not used)");
+
+static int active_low_resetb;
+module_param(active_low_resetb, int, 0644);
+MODULE_PARM_DESC(active_low_resetb, " Serializer GPIO reset level (default: 0 - active high)");
+
+static int timeout_n = 100;
+module_param(timeout_n, int, 0644);
+MODULE_PARM_DESC(timeout_n, " Timeout of link detection (default: 100 retries)");
+
+static int poc_delay = 50;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 50 ms)");
+
+static int bws = 0;
+module_param(bws, int, 0644);
+MODULE_PARM_DESC(bws, " BWS mode (default: 0 - 24-bit gmsl packets)");
+
+static int dbl = 1;
+module_param(dbl, int, 0644);
+MODULE_PARM_DESC(dbl, " DBL mode (default: 1 - DBL mode enabled)");
+
+static int dt = 3;
+module_param(dt, int, 0644);
+MODULE_PARM_DESC(dt, " DataType (default: 3 - YUV8), 0 - RGB888, 5 - RAW8, 6 - RAW10, 7 - RAW12, 8 - RAW14");
+
+static int hsgen;
+module_param(hsgen, int, 0644);
+MODULE_PARM_DESC(hsgen, " Enable HS embedded generator (default: 0 - disabled)");
+
+static int pclk = 100;
+module_param(pclk, int, 0644);
+MODULE_PARM_DESC(pclk, " PCLK rate (default: 100MHz)");
+
+enum {
+	RGB888_DT = 0,
+	RGB565_DT,
+	RGB666_DT,
+	YUV8_DT, /* default */
+	YUV10_DT,
+	RAW8_DT,
+	RAW10_DT,
+	RAW12_DT,
+	RAW14_DT,
+};
+
+static int dt2bpp[9] = {
+	24,	/* RGB888 */
+	16,	/* RGB565 */
+	18,	/* RGB666 */
+	8,	/* YUV8 - default */
+	10,	/* YUV10 */
+	8,	/* RAW8/RAW16 */
+	10,	/* RAW10 */
+	12,	/* RAW12 */
+	14,	/* RAW14 */
+};
+
+static void max9288_write_remote_verify(struct i2c_client *client, u8 reg, u8 val)
+{
+	int timeout;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		u8 val2 = 0;
+
+		reg8_write(client, reg, val);
+		reg8_read(client, reg, &val2);
+		if (val2 == val)
+			break;
+
+		usleep_range(1000, 1500);
+	}
+
+	if (timeout >= 10)
+		dev_err(&client->dev, "timeout remote write acked\n");
+}
+
+
+static void max9288_preinit(struct i2c_client *client, int addr)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+
+	client->addr = addr;
+	reg8_write(client, 0x04, 0x00);		/* disable reverse control */
+	reg8_write(client, 0x16, (priv->him ? 0x80 : 0x00) |
+				 0x5a);		/* high-immunity/legacy mode */
+}
+
+static void max9288_sensor_reset(struct i2c_client *client, int addr, int reset_on)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+
+	if (priv->ser_id == MAX96707_ID)
+		return;
+
+	if (priv->gpio_resetb < 1 || priv->gpio_resetb > 5)
+		return;
+
+	if (priv->active_low_resetb)
+		reset_on = !reset_on;
+
+	/* sensor reset/unreset using serializer gpio */
+	client->addr = addr;
+	reg8_write(client, 0x0f, (0xfe & ~BIT(priv->gpio_resetb)) | (reset_on ? BIT(priv->gpio_resetb) : 0)); /* set GPIOn value */
+	reg8_write(client, 0x0e, 0x42 | BIT(priv->gpio_resetb)); /* set GPIOn direction output */
+}
+
+static int max9288_reverse_channel_setup(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+	u8 val = 0, lock_sts = 0;
+	int timeout = priv->timeout;
+	char timeout_str[40];
+	int ret = 0;
+
+	/* Reverse channel enable */
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x1c, 0xa2 | MAXIM_I2C_I2C_SPEED);	/* enable artificial ACKs, I2C speed set */
+	usleep_range(2000, 2500);
+	reg8_write(client, 0x04, 0x03);				/* enable reverse control */
+	usleep_range(2000, 2500);
+
+	for (;;) {
+		if (priv->him) {
+			/* HIM mode setup */
+			client->addr = 0x40;
+			reg8_write(client, 0x4d, 0xc0);
+			usleep_range(2000, 2500);
+			reg8_write(client, 0x04, 0x43);		/* wake-up, enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				reg8_write(client, 0x07, (priv->pclk_rising_edge ? 0 : 0x10) |
+							 (priv->dbl ? 0x80 : 0) |
+							 (priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS disabled enabled, DBL mode, BWS 24/32-bit */
+				usleep_range(2000, 2500);
+			}
+		} else {
+			/* Legacy mode setup */
+			client->addr = priv->des_addr;
+			reg8_write(client, 0x13, 0x00);
+			reg8_write(client, 0x11, 0x42);		/* enable custom reverse channel & first pulse length */
+			reg8_write(client, 0x0a, 0x0f);		/* first pulse length rise time changed from 300ns to 200ns, amplitude 100mV */
+			usleep_range(2000, 2500);
+
+			client->addr = 0x40;
+			reg8_write(client, 0x04, 0x43);		/* wake-up, enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			reg8_write(client, 0x08, 0x01);		/* reverse channel receiver high threshold enable */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				reg8_write(client, 0x07, (priv->pclk_rising_edge ? 0 : 0x10) |
+							 (priv->dbl ? 0x80 : 0) |
+							 (priv->bws ? 0x20 : 0)); /* RAW/YUV, PCLK edge, HS/VS encoding disabled, DBL mode, BWS 24/32-bit */
+				usleep_range(2000, 2500);
+			}
+			reg8_write(client, 0x97, 0x5f);		/* enable reverse control channel programming (MAX96705-MAX96711 only) */
+			usleep_range(2000, 2500);
+
+			client->addr = priv->des_addr;
+			reg8_write(client, 0x0a, 0x0c);		/* first pulse length rise time changed from 300ns to 200ns, amplitude 100mV */
+			reg8_write(client, 0x13, 0x20);		/* reverse channel increase amplitude 170mV to compensate high threshold enabled */
+			usleep_range(2000, 2500);
+		}
+
+		client->addr = 0x40;
+		reg8_read(client, 0x1e, &val); /* read serializer ID */
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID || --timeout == 0) {
+			priv->ser_id = val;
+			break;
+		}
+
+		/* Check if already initialized (after reboot/reset ?) */
+		client->addr = priv->ser_addr;
+		reg8_read(client, 0x1e, &val); /* read serializer ID */
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			priv->ser_id = val;
+			reg8_write(client, 0x04, 0x43);		/* enable reverse_control/conf_link */
+			usleep_range(2000, 2500);
+			ret = -EADDRINUSE;
+			break;
+		}
+
+		if (poc_trig) {
+			if (!IS_ERR(priv->poc_reg) && (timeout % poc_trig == 0)) {
+				regulator_disable(priv->poc_reg); /* POC power off */
+				mdelay(200);
+				ret = regulator_enable(priv->poc_reg); /* POC power on */
+				if (ret)
+					dev_err(&client->dev, "failed to enable poc regulator\n");
+				mdelay(priv->poc_delay);
+			}
+		}
+	}
+
+	max9288_sensor_reset(client, client->addr, 1);	/* sensor reset */
+
+	client->addr = priv->des_addr;
+	reg8_read(client, 0x04, &lock_sts);		/* LOCK status */
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+out:
+	sprintf(timeout_str, "retries=%d lock_sts=%d", priv->timeout - timeout, !!(lock_sts & 0x80));
+	dev_info(&client->dev, "link %s %sat 0x%x %s %s\n", chip_name(priv->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", priv->ser_addr,
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL link establish" : "",
+			       priv->timeout - timeout ? timeout_str : "");
+
+	return ret;
+}
+
+static void max9288_initial_setup(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+
+	/* Initial setup */
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x09, 0x40);				/* Automatic pixel count enable */
+	reg8_write(client, 0x15, 0x70);				/* Enable HV and DE tracking by register 0x69 */
+	reg8_write(client, 0x60, (priv->dbl ? 0x20 : 0) |
+				 (priv->dt & 0xf));		/* VC=0, DBL mode, DataType */
+	reg8_write(client, 0x65, 0x47 | ((priv->lanes - 1) << 4)); /* setup CSI lanes, DE input is HS */
+
+	reg8_write(client, 0x08, 0x20);				/* use D18/19 for HS/VS */
+	reg8_write(client, 0x14, (priv->vsync ? 0x80 : 0) | (priv->hsync ? 0x40 : 0)); /* setup HS/VS inversion */
+	reg8_write(client, 0x64, 0x0c);				/* Drive HSTRAIL state for 120ns after the last payload bit */
+}
+
+static void max9288_gmsl_link_setup(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+
+	/* GMSL setup */
+	client->addr = 0x40;
+	reg8_write(client, 0x0d, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	reg8_write(client, 0x07, (priv->pclk_rising_edge ? 0 : 0x10) |
+				 (priv->dbl ? 0x80 : 0) |
+				 (priv->bws ? 0x20 : 0));	/* RAW/YUV, PCLK edge, HS/VS encoding disabled, DBL mode, BWS 24/32-bit */
+	usleep_range(2000, 2500);
+	reg8_write(client, 0x02, 0xff);				/* spread spectrum +-4%, pclk range automatic, Gbps automatic  */
+	usleep_range(2000, 2500);
+
+	if (priv->ser_id == MAX96705_ID || priv->ser_id == MAX96707_ID) {
+		switch (priv->dt) {
+		case YUV8_DT:
+			/* setup crossbar for YUV8/RAW8: reverse DVP bus */
+			reg8_write(client, 0x20, 3);
+			reg8_write(client, 0x21, 4);
+			reg8_write(client, 0x22, 5);
+			reg8_write(client, 0x23, 6);
+			reg8_write(client, 0x24, 7);
+			reg8_write(client, 0x25, 0x40);
+			reg8_write(client, 0x26, 0x40);
+			if (priv->ser_id == MAX96705_ID) {
+				reg8_write(client, 0x27, 14); /* HS: D14->D18  */
+				reg8_write(client, 0x28, 15); /* VS: D15->D19 */
+			}
+			if (priv->ser_id == MAX96707_ID) {
+				reg8_write(client, 0x27, 14); /* HS: D14->D18, this is a virtual NC pin, hence it is D14 at HS */
+				reg8_write(client, 0x28, 13); /* VS: D13->D19 */
+			}
+			reg8_write(client, 0x29, 0x40);
+			reg8_write(client, 0x2A, 0x40);
+
+			/* this is second byte if DBL=1 */
+			reg8_write(client, 0x30, 0x10 + 0);
+			reg8_write(client, 0x31, 0x10 + 1);
+			reg8_write(client, 0x32, 0x10 + 2);
+			reg8_write(client, 0x33, 0x10 + 3);
+			reg8_write(client, 0x34, 0x10 + 4);
+			reg8_write(client, 0x35, 0x10 + 5);
+			reg8_write(client, 0x36, 0x10 + 6);
+			reg8_write(client, 0x37, 0x10 + 7);
+			reg8_write(client, 0x38, 0);
+			reg8_write(client, 0x39, 1);
+			reg8_write(client, 0x3A, 2);
+
+			reg8_write(client, 0x67, 0xC4); /* DBL_ALIGN_TO = 100b */
+
+			break;
+		}
+
+		if (priv->hsgen) {
+			/* HS/VS pins map */
+			reg8_write(client, 0x3f, 0x10);			/* HS (NC) */
+			reg8_write(client, 0x41, 0x10);			/* DE (NC) */
+			if (priv->ser_id == MAX96705_ID)
+				reg8_write(client, 0x40, 15);		/* VS (DIN13) */
+			if (priv->ser_id == MAX96707_ID)
+				reg8_write(client, 0x40, 13);		/* VS (DIN13) */
+#if 0
+			/* following must come from imager */
+#define SENSOR_WIDTH	(1280*2)
+#define HTS		(1288*2)
+#define VTS		960
+#define HTS_DELAY	0x9
+			reg8_write(client, 0x4e, HTS_DELAY >> 16);	/* HS delay */
+			reg8_write(client, 0x4f, (HTS_DELAY >> 8) & 0xff);
+			reg8_write(client, 0x50, HTS_DELAY & 0xff);
+			reg8_write(client, 0x54, SENSOR_WIDTH >> 8);	/* HS high period */
+			reg8_write(client, 0x55, SENSOR_WIDTH & 0xff);
+			reg8_write(client, 0x56, (HTS - SENSOR_WIDTH) >> 8); /* HS low period */
+			reg8_write(client, 0x57, (HTS - SENSOR_WIDTH) & 0xff);
+			reg8_write(client, 0x58, VTS >> 8);		/* HS count */
+			reg8_write(client, 0x59, VTS & 0xff );
+#endif
+			reg8_write(client, 0x43, 0x15);			/* enable HS generator */
+		}
+	}
+
+	client->addr = priv->des_addr;
+	reg8_write(client, 0x1c, 0x22 | MAXIM_I2C_I2C_SPEED);	/* disable artificial ACK, I2C speed set */
+	usleep_range(2000, 2500);
+
+	/* I2C translator setup */
+	client->addr = 0x40;
+//	reg8_write(client, 0x09, maxim_map[2][idx] << 1);	/* SENSOR I2C translated - must be set by sensor driver */
+//	reg8_write(client, 0x0A, 0x30 << 1);			/* SENSOR I2C native - must be set by sensor driver */
+	reg8_write(client, 0x0B, BROADCAST << 1);		/* broadcast I2C */
+	reg8_write(client, 0x0C, priv->ser_addr << 1);
+	/* I2C addresse change */
+	reg8_write(client, 0x01, priv->des_addr << 1);
+	reg8_write(client, 0x00, priv->ser_addr << 1);
+	usleep_range(2000, 2500);
+	/* put MAX9271 in configuration link state  */
+	client->addr = priv->ser_addr;
+	reg8_write(client, 0x04, 0x43);				/* enable reverse_control/conf_link */
+	usleep_range(2000, 2500);
+}
+
+static int max9288_initialize(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+	int ret;
+
+	dev_info(&client->dev, "LANES=%d, PCLK edge=%s\n",
+			       priv->lanes, priv->pclk_rising_edge ? "rising" : "falling");
+
+	max9288_preinit(client, priv->des_addr);
+	max9288_initial_setup(client);
+
+	if (!IS_ERR(priv->poc_reg)) {
+		ret = regulator_enable(priv->poc_reg); /* POC power on */
+		if (ret)
+			dev_err(&client->dev, "failed to enable poc regulator\n");
+		mdelay(priv->poc_delay);
+	}
+
+	max9288_reverse_channel_setup(client);
+	max9288_gmsl_link_setup(client);
+
+	i2c_mux_add_adapter(priv->mux, 0, 0, 0);
+
+	client->addr = priv->des_addr;
+
+	return 0;
+}
+
+static int max9288_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct max9288_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	client->addr = priv->ser_addr;
+	max9288_write_remote_verify(client, 0x04, enable ? (conf_link ? 0x43 : 0x83) : 0x43); /* enable serial_link or conf_link */
+	usleep_range(2000, 2500);
+	client->addr = priv->des_addr;
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops max9288_video_ops = {
+	.s_stream = max9288_s_stream,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int max9288_g_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register *reg)
+{
+	struct max9288_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+	int ret;
+	u8 val = 0;
+
+	ret = reg8_read(client, (u8)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u8);
+
+	return 0;
+}
+
+static int max9288_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct max9288_priv *priv = v4l2_get_subdevdata(sd);
+	struct i2c_client *client = priv->client;
+
+	return reg8_write(client, (u8)reg->reg, (u8)reg->val);
+}
+#endif
+
+static int max9288_reboot_notifier(struct notifier_block *nb, unsigned long event, void *buf)
+{
+	struct max9288_priv *priv = container_of(nb, struct max9288_priv, reboot_notifier);
+
+	if (!IS_ERR(priv->poc_reg))
+		regulator_disable(priv->poc_reg); /* POC power off */
+
+	return NOTIFY_DONE;
+}
+
+static struct v4l2_subdev_core_ops max9288_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = max9288_g_register,
+	.s_register = max9288_s_register,
+#endif
+};
+
+static const struct v4l2_subdev_ops max9288_subdev_ops = {
+	.core = &max9288_subdev_core_ops,
+	.video = &max9288_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int max9288_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int max9288_i2c_mux_init(struct max9288_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  1, 0, I2C_MUX_LOCKED,
+				  max9288_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int max9288_notify_bound(struct v4l2_async_notifier *notifier,
+				struct v4l2_subdev *subdev,
+				struct v4l2_async_subdev *asd)
+{
+	struct max9288_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9288_sink *sink = asd_to_max9288_sink(asd);
+	int sink_pad = 0;
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, sink->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	sink->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void max9288_notify_unbind(struct v4l2_async_notifier *notifier,
+				  struct v4l2_subdev *subdev,
+				  struct v4l2_async_subdev *asd)
+{
+	struct max9288_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9288_sink *sink = asd_to_max9288_sink(asd);
+
+	sink->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations max9288_notify_ops = {
+	.bound = max9288_notify_bound,
+	.unbind = max9288_notify_unbind,
+};
+
+static int max9288_v4l2_init(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	int err;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdev);
+	if (err < 0)
+		return err;
+
+	priv->notifier.ops = &max9288_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &max9288_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* CSI2_RATE = PCLK*bpp*n_links/lanes*/
+	priv->pixel_rate = priv->pclk * 2 * dt2bpp[priv->dt] / 8 / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  priv->pixel_rate, priv->pixel_rate, 1, priv->pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[MAX9288_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[MAX9288_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, MAX9288_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, MAX9288_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int max9288_parse_dt(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	int err, pwen, i;
+	int sensor_delay, gpio0 = 1, gpio1 = 1;
+	u8 val = 0;
+	char poc_name[10];
+
+	i = of_property_match_string(np, "reg-names", "max9288");
+	if (i >= 0)
+		of_property_read_u32_index(np, "reg", i, (unsigned int *)&client->addr);
+	priv->des_addr = client->addr;
+
+	err = of_property_read_u32(client->dev.of_node, "regs", &priv->ser_addr);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+
+	pwen = of_get_gpio(np, 0);
+	if (pwen > 0) {
+		err = gpio_request_one(pwen, GPIOF_OUT_INIT_HIGH, dev_name(&client->dev));
+		if (err)
+			dev_err(&client->dev, "cannot request PWEN gpio %d: %d\n", pwen, err);
+	}
+
+	mdelay(250);
+
+	sprintf(poc_name, "poc%d", i);
+	priv->poc_reg = devm_regulator_get(&client->dev, poc_name);
+	if (PTR_ERR(priv->poc_reg) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+
+	reg8_read(client, 0x1e, &val); /* read max9288 ID */
+	if (val != MAX9288_ID)
+		return -ENODEV;
+
+	if (!of_property_read_u32(np, "maxim,gpio0", &gpio0) ||
+	    !of_property_read_u32(np, "maxim,gpio1", &gpio1))
+		reg8_write(client, 0x06, (gpio1 << 3) | (gpio0 << 1));
+
+	if (of_property_read_u32(np, "maxim,resetb-gpio", &priv->gpio_resetb)) {
+		priv->gpio_resetb = -1;
+	} else {
+		if (of_property_read_bool(np, "maxim,resetb-active-high"))
+			priv->active_low_resetb = 0;
+		else
+			priv->active_low_resetb = 1;
+	}
+
+	if (!of_property_read_u32(np, "maxim,sensor_delay", &sensor_delay))
+		mdelay(sensor_delay);
+	priv->pclk_rising_edge = true;
+	if (of_property_read_bool(np, "maxim,pclk-falling-edge"))
+		priv->pclk_rising_edge = false;
+	if (of_property_read_u32(np, "maxim,timeout", &priv->timeout))
+		priv->timeout = 100;
+	if (of_property_read_u32(np, "maxim,him", &priv->him))
+		priv->him = 0;
+	if (of_property_read_u32(np, "maxim,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "maxim,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "maxim,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 50;
+	if (of_property_read_u32(np, "maxim,bws", &priv->bws))
+		priv->bws = 0;
+	if (of_property_read_u32(np, "maxim,dbl", &priv->dbl))
+		priv->dbl = 1;
+	if (of_property_read_u32(np, "maxim,dt", &priv->dt))
+		priv->dt = 3;
+	if (of_property_read_u32(np, "maxim,hsgen", &priv->hsgen))
+		priv->hsgen = 0;
+	if (of_property_read_u32(np, "maxim,pclk", &priv->pclk))
+		priv->pclk = pclk;
+
+	/* module params override dts */
+	if (him)
+		priv->him = him;
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (gpio_resetb)
+		priv->gpio_resetb = gpio_resetb;
+	if (active_low_resetb)
+		priv->active_low_resetb = active_low_resetb;
+	if (timeout_n)
+		priv->timeout = timeout_n;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (bws)
+		priv->bws = bws;
+	if (!dbl)
+		priv->dbl = dbl;
+	if (dt != 3)
+		priv->dt = dt;
+	if (hsgen)
+		priv->hsgen = hsgen;
+	if (pclk != 100)
+		priv->pclk = pclk;
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct max9288_sink *sink;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > MAX9288_N_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+			of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == MAX9288_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		sink = priv->sink;
+		sink->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!sink->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		sink->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		sink->asd.match.fwnode = sink->fwnode;
+
+		priv->subdev = &sink->asd;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int max9288_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct max9288_priv *priv;
+	int err;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+
+	err = max9288_parse_dt(client);
+	if (err)
+		goto out;
+
+	err = max9288_i2c_mux_init(priv);
+	if (err) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	err = max9288_initialize(client);
+	if (err < 0)
+		goto out;
+
+	err = max9288_v4l2_init(client);
+	if (err < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+
+	priv->reboot_notifier.notifier_call = max9288_reboot_notifier;
+	err = register_reboot_notifier(&priv->reboot_notifier);
+	if (err) {
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+		goto out;
+	}
+
+out:
+	return err;
+}
+
+static int max9288_remove(struct i2c_client *client)
+{
+	struct max9288_priv *priv = i2c_get_clientdata(client);
+
+	unregister_reboot_notifier(&priv->reboot_notifier);
+
+	i2c_mux_del_adapters(priv->mux);
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	if (!IS_ERR(priv->poc_reg))
+		regulator_disable(priv->poc_reg); /* POC power off */
+
+	return 0;
+}
+
+static const struct of_device_id max9288_dt_ids[] = {
+	{ .compatible = "maxim,max9288" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9288_dt_ids);
+
+static const struct i2c_device_id max9288_id[] = {
+	{ "max9288", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9288_id);
+
+static struct i2c_driver max9288_i2c_driver = {
+	.driver = {
+		.name = "max9288",
+		.of_match_table = of_match_ptr(max9288_dt_ids),
+	},
+	.probe = max9288_probe,
+	.remove = max9288_remove,
+	.id_table = max9288_id,
+};
+
+module_i2c_driver(max9288_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL driver for MAX9288");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/gmsl/max9295.h b/drivers/media/i2c/gmsl/max9295.h
new file mode 100644
index 0000000..864c441
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9295.h
@@ -0,0 +1,39 @@
+/*
+ * MAXIM max9295 GMSL2 driver header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define MAX9295_REG2			0x02
+#define MAX9295_REG7			0x07
+#define MAX9295_CTRL0			0x10
+#define MAX9295_I2C2			0x42
+#define MAX9295_I2C3			0x43
+#define MAX9295_I2C4			0x44
+#define MAX9295_I2C5			0x45
+#define MAX9295_I2C6			0x46
+
+#define MAX9295_CROSS(n)		(0x1b0 + n)
+
+#define MAX9295_GPIO_A(n)		(0x2be + (3 * n))
+#define MAX9295_GPIO_B(n)		(0x2bf + (3 * n))
+#define MAX9295_GPIO_C(n)		(0x2c0 + (3 * n))
+
+#define MAX9295_VIDEO_TX_BASE(n)	(0x100 + (0x8 * n))
+#define MAX9295_VIDEO_TX0(n)		(MAX9295_VIDEO_TX_BASE(n) + 0)
+#define MAX9295_VIDEO_TX1(n)		(MAX9295_VIDEO_TX_BASE(n) + 1)
+
+#define MAX9295_FRONTTOP_0		0x308
+#define MAX9295_FRONTTOP_9		0x311
+#define MAX9295_FRONTTOP_12		0x314
+#define MAX9295_FRONTTOP_13		0x315
+
+#define MAX9295_MIPI_RX0		0x330
+#define MAX9295_MIPI_RX1		0x331
+#define MAX9295_MIPI_RX2		0x332
+#define MAX9295_MIPI_RX3		0x333
\ No newline at end of file
diff --git a/drivers/media/i2c/gmsl/max9296.c b/drivers/media/i2c/gmsl/max9296.c
new file mode 100644
index 0000000..440e353
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9296.c
@@ -0,0 +1,1596 @@
+/*
+ * MAXIM max9296 GMSL2 driver
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-clk.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+#include "max9296.h"
+#include "max9296_debug.h"
+
+static char mbus_default[10] = "dvp"; /* mipi, dvp */
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int poc_trig;
+module_param(poc_trig, int, 0644);
+MODULE_PARM_DESC(poc_trig, " Use PoC triggering during RC setup. Useful on systems with dedicated PoC and unstable ser-des lock");
+
+static int him;
+module_param(him, int, 0644);
+MODULE_PARM_DESC(him, " Use High-Immunity mode (default: leagacy mode)");
+
+static int fsync_period;
+module_param(fsync_period, int, 0644);
+MODULE_PARM_DESC(fsync_period, " Frame sync period (default: 3.2MHz)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int gpio_resetb;
+module_param(gpio_resetb, int, 0644);
+MODULE_PARM_DESC(gpio_resetb, " Serializer GPIO reset (default: 0 - not used)");
+
+static int active_low_resetb;
+module_param(active_low_resetb, int, 0644);
+MODULE_PARM_DESC(active_low_resetb, " Serializer GPIO reset level (default: 0 - active high)");
+
+static int timeout_n = 100;
+module_param(timeout_n, int, 0644);
+MODULE_PARM_DESC(timeout_n, " Timeout of link detection (default: 100 retries)");
+
+static int poc_delay = 50;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 50 ms)");
+
+static int bws;
+module_param(bws, int, 0644);
+MODULE_PARM_DESC(bws, " BWS mode (default: 0 - 24-bit gmsl packets)");
+
+static int dbl = 1;
+module_param(dbl, int, 0644);
+MODULE_PARM_DESC(dbl, " DBL mode (default: 1 - DBL mode enabled)");
+
+static int dt = MIPI_DT_YUV8;
+module_param(dt, int, 0644);
+MODULE_PARM_DESC(dt, " DataType (default: 0x1e - YUV8)");
+
+static unsigned long crossbar = 0xba9876543210;
+module_param(crossbar, ulong, 0644);
+MODULE_PARM_DESC(crossbar, " Serializer crossbar setup (default: ba9876543210 - reversed)");
+
+static int gmsl = MODE_GMSL2;
+module_param(gmsl, int, 0644);
+MODULE_PARM_DESC(gmsl, " GMSL mode (default: 2 - GMSL2)");
+
+static char *mbus = mbus_default;
+module_param(mbus, charp, 0644);
+MODULE_PARM_DESC(mbus, " Interfaces mipi,dvp (default: dvp)");
+
+static int gpio0 = -1, gpio1 = -1, gpio7 = -1, gpio8 = -1;
+module_param(gpio0, int, 0644);
+MODULE_PARM_DESC(gpio0, "  GPIO0 function select (default: GPIO0 tri-state)");
+module_param(gpio1, int, 0644);
+MODULE_PARM_DESC(gpio1, "  GPIO1 function select (default: GPIO1 tri-state)");
+module_param(gpio7, int, 0644);
+MODULE_PARM_DESC(gpio7, "  GPIO7 function select (default: GPIO7 tri-state)");
+module_param(gpio8, int, 0644);
+MODULE_PARM_DESC(gpio8, "  GPIO8 function select (default: GPIO8 tri-state)");
+
+static const struct regmap_config max9296_regmap[] = {
+	{
+		/* max9296 */
+		.reg_bits = 16,
+		.val_bits = 8,
+		.max_register = 0x1f03,
+	}, {
+		/* max9271/max96705 */
+		.reg_bits = 8,
+		.val_bits = 8,
+		.max_register = 0xff,
+	}, {
+		/* max9695 */
+		.reg_bits = 16,
+		.val_bits = 8,
+		.max_register = 0x1b03,
+	}
+};
+
+static void max9296_write_remote_verify(struct max9296_priv *priv, int link_n, u8 reg, int val)
+{
+	struct max9296_link *link = priv->link[link_n];
+	int timeout;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		int sts = 0;
+		u8 val2 = 0;
+
+		ser_write(reg, val);
+		des_read(MAX9296_COMMON1, &sts);
+		/* check ACKed */
+		if (sts & BIT(link_n)) {
+			ser_read(reg, &val2);
+			if (val2 == val)
+				break;
+		}
+
+		usleep_range(1000, 1500);
+	}
+
+	if (timeout >= 10)
+		dev_err(&priv->client->dev, "timeout remote write acked\n");
+}
+
+static void max9296_reset_oneshot(struct max9296_priv *priv)
+{
+	int timeout;
+	int reg = 0;
+
+	des_update_bits(MAX9296_CTRL0, BIT(5), BIT(5)); /* set reset one-shot */
+
+	/* wait for one-shot bit self-cleared */
+	for (timeout = 0; timeout < 100; timeout++) {
+		des_read(MAX9296_CTRL0, &reg);
+		if (!(reg & BIT(5)))
+			break;
+
+		mdelay(1);
+	}
+
+	if (reg & BIT(5))
+		dev_err(&priv->client->dev, "Failed reset oneshot\n");
+}
+
+/* -----------------------------------------------------------------------------
+ * MIPI, mapping, routing
+ */
+
+static void max9296_pipe_override(struct max9296_priv *priv, unsigned int pipe,
+				   unsigned int dt, unsigned int vc)
+{
+	int bpp, bank;
+
+	bpp = mipi_dt_to_bpp(dt);
+	bank = pipe / 4;
+	pipe %= 4;
+
+	if (priv->dbl == 1) {
+		/* DBL=1 is MUX mode, DBL=0 is Normal mode */
+		des_update_bits(MAX_BACKTOP27(bank), BIT(pipe + 4), BIT(pipe + 4));	/* enable MUX mode */
+		bpp = bpp / 2;								/* divide because of MUX=1 */
+	}
+
+	switch (pipe) {
+	case 0:
+		/* Pipe X: 0 or 4 */
+		des_update_bits(MAX_BACKTOP12(bank), 0x1f << 3, bpp << 3);
+		des_update_bits(MAX_BACKTOP13(bank), 0x0f, vc);
+		des_update_bits(MAX_BACKTOP15(bank), 0x3f, dt);
+		des_update_bits(bank ? MAX_BACKTOP28(0) : MAX_BACKTOP22(0), BIT(6), BIT(6)); /* enalbe s/w override */
+		break;
+	case 1:
+		/* Pipe Y: 1 or 5 */
+		des_update_bits(MAX_BACKTOP18(bank), 0x1f, bpp);
+		des_update_bits(MAX_BACKTOP13(bank), 0x0f << 4, vc << 4);
+		des_update_bits(MAX_BACKTOP16(bank), 0x0f, dt & 0x0f);
+		des_update_bits(MAX_BACKTOP15(bank), 0x03 << 6, (dt & 0x30) << 2);
+		des_update_bits(bank ? MAX_BACKTOP28(0) : MAX_BACKTOP22(0), BIT(7), BIT(7)); /* enable s/w override */
+		break;
+	case 2:
+		/* Pipe Z: 2 or 6 */
+		des_update_bits(MAX_BACKTOP19(bank), 0x03, bpp & 0x03);
+		des_update_bits(MAX_BACKTOP18(bank), 0xe0, (bpp & 0x1c) << 3);
+		des_update_bits(MAX_BACKTOP14(bank), 0x0f, vc);
+		des_update_bits(MAX_BACKTOP17(bank), 0x03, dt & 0x03);
+		des_update_bits(MAX_BACKTOP16(bank), 0x0f << 4, (dt & 0x3c) << 2);
+		des_update_bits(bank ? MAX_BACKTOP30(0) : MAX_BACKTOP25(0), BIT(6), BIT(6)); /* enable s/w override */
+		break;
+	case 3:
+		/* Pipe U: 3 or 7 */
+		des_update_bits(MAX_BACKTOP19(bank), 0xfc, bpp << 2);
+		des_update_bits(MAX_BACKTOP14(bank), 0x0f << 4, vc << 4);
+		des_update_bits(MAX_BACKTOP17(bank), 0x3f << 2, dt << 2);
+		des_update_bits(bank ? MAX_BACKTOP30(0) : MAX_BACKTOP25(0), BIT(7), BIT(7)); /* enable s/w override */
+		break;
+	}
+}
+
+static void max9296_set_pipe_to_mipi_mapping(struct max9296_priv *priv,
+					      unsigned int pipe, unsigned int map_n,
+					      unsigned int in_dt, unsigned int in_vc,
+					      unsigned int out_dt, unsigned int out_vc, unsigned int out_mipi)
+{
+	int offset = 2 * (map_n % 4);
+
+	des_write(MAX_MIPI_MAP_SRC(pipe, map_n), (in_vc << 6) | in_dt);
+	des_write(MAX_MIPI_MAP_DST(pipe, map_n), (out_vc << 6) | out_dt);
+	des_update_bits(MAX_MIPI_MAP_DST_PHY(pipe, map_n / 4), 0x03 << offset, out_mipi << offset);
+	des_update_bits(MAX_MIPI_TX11(pipe), BIT(map_n), BIT(map_n));	/* enable SRC_n to DST_n mapping */
+}
+
+static void max9296_mipi_setup(struct max9296_priv *priv)
+{
+	des_write(MAX9296_REG2, 0);		/* disable all pipes */
+	des_update_bits(MAX_BACKTOP12(0), 0x02, 0); /* CSI output disable */
+
+	des_write(MAX_MIPI_PHY0, 0x04);		/* MIPI Phy 2x4 mode */
+	des_write(MAX_MIPI_PHY3, 0xe4);		/* Lane map: straight */
+	des_write(MAX_MIPI_PHY4, 0xe4);		/* Lane map: straight */
+	//des_write(MAX_MIPI_PHY5, 0x00);	/* HS_prepare time, non-inverted polarity */
+	//des_write(MAX_MIPI_PHY6, 0x00);
+
+	des_write(MAX_MIPI_TX10(1), 0xc0);	/* MIPI1: 4 lanes */
+	des_write(MAX_MIPI_TX10(2), 0xc0);	/* MIPI2: 4 lanes */
+
+	des_update_bits(MAX_BACKTOP22(0), 0x3f, ((priv->csi_rate[1] / 100) & 0x1f) | BIT(5)); /* MIPI rate */
+	des_update_bits(MAX_BACKTOP25(0), 0x3f, ((priv->csi_rate[1] / 100) & 0x1f) | BIT(5));
+	des_update_bits(MAX_BACKTOP28(0), 0x3f, ((priv->csi_rate[2] / 100) & 0x1f) | BIT(5));
+	des_update_bits(MAX_BACKTOP31(0), 0x3f, ((priv->csi_rate[2] / 100) & 0x1f) | BIT(5));
+
+	des_update_bits(MAX_MIPI_PHY2, 0xf0, 0xf0); /* enable all MIPI PHYs */
+}
+
+/* -----------------------------------------------------------------------------
+ * GMSL1
+ */
+
+static int max9296_gmsl1_sensor_reset(struct max9296_priv *priv, int link_n, int reset_on)
+{
+	struct max9296_link *link = priv->link[link_n];
+
+	if (priv->gpio_resetb < 1 || priv->gpio_resetb > 5)
+		return -EINVAL;
+
+	/* sensor reset/unreset */
+	ser_write(0x0f, (0xfe & ~BIT(priv->gpio_resetb)) | /* set GPIOn value to reset/unreset */
+		  ((priv->active_low_resetb ? BIT(priv->gpio_resetb) : 0) ^ reset_on));
+	ser_write(0x0e, 0x42 | BIT(priv->gpio_resetb)); /* set GPIOn direction output */
+
+	return 0;
+}
+
+static void max9296_gmsl1_cc_enable(struct max9296_priv *priv, int link, int on)
+{
+	des_update_bits(MAX_GMSL1_4(link), 0x03, on ? 0x03 : 0x00);
+	usleep_range(2000, 2500);
+}
+
+static int max9296_gmsl1_get_link_lock(struct max9296_priv *priv, int link_n)
+{
+	int val = 0;
+
+	des_read(MAX_GMSL1_CB(link_n), &val);
+
+	return !!(val & BIT(0));
+}
+
+static void max9296_gmsl1_link_crossbar_setup(struct max9296_priv *priv, int link, int dt)
+{
+	/* Always decode reversed bus, since we always reverse on serializer (old imagers need this) */
+	switch (dt) {
+	case MIPI_DT_YUV8:
+		des_write(MAX_CROSS(link, 0), 7);
+		des_write(MAX_CROSS(link, 1), 6);
+		des_write(MAX_CROSS(link, 2), 5);
+		des_write(MAX_CROSS(link, 3), 4);
+		des_write(MAX_CROSS(link, 4), 3);
+		des_write(MAX_CROSS(link, 5), 2);
+		des_write(MAX_CROSS(link, 6), 1);
+		des_write(MAX_CROSS(link, 7), 0);
+
+		if (priv->dbl == 0) {
+			/* deserializer DBL=1 is MUX, DBL=0 is Normal */
+			des_write(MAX_CROSS(link, 8), 15);
+			des_write(MAX_CROSS(link, 9), 14);
+			des_write(MAX_CROSS(link, 10), 13);
+			des_write(MAX_CROSS(link, 11), 12);
+			des_write(MAX_CROSS(link, 12), 11);
+			des_write(MAX_CROSS(link, 13), 10);
+			des_write(MAX_CROSS(link, 14), 9);
+			des_write(MAX_CROSS(link, 15), 8);
+		}
+		break;
+	case MIPI_DT_RAW12:
+		des_write(MAX_CROSS(link, 0), 11);
+		des_write(MAX_CROSS(link, 1), 10);
+		des_write(MAX_CROSS(link, 2), 9);
+		des_write(MAX_CROSS(link, 3), 8);
+		des_write(MAX_CROSS(link, 4), 7);
+		des_write(MAX_CROSS(link, 5), 6);
+		des_write(MAX_CROSS(link, 6), 5);
+		des_write(MAX_CROSS(link, 7), 4);
+		des_write(MAX_CROSS(link, 8), 3);
+		des_write(MAX_CROSS(link, 9), 2);
+		des_write(MAX_CROSS(link, 10), 1);
+		des_write(MAX_CROSS(link, 11), 0);
+
+		if (priv->dbl == 0) {
+			/* deserializer DBL=1 is MUX, DBL=0 is Normal */
+			des_write(MAX_CROSS(link, 12), 23);
+			des_write(MAX_CROSS(link, 13), 22);
+			des_write(MAX_CROSS(link, 14), 21);
+			des_write(MAX_CROSS(link, 15), 20);
+			des_write(MAX_CROSS(link, 16), 19);
+			des_write(MAX_CROSS(link, 17), 18);
+			des_write(MAX_CROSS(link, 18), 17);
+			des_write(MAX_CROSS(link, 19), 16);
+			des_write(MAX_CROSS(link, 20), 15);
+			des_write(MAX_CROSS(link, 21), 14);
+			des_write(MAX_CROSS(link, 22), 13);
+			des_write(MAX_CROSS(link, 23), 12);
+		}
+		break;
+	default:
+		dev_err(&priv->client->dev, "crossbar for dt %d is not supported\n", dt);
+		break;
+	}
+
+	des_write(MAX_CROSS(link, 24), (priv->hsync ? 0x40 : 0) + 24);	/* invert HS polarity */
+	des_write(MAX_CROSS(link, 25), (priv->vsync ? 0 : 0x40) + 25);	/* invert VS polarity */
+	des_write(MAX_CROSS(link, 26), (priv->hsync ? 0x40 : 0) + 26);	/* invert DE polarity */
+}
+
+static void max9296_gmsl1_initial_setup(struct max9296_priv *priv)
+{
+	int i;
+
+	des_write(MAX9296_REG6, 0x10);				/* set GMSL1 mode */
+	des_write(MAX9296_REG1, 0x01);				/* 187.5M/3G */
+
+	for (i = 0; i < priv->n_links; i++) {
+		des_write(MAX_GMSL1_2(i), 0x03);			/* Autodetect serial data rate range */
+		des_write(MAX_GMSL1_4(i), 0);				/* disable REV/FWD CC */
+		des_update_bits(MAX_GMSL1_6(i), BIT(7), priv->him ? BIT(7) : 0); /* HIM/Legacy mode */
+		des_write(MAX_GMSL1_7(i), (priv->dbl ? BIT(7) : 0) |	/* DBL mode */
+					  (priv->bws ? BIT(5) : 0) |	/* BWS 32/24-bit */
+					  (priv->hibw ? BIT(3) : 0) |	/* High-bandwidth mode */
+					  (priv->hven ? BIT(2) : 0));	/* HS/VS encoding enable */
+		des_write(MAX_GMSL1_D(i), 0);				/* disable artificial ACKs, RC conf disable */
+		des_write(MAX_GMSL1_F(i), 0);				/* disable DE processing */
+		des_write(MAX_GMSL1_96(i), (0x13 << 3) | 0x3);		/* color map: RAW12 double - i.e. bypass packet as is */
+	}
+}
+
+static int max9296_gmsl1_reverse_channel_setup(struct max9296_priv *priv, int link_n)
+{
+	struct max9296_link *link = priv->link[link_n];
+	int ser_addrs[] = { 0x40 };					/* possible MAX9271/MAX96705 addresses on i2c bus */
+	int lock_sts;
+	int timeout = priv->timeout;
+	char timeout_str[40];
+	u8 val = 0;
+	int ret = 0;
+
+	des_write(MAX_GMSL1_D(link_n), 0x81);			/* enable artificial ACKs, RC conf mode */
+	des_write(MAX_RLMSC5(link_n), 0xa0);			/* override RC pulse length */
+	des_write(MAX_RLMSC4(link_n), 0x80);			/* override RC rise/fall time */
+	usleep_range(2000, 2500);
+	des_write(MAX_GMSL1_4(link_n), 0x3);			/* enable REV/FWD CC */
+	des_write(MAX9296_GMSL1_EN, BIT(link_n));		/* enable GMSL link# */
+	des_update_bits(MAX9296_CTRL0, 0x13, BIT(link_n));	/* enable GMSL link# */
+	max9296_reset_oneshot(priv);
+	usleep_range(2000, 2500);
+
+	for (; timeout > 0; timeout--) {
+		if (priv->him) {
+			/* HIM mode setup */
+			__reg8_write(ser_addrs[0], 0x4d, 0xc0);
+			usleep_range(2000, 2500);
+			__reg8_write(ser_addrs[0], 0x04, 0x43);	/* wake-up, enable RC, conf_link */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				__reg8_write(ser_addrs[0], 0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+								 (priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+								 (0x80) |				/* DBL=1 in serializer */
+								 (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+				usleep_range(2000, 2500);
+			}
+		} else {
+			/* Legacy mode setup */
+			des_write(MAX_RLMS95(link_n), 0x88);		/* override RC Tx amplitude */
+			usleep_range(2000, 2500);
+
+			__reg8_write(ser_addrs[0], 0x04, 0x43);		/* wake-up, enable RC, conf_link */
+			usleep_range(2000, 2500);
+			__reg8_write(ser_addrs[0], 0x08, 0x01);		/* RC receiver high threshold enable */
+			__reg8_write(ser_addrs[0], 0x97, 0x5f);		/* enable RC programming (MAX96705-MAX96711 only) */
+			usleep_range(2000, 2500);
+
+			if (priv->bws) {
+				__reg8_write(ser_addrs[0], 0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+								 (priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+								 (0x80) |				/* DBL=1 in serializer */
+								 (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+				usleep_range(2000, 2500);
+			}
+
+			des_write(MAX_RLMS95(link_n), 0xd3);	/* increase RC Tx amplitude */
+			usleep_range(2000, 2500);
+		}
+
+		__reg8_read(ser_addrs[0], 0x1e, &val);
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			link->ser_id = val;
+			__reg8_write(ser_addrs[0], 0x00, link->ser_addr << 1);	 /* relocate serizlizer on I2C bus */
+			usleep_range(2000, 2500);
+			break;
+		}
+
+		/* Check if already initialized (after reboot/reset ?) */
+		ser_read(0x1e, &val);
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			link->ser_id = val;
+			ser_write(0x04, 0x43);			/* enable RC, conf_link */
+			usleep_range(2000, 2500);
+			ret = -EADDRINUSE;
+			break;
+		}
+
+		if (poc_trig) {
+			if (!IS_ERR(link->poc_reg) && (timeout % poc_trig == 0)) {
+				regulator_disable(link->poc_reg); /* POC power off */
+				mdelay(200);
+				ret = regulator_enable(link->poc_reg); /* POC power on */
+				if (ret)
+					dev_err(&link->client->dev, "failed to enable poc regulator\n");
+				mdelay(priv->poc_delay);
+			}
+		}
+	}
+
+	max9296_gmsl1_sensor_reset(priv, link_n, 0);		/* sensor un-reset */
+
+	des_write(MAX_GMSL1_D(link_n), 0);			/* disable artificial ACKs, RC conf disable */
+	usleep_range(2000, 2500);
+	des_read(MAX_GMSL1_CB(link_n), &lock_sts);
+	lock_sts = !!(lock_sts & 0x01);
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	priv->links_mask |= BIT(link_n);
+
+out:
+	sprintf(timeout_str, " retries=%d lock_sts=%d", priv->timeout - timeout, lock_sts);
+	dev_info(&priv->client->dev, "GMSL1 link%d %s %sat 0x%x %s %s\n", link_n, chip_name(link->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", link->ser_addr,
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL link establish" : "",
+			       priv->timeout - timeout ? timeout_str : "");
+	return ret;
+}
+
+static int max9296_gmsl1_link_serializer_setup(struct max9296_priv *priv, int link_n)
+{
+	struct max9296_link *link = priv->link[link_n];
+
+	/* GMSL setup */
+	ser_write(0x0d, 0x22 | MAXIM_I2C_I2C_SPEED);		/* disable artificial ACK, I2C speed set */
+	ser_write(0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+				       (priv->pclk_rising_edge ? 0 : 0x10) | /* PCLK edge */
+				       (0x80) |				/* DBL=1 in serializer */
+				       (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+	usleep_range(2000, 2500);
+	ser_write(0x02, 0xff);					/* spread spectrum +-4%, pclk range automatic, Gbps automatic */
+	usleep_range(2000, 2500);
+
+	if (link->ser_id != MAX9271_ID) {
+		switch (priv->dt) {
+		case MIPI_DT_YUV8:
+			if (priv->dbl == 1) {
+				/* setup crossbar for YUV8/RAW8: reverse DVP bus */
+				ser_write(0x20, priv->cb[7]);
+				ser_write(0x21, priv->cb[6]);
+				ser_write(0x22, priv->cb[5]);
+				ser_write(0x23, priv->cb[4]);
+				ser_write(0x24, priv->cb[3]);
+				ser_write(0x25, priv->cb[2]);
+				ser_write(0x26, priv->cb[1]);
+				ser_write(0x27, priv->cb[0]);
+
+				/* this is second byte in the packet (DBL=1 in serializer always) */
+				ser_write(0x30, priv->cb[7] + 16);
+				ser_write(0x31, priv->cb[6] + 16);
+				ser_write(0x32, priv->cb[5] + 16);
+				ser_write(0x33, priv->cb[4] + 16);
+				ser_write(0x34, priv->cb[3] + 16);
+				ser_write(0x35, priv->cb[2] + 16);
+				ser_write(0x36, priv->cb[1] + 16);
+				ser_write(0x37, priv->cb[0] + 16);
+			} else {
+				/* setup crossbar for YUV8/RAW8: reversed DVP bus */
+				ser_write(0x20, priv->cb[4]);
+				ser_write(0x21, priv->cb[3]);
+				ser_write(0x22, priv->cb[2]);
+				ser_write(0x23, priv->cb[1]);
+				ser_write(0x24, priv->cb[0]);
+				ser_write(0x25, 0x40);
+				ser_write(0x26, 0x40);
+				if (link->ser_id == MAX96705_ID) {
+					ser_write(0x27, 14); /* HS: D14->D18  */
+					ser_write(0x28, 15); /* VS: D15->D19 */
+					ser_write(0x29, 14); /* DE: D14->D20 */
+				}
+				if (link->ser_id == MAX96707_ID) {
+					ser_write(0x27, 12); /* HS: D12->D18, this is a virtual NC pin, hence it is D14 at HS */
+					ser_write(0x28, 13); /* VS: D13->D19 */
+					ser_write(0x29, 12); /* DE: D12->D20 */
+				}
+				ser_write(0x2A, 0x40);
+
+				/* this is second byte in the packet (DBL=1 in serializer) */
+				ser_write(0x30, 0x10 + priv->cb[7]);
+				ser_write(0x31, 0x10 + priv->cb[6]);
+				ser_write(0x32, 0x10 + priv->cb[5]);
+				ser_write(0x33, 0x10 + priv->cb[4]);
+				ser_write(0x34, 0x10 + priv->cb[3]);
+				ser_write(0x35, 0x10 + priv->cb[2]);
+				ser_write(0x36, 0x10 + priv->cb[1]);
+				ser_write(0x37, 0x10 + priv->cb[0]);
+				ser_write(0x38, priv->cb[7]);
+				ser_write(0x39, priv->cb[6]);
+				ser_write(0x3A, priv->cb[5]);
+
+				ser_write(0x67, 0xC4); /* DBL_ALIGN_TO = 100b */
+			}
+			break;
+		case MIPI_DT_RAW12:
+			/* setup crossbar for RAW12: reverse DVP bus */
+			ser_write(0x20, priv->cb[11]);
+			ser_write(0x21, priv->cb[10]);
+			ser_write(0x22, priv->cb[9]);
+			ser_write(0x23, priv->cb[8]);
+			ser_write(0x24, priv->cb[7]);
+			ser_write(0x25, priv->cb[6]);
+			ser_write(0x26, priv->cb[5]);
+			ser_write(0x27, priv->cb[4]);
+			ser_write(0x28, priv->cb[3]);
+			ser_write(0x29, priv->cb[2]);
+			ser_write(0x2a, priv->cb[1]);
+			ser_write(0x2b, priv->cb[0]);
+
+			/* this is second byte in the packet (DBL=1 in serializer) */
+			ser_write(0x30, priv->cb[11] + 16);
+			ser_write(0x31, priv->cb[10] + 16);
+			ser_write(0x32, priv->cb[9] + 16);
+			ser_write(0x33, priv->cb[8] + 16);
+			ser_write(0x34, priv->cb[7] + 16);
+			ser_write(0x35, priv->cb[6] + 16);
+			ser_write(0x36, priv->cb[5] + 16);
+			ser_write(0x37, priv->cb[4] + 16);
+			ser_write(0x38, priv->cb[3] + 16);
+			ser_write(0x39, priv->cb[2] + 16);
+			ser_write(0x3a, priv->cb[1] + 16);
+			ser_write(0x3b, priv->cb[0] + 16);
+
+			if (!(priv->bws || priv->hibw) && priv->dbl)
+				dev_err(&priv->client->dev, " BWS must be 27/32-bit for RAW12 in DBL mode\n");
+			break;
+		}
+	}
+
+	/* I2C translator setup */
+	//ser_write(0x09, OV490_I2C_ADDR_NEW << 1);	/* sensor I2C translated - must be set by sensor driver */
+	//ser_write(0x0A, OV490_I2C_ADDR << 1);		/* sensor I2C native - must be set by sensor driver */
+	ser_write(0x0B, BROADCAST << 1);		/* serializer broadcast I2C translated */
+	ser_write(0x0C, link->ser_addr << 1);		/* serializer broadcast I2C native */
+	/* put serializer in configuration link state  */
+	ser_write(0x04, 0x43);				/* enable RC, conf_link */
+	usleep_range(2000, 2500);
+
+	return 0;
+}
+
+static void max9296_gmsl1_link_pipe_setup(struct max9296_priv *priv, int link_n)
+{
+	struct max9296_link *link = priv->link[link_n];
+	int pipe = link_n; /* straight map */
+	int dt = priv->dt; /* should come from imager */
+	int in_vc = 0;
+
+	max9296_pipe_override(priv, pipe, dt, in_vc);		/* override dt, vc */
+
+	des_write(MAX_MIPI_TX11(pipe), 0x00);			/* disable all mappings */
+	des_write(MAX_MIPI_TX12(pipe), 0x00);
+
+	/* use map #0 for payload data */
+	max9296_set_pipe_to_mipi_mapping(priv, pipe, 0,	/* pipe, map# */
+					  dt, in_vc,		/* src DT, VC */
+					  dt, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	/* use map #1 for FS */
+	max9296_set_pipe_to_mipi_mapping(priv, pipe, 1,	/* pipe, map# */
+					  0x00, in_vc,		/* src DT, VC */
+					  0x00, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	/* use map #2 for FE */
+	max9296_set_pipe_to_mipi_mapping(priv, pipe, 2,	/* pipe, map# */
+					  0x01, in_vc,		/* src DT, VC */
+					  0x01, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	usleep_range(5000, 5500);
+
+	link->pipes_mask |= BIT(pipe);
+}
+
+static void max9296_gmsl1_postinit(struct max9296_priv *priv)
+{
+	int i;
+	u8 val = 0;
+
+	for (i = 0; i < priv->n_links; i++) {
+		struct max9296_link *link = priv->link[i];
+
+		if (!(priv->links_mask & BIT(i)))
+			continue;
+
+		des_write(MAX_GMSL1_4(i), 0x3);			/* enable REV/FWD CC */
+		des_write(MAX9296_GMSL1_EN, BIT(i));		/* enable GMSL link# */
+		des_update_bits(MAX9296_CTRL0, 0x13, BIT(i));	/* enable GMSL link# */
+		max9296_reset_oneshot(priv);
+		usleep_range(2000, 2500);
+
+		ser_read(0x15, &val);
+		if (!(val & BIT(1)))
+			dev_warn(&priv->client->dev, "link%d valid PCLK is not detected\n", i);
+
+		/* switch to GMSL serial_link for streaming video */
+		max9296_write_remote_verify(priv, i, 0x04, conf_link ? 0x43 : 0x83);
+		usleep_range(2000, 2500);
+
+		des_write(MAX_GMSL1_4(i), 0x00);		/* disable REV/FWD CC */
+
+		switch (priv->link[i]->ser_id) {
+		case MAX9271_ID:
+			des_update_bits(MAX_GMSL1_6(i), 0x07, 0x01); /* use D14/15 for HS/VS */
+			break;
+		case MAX96705_ID:
+		case MAX96707_ID:
+			des_update_bits(MAX_GMSL1_6(i), 0x07, 0x00); /* use D18/D19 for HS/VS */
+			break;
+		}
+	}
+
+	for (i = 0; i < priv->n_links; i++)
+		des_write(MAX_GMSL1_4(i), priv->links_mask & BIT(i) ? 0x03 : 0); /* enable REV/FWD CC */
+
+	des_write(MAX9296_GMSL1_EN, priv->links_mask);		/* enable detected links */
+	des_update_bits(MAX9296_CTRL0, 0x13, priv->links_mask == 3 ? 0x13 : priv->links_mask); /* enable detected links */
+	max9296_reset_oneshot(priv);				/* one-shot reset links */
+}
+
+static void max9296_gmsl1_fsync_setup(struct max9296_priv *priv)
+{
+	des_write(MAX9296_FSYNC_5, priv->fsync_period & 0xff);	/* Fsync Period L */
+	des_write(MAX9296_FSYNC_6, (priv->fsync_period >> 8) & 0xff);/* Fsync Period M */
+	des_write(MAX9296_FSYNC_7, priv->fsync_period >> 16);	/* Fsync Period H */
+	//des_write(MAX9296_FSYNC_8, 0x00);			/* Disable Err Thresh */
+	//des_write(MAX9296_FSYNC_9, 0x00);			/* Disable Err Thresh */
+	des_write(MAX9296_FSYNC_10, 0x00);			/* Disable Overlap */
+	des_write(MAX9296_FSYNC_11, 0x00);
+
+	des_write(MAX9296_FSYNC_0, 0x00);			/* Manual method, Internal GMSL1 generator mode */
+
+	des_write(MAX_GMSL1_8(0), 0x11);			/* Fsync Tx Enable on Link A */
+	des_write(MAX_GMSL1_8(1), 0x11);			/* Fsync Tx Enable on Link B */
+	des_write(MAX_GMSL1_8(2), 0x11);			/* Fsync Tx Enable on Link C */
+	des_write(MAX_GMSL1_8(3), 0x11);			/* Fsync Tx Enable on Link D */
+
+	des_write(MAX9296_FSYNC_15, 0x1f);			/* GMSL1 Type Fsync, Enable all pipes */
+}
+
+/* -----------------------------------------------------------------------------
+ * GMSL2
+ */
+
+static void max9296_gmsl2_cc_enable(struct max9296_priv *priv, int link, int on)
+{
+	/* nothing */
+}
+
+static int max9296_gmsl2_get_link_lock(struct max9296_priv *priv, int link_n)
+{
+	int val = 0;
+
+	des_read(MAX9296_CTRL3, &val);
+
+	return !!(val & BIT(3)) && (val & BIT(link_n + 4));
+}
+
+static void max9296_gmsl2_initial_setup(struct max9296_priv *priv)
+{
+	des_write(MAX9296_REG6, 0xC0 | 0x10);	/* set GMSL2 mode */
+	des_write(MAX9296_REG1, 0x02);		/* 187.5M/6G */
+}
+
+static int max9296_gmsl2_reverse_channel_setup(struct max9296_priv *priv, int link_n)
+{
+	struct max9296_link *link = priv->link[link_n];
+	int ser_addrs[] = {0x40, 0x42, 0x60, 0x62}; /* possible MAX9295 addresses on i2c bus */
+	int timeout = priv->timeout;
+	int ret = 0;
+	int i = 0;
+
+	des_update_bits(MAX9296_CTRL0, 0x13, BIT(link_n));	/* enable GMSL link# */
+	max9296_reset_oneshot(priv);
+
+	/* wait the link to be established, indicated when status bit LOCKED goes high */
+	for (; timeout > 0; timeout--) {
+		if (max9296_gmsl2_get_link_lock(priv, link_n))
+			break;
+		mdelay(1);
+	}
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ser_addrs); i++) {
+		int val = 0;
+
+		__reg16_read(ser_addrs[i], 0x000d, &val);	/* read serializer ID */
+		if (val == MAX9295A_ID || val == MAX9295B_ID) {
+			link->ser_id = val;
+			__reg16_write(ser_addrs[i], 0x0000, link->ser_addr << 1); /* relocate serizlizer on I2C bus */
+			usleep_range(2000, 2500);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ser_addrs)) {
+		dev_err(&priv->client->dev, "serializer not found\n");
+		goto out;
+	}
+
+	priv->links_mask |= BIT(link_n);
+
+out:
+	dev_info(&priv->client->dev, "link%d %s %sat 0x%x (0x%x) %s\n", link_n, chip_name(link->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", link->ser_addr, ser_addrs[i],
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL2 link establish" : "");
+	return ret;
+}
+
+static int max9296_gmsl2_link_serializer_setup(struct max9296_priv *priv, int link_n)
+{
+	struct max9296_link *link = priv->link[link_n];
+	int i;
+
+	if (strcmp(priv->mbus, "dvp") == 0) {
+		ser_write(MAX9295_VIDEO_TX0(0), BIT(6) |	/* line CRC enable */
+						(priv->hven ? BIT(5) : 0)); /* HS/VS encoding */
+		ser_write(MAX9295_VIDEO_TX1(0), 0x0a);	/* BPP = 10 */
+		ser_write(MAX9295_REG7, 0x07);		/* DVP stream, enable HS/VS, rising edge */
+
+		switch (priv->dt) {
+		case MIPI_DT_YUV8:
+		case MIPI_DT_RAW12:
+			/* setup crossbar: strait DVP mapping */
+			ser_write(MAX9295_CROSS(0), priv->cb[0]);
+			ser_write(MAX9295_CROSS(1), priv->cb[1]);
+			ser_write(MAX9295_CROSS(2), priv->cb[2]);
+			ser_write(MAX9295_CROSS(3), priv->cb[3]);
+			ser_write(MAX9295_CROSS(4), priv->cb[4]);
+			ser_write(MAX9295_CROSS(5), priv->cb[5]);
+			ser_write(MAX9295_CROSS(6), priv->cb[6]);
+			ser_write(MAX9295_CROSS(7), priv->cb[7]);
+			ser_write(MAX9295_CROSS(8), priv->cb[8]);
+			ser_write(MAX9295_CROSS(9), priv->cb[9]);
+			ser_write(MAX9295_CROSS(10), priv->cb[10]);
+			ser_write(MAX9295_CROSS(11), priv->cb[11]);
+			break;
+		}
+	} else {
+		/* defaults:
+		 *  REG2	- video enable Pipex X,Z
+		 *  MIPI_RX0	- 1x4 mode (1-port x 4-lanes)
+		 *  MIPI_RX1	- 4-lanes
+		 *  MIPI_RX2, MIPI_RX3 - merge PHY1,PHY2 to 1x4-mode
+		 *  FRONTTOP_9	- start Pipes X,Z from CSI_A,CSI_B
+		 */
+
+		ser_write(MAX9295_FRONTTOP_0, 0x71);			/* enable Pipe X from from CSI_A,CSI_B */
+		ser_write(MAX9295_FRONTTOP_12, BIT(6) | priv->dt);	/* primary DT for Pipe X */
+		ser_write(MAX9295_FRONTTOP_13, BIT(6) | MIPI_DT_EMB);	/* secondary DT for Pipe X */
+	}
+
+	for (i = 0; i < 11; i++) {
+		if (priv->gpio[i] == 0) {
+			/* GPIO set 0 */
+			ser_write(MAX9295_GPIO_A(i), 0x80);	/* 1MOm, GPIO output low */
+			ser_write(MAX9295_GPIO_B(i), 0xa0);	/* push-pull, pull-down */
+		}
+		if (priv->gpio[i] == 1) {
+			/* GPIO set 1 */
+			ser_write(MAX9295_GPIO_A(i), 0x90);	/* 1MOm, GPIO output high */
+			ser_write(MAX9295_GPIO_B(i), 0x60);	/* push-pull, pull-up */
+		}
+		if (priv->gpio[i] == 2) {
+			/* GPIO FSIN */
+			ser_write(MAX9295_GPIO_A(i), 0x84);	/* 1MOm, GMSL2 RX from deserializer */
+			ser_write(MAX9295_GPIO_C(i), 0x08);	/* pull-none, GPIO ID=8 assosiated with FSYNC transmission */
+		}
+		if (priv->gpio[i] == 3) {
+			/* GPIO Interrupt */
+			ser_write(MAX9295_GPIO_A(i), 0x63);	/* 40kOm, GMSL2 TX to deserializer */
+			ser_write(MAX9295_GPIO_B(i), 0x25);	/* push-pull, pull-none, GPIO stream ID=5 */
+		}
+	}
+
+	/* I2C translator setup */
+	//ser_write(MAX9295_I2C2, OV490_I2C_ADDR_NEW << 1); /* sensor I2C translated - must be set by sensor driver */
+	//ser_write(MAX9295_I2C3, OV490_I2C_ADDR << 1);	/* sensor I2C native - must be set by sensor driver */
+	ser_write(MAX9295_I2C4, BROADCAST << 1);	/* serializer broadcast I2C translated */
+	ser_write(MAX9295_I2C5, link->ser_addr << 1);	/* serializer broadcast I2C native */
+	usleep_range(2000, 2500);
+
+	return 0;
+}
+
+static struct {
+	int in_dt;
+	int out_dt;
+} gmsl2_pipe_maps[] = {
+	{0x00,		0x00},		/* FS */
+	{0x01,		0x01},		/* FE */
+	{MIPI_DT_YUV8,	MIPI_DT_YUV8},	/* payload data */
+	{MIPI_DT_RAW8,	MIPI_DT_RAW8},
+	{MIPI_DT_RAW12,	MIPI_DT_RAW12},
+};
+
+static void max9296_gmsl2_pipe_set_source(struct max9296_priv *priv, int pipe, int phy, int in_pipe)
+{
+	// TODO
+}
+
+static void max9296_gmsl2_link_pipe_setup(struct max9296_priv *priv, int link_n)
+{
+	struct max9296_link *link = priv->link[link_n];
+	int pipe = link_n; /* straight mapping */
+	int dt = priv->dt; /* must come from imager */
+	int in_vc = 0;
+	int i;
+
+	max9296_gmsl2_pipe_set_source(priv, pipe, link_n, 0);			/* route Pipe X only */
+
+	if (strcmp(priv->mbus, "dvp") == 0) {
+		des_write(MAX9296_RX0(pipe), 0);				/* stream_id = 0 */
+		//des_update_bits(MAX_VIDEO_RX0(pipe), BIT(0), BIT(0));		/* disable Packet detector */
+		max9296_pipe_override(priv, pipe, dt, in_vc);			/* override dt, vc */
+	}
+
+	des_write(MAX_MIPI_TX11(pipe), 0x00);					/* disable all mappings */
+	des_write(MAX_MIPI_TX12(pipe), 0x00);
+
+	for (i = 0; i < ARRAY_SIZE(gmsl2_pipe_maps); i++) {
+		max9296_set_pipe_to_mipi_mapping(priv, pipe, i,		/* pipe, map# */
+						  gmsl2_pipe_maps[i].in_dt, in_vc, /* src DT, VC */
+						  gmsl2_pipe_maps[i].out_dt, link->out_vc, /* dst DT, VC */
+						  link->out_mipi);		/* dst MIPI PHY */
+	}
+
+	link->pipes_mask |= BIT(pipe);
+}
+
+static void max9296_gmsl2_postinit(struct max9296_priv *priv)
+{
+	des_update_bits(MAX9296_CTRL0, 0x13, priv->links_mask == 3 ? 0x13 : priv->links_mask); /* enable detected links */
+	max9296_reset_oneshot(priv);				/* one-shot reset links */
+}
+
+static void max9296_gmsl2_link_crossbar_setup(struct max9296_priv *priv, int link, int dt)
+{
+	des_write(MAX_CROSS(link, 24), (priv->hsync ? 0x40 : 0) + 24);	/* invert HS polarity */
+	des_write(MAX_CROSS(link, 25), (priv->vsync ? 0 : 0x40) + 25);	/* invert VS polarity */
+	des_write(MAX_CROSS(link, 26), (priv->hsync ? 0x40 : 0) + 26);	/* invert DE polarity */
+}
+
+static void max9296_gmsl2_fsync_setup(struct max9296_priv *priv)
+{
+	des_write(MAX9296_FSYNC_5, priv->fsync_period & 0xff);	/* Fsync Period L */
+	des_write(MAX9296_FSYNC_6, (priv->fsync_period >> 8) & 0xff);/* Fsync Period M */
+	des_write(MAX9296_FSYNC_7, priv->fsync_period >> 16);	/* Fsync Period H */
+	des_write(MAX9296_FSYNC_10, 0x00);			/* Disable Overlap */
+	des_write(MAX9296_FSYNC_11, 0x00);
+
+	des_write(MAX9296_FSYNC_0, 0x00);			/* Manual method, Internal GMSL2 generator mode */
+	des_write(MAX9296_FSYNC_15, 0x80);			/* GMSL2 Type Fsync, Disable all pipes for manual mode */
+	des_write(MAX9296_FSYNC_17, 8 << 3);			/* GPIO ID=8 assosiated with FSYNC transmission */
+}
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int max9296_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int max9296_i2c_mux_init(struct max9296_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->n_links, 0, I2C_MUX_LOCKED,
+				  max9296_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+#define max9296_cc_enable(priv,i,en)		(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_cc_enable(priv, i, en) : \
+										 max9296_gmsl1_cc_enable(priv, i, en))
+#define max9296_initial_setup(priv)		(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_initial_setup(priv) : \
+										 max9296_gmsl1_initial_setup(priv))
+#define max9296_reverse_channel_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_reverse_channel_setup(priv, i) : \
+										 max9296_gmsl1_reverse_channel_setup(priv, i))
+#define max9296_link_serializer_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_link_serializer_setup(priv, i) : \
+										 max9296_gmsl1_link_serializer_setup(priv, i))
+#define max9296_link_pipe_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_link_pipe_setup(priv, i) : \
+										 max9296_gmsl1_link_pipe_setup(priv, i))
+#define max9296_link_crossbar_setup(priv,i,dt)	(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_link_crossbar_setup(priv, i, dt) : \
+										 max9296_gmsl1_link_crossbar_setup(priv, i, dt))
+#define max9296_postinit(priv)			(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_postinit(priv) : \
+										 max9296_gmsl1_postinit(priv))
+#define max9296_fsync_setup(priv)		(priv->gmsl_mode == MODE_GMSL2 ? max9296_gmsl2_fsync_setup(priv) : \
+										 max9296_gmsl1_fsync_setup(priv))
+
+static int max9296_preinit(struct max9296_priv *priv)
+{
+	int i;
+
+	des_update_bits(MAX9296_CTRL0, BIT(7), BIT(7));	/* reset chip */
+	mdelay(5);
+
+	/* enable internal regulator for 1.2V VDD supply */
+	des_update_bits(MAX9296_CTRL0, BIT(2), BIT(2));	/* REG_ENABLE = 1 */
+	des_update_bits(MAX9296_CTRL2, BIT(4), BIT(4));	/* REG_MNL = 1 */
+
+	/* this is needed for engineering samples */
+	for (i = 0; i < priv->n_links; i++) {
+		des_write(MAX_RLMS4(i), 0x29);
+		des_write(MAX_RLMSA4(i), 0xc8);
+		des_write(MAX_RLMSA(i), 0x00);
+		des_write(MAX_RLMSB(i), 0x00);
+	}
+
+	/* I2C-I2C timings */
+	des_write(MAX9296_I2C_PT_0, 0x01);		/* Fast mode Plus, 1mS timeout */
+	des_write(MAX9296_I2C_PT_1, 0x51);		/* i2c speed: 397Kbps, 32mS timeout */
+	des_write(MAX9296_I2C_0, 0x01);			/* Fast mode Plus, 1mS timeout */
+	des_write(MAX9296_I2C_1, 0x51);			/* i2c speed: 397Kbps, 1mS timeout */
+
+	des_write(MAX9296_CTRL1, priv->is_coax ? 0x5 : 0); /* cable mode */
+	des_write(MAX9296_GMSL1_EN, 0);			/* disable all links */
+	des_update_bits(MAX9296_CTRL0, 0x13, 0);	/* disable all links */
+
+	return 0;
+}
+
+static int max9296_initialize(struct max9296_priv *priv)
+{
+	int ret, i;
+
+	max9296_preinit(priv);
+	max9296_initial_setup(priv);
+	max9296_mipi_setup(priv);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg)) {
+			ret = regulator_enable(priv->link[i]->poc_reg); /* POC power on */
+			if (ret) {
+				dev_err(&priv->link[i]->client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ret = max9296_reverse_channel_setup(priv, i);
+		if (ret == -ETIMEDOUT)
+			continue;
+		if (!ret)
+			max9296_link_serializer_setup(priv, i);
+
+		max9296_link_pipe_setup(priv, i);
+		max9296_link_crossbar_setup(priv, i, priv->dt);
+
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+		max9296_cc_enable(priv, i, 0);
+	}
+
+	max9296_postinit(priv);
+	max9296_fsync_setup(priv);
+
+	return 0;
+}
+
+static int max9296_reboot_notifier(struct notifier_block *nb, unsigned long code, void *data)
+{
+	struct max9296_priv *priv = container_of(nb, struct max9296_priv, reboot_nb);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg))
+			regulator_disable(priv->link[i]->poc_reg); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int max9296_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct max9296_priv *priv = v4l2_get_subdevdata(sd);
+
+	if (enable) {
+		if (atomic_inc_return(&priv->use_count) == 1)
+			des_update_bits(MAX_BACKTOP12(0), 0x02, 0x02); /* CSI output enable */
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0)
+			des_update_bits(MAX_BACKTOP12(0), 0x02, 0); /* CSI output disable */
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops max9296_video_ops = {
+	.s_stream = max9296_s_stream,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int max9296_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct max9296_priv *priv = v4l2_get_subdevdata(sd);
+	int ret;
+	int val = 0;
+
+	ret = des_read(reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int max9296_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)
+{
+	struct max9296_priv *priv = v4l2_get_subdevdata(sd);
+
+	return des_write(reg->reg, (u8)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops max9296_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = max9296_g_register,
+	.s_register = max9296_s_register,
+#endif
+};
+
+static struct v4l2_subdev_ops max9296_subdev_ops = {
+	.core = &max9296_subdev_core_ops,
+	.video = &max9296_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int max9296_notify_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *subdev,
+				 struct v4l2_async_subdev *asd)
+{
+	struct max9296_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9296_link *link = asd_to_max9296_link(asd);
+	int sink_pad = link->pad;
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, link->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	link->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void max9296_notify_unbind(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *subdev,
+				   struct v4l2_async_subdev *asd)
+{
+	struct max9296_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max9296_link *link = asd_to_max9296_link(asd);
+
+	link->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations max9296_notify_ops = {
+	.bound = max9296_notify_bound,
+	.unbind = max9296_notify_unbind,
+};
+
+static int max9296_v4l2_init(struct i2c_client *client)
+{
+	struct max9296_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+	long pixel_rate;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+
+	priv->notifier.ops = &max9296_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &max9296_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Only YUV422 bpp=16 supported atm, decode to pixel_rate from fixed csi_rate */
+	pixel_rate = priv->csi_rate[priv->link[0]->out_mipi] / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  pixel_rate, pixel_rate, 1, pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[MAX9296_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[MAX9296_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9296_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9296_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX9296_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, MAX9296_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, MAX9296_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int max9296_parse_dt(struct i2c_client *client)
+{
+	struct max9296_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	struct property *prop;
+	char name[16];
+	int i, csi_rate, err;
+	u32 addrs[4], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+
+	priv->n_links = naddrs;
+	for (i = 0; i < priv->n_links; i++)
+		priv->link[i]->ser_addr = addrs[i];
+
+	if (of_property_read_u32(np, "maxim,gmsl", &priv->gmsl_mode))
+		priv->gmsl_mode = MODE_GMSL2;
+	if (of_property_read_bool(np, "maxim,stp"))
+		priv->is_coax = 0;
+	else
+		priv->is_coax = 1;
+	if (of_property_read_u32(np, "maxim,resetb-gpio", &priv->gpio_resetb)) {
+		priv->gpio_resetb = -1;
+	} else {
+		if (of_property_read_bool(np, "maxim,resetb-active-high"))
+			priv->active_low_resetb = 0;
+		else
+			priv->active_low_resetb = 1;
+	}
+	if (of_property_read_u32(np, "maxim,fsync-period", &priv->fsync_period))
+		priv->fsync_period = 3210000;/* 96MHz/30fps */
+	priv->pclk_rising_edge = true;
+	if (of_property_read_bool(np, "maxim,pclk-falling-edge"))
+		priv->pclk_rising_edge = false;
+	if (of_property_read_u32(np, "maxim,timeout", &priv->timeout))
+		priv->timeout = 100;
+	if (of_property_read_u32(np, "maxim,him", &priv->him))
+		priv->him = 0;
+	if (of_property_read_u32(np, "maxim,bws", &priv->bws))
+		priv->bws = 0;
+	if (of_property_read_u32(np, "maxim,dbl", &priv->dbl))
+		priv->dbl = 1;
+	if (of_property_read_u32(np, "maxim,hven", &priv->hven))
+		priv->hven = 1;
+	if (of_property_read_u32(np, "maxim,hibw", &priv->hibw))
+		priv->hibw = 0;
+	if (of_property_read_u32(np, "maxim,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "maxim,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "maxim,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 50;
+	if (of_property_read_u32(np, "maxim,dt", &priv->dt))
+		priv->dt = MIPI_DT_YUV8;
+	if (of_property_read_u64(np, "maxim,crossbar", &priv->crossbar))
+		priv->crossbar = crossbar;
+	if (of_property_read_string(np, "maxim,mbus", &priv->mbus))
+		priv->mbus = mbus_default;
+	for (i = 0; i < 11; i++) {
+		sprintf(name, "maxim,gpio%d", i);
+		if (of_property_read_u32(np, name, &priv->gpio[i]))
+			priv->gpio[i] = -1;
+	}
+
+	/* module params override dts */
+	if (gmsl != MODE_GMSL2)
+		priv->gmsl_mode = gmsl;
+	if (him)
+		priv->him = him;
+	if (fsync_period) {
+		priv->fsync_period = fsync_period;
+	//	priv->fsync_mode = fsync_mode_default;
+	}
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (gpio_resetb)
+		priv->gpio_resetb = gpio_resetb;
+	if (active_low_resetb)
+		priv->active_low_resetb = active_low_resetb;
+	if (timeout_n)
+		priv->timeout = timeout_n;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (bws)
+		priv->bws = bws;
+	if (!dbl)
+		priv->dbl = dbl;
+	if (dt != MIPI_DT_YUV8)
+		priv->dt = dt;
+	//if (hsgen)
+	//	priv->hsgen = hsgen;
+	if (gpio0 >= 0)
+		priv->gpio[0] = gpio0;
+	if (gpio1 >= 0)
+		priv->gpio[1] = gpio1;
+	if (gpio7 >= 0)
+		priv->gpio[7] = gpio7;
+	if (gpio8 >= 0)
+		priv->gpio[8] = gpio8;
+	if (strcmp(mbus, "dvp"))
+		priv->mbus = mbus;
+
+	/* parse serializer crossbar setup */
+	for (i = 0; i < 16; i++) {
+		priv->cb[i] = priv->crossbar % 16;
+		priv->crossbar /= 16;
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		priv->link[i]->out_mipi = 1;	/* CSI default forwarding is to MIPI1 */
+		priv->link[i]->out_vc = i;	/* Default VC map: 0 1 2 3 */
+	}
+
+	prop = of_find_property(np, "maxim,links-mipi-map", NULL);
+	if (prop) {
+		const __be32 *map = NULL;
+		u32 val;
+
+		for (i = 0; i < priv->n_links; i++) {
+			map = of_prop_next_u32(prop, map, &val);
+			if (!map)
+				break;
+			if (val >= MAX9296_MAX_MIPI)
+				return -EINVAL;
+			priv->link[i]->out_mipi = val;
+		}
+	}
+
+	if (of_property_read_u32(np, "csi-rate", &csi_rate))
+		csi_rate = 1200;
+
+	for (i = 0; i < priv->n_links; i++)
+		priv->csi_rate[priv->link[i]->out_mipi] = csi_rate;
+
+	prop = of_find_property(np, "maxim,links-vc-map", NULL);
+	if (prop) {
+		const __be32 *map = NULL;
+		u32 val;
+
+		for (i = 0; i < priv->n_links; i++) {
+			map = of_prop_next_u32(prop, map, &val);
+			if (!map)
+				break;
+			if (val >= 4)
+				return -EINVAL;
+			priv->link[i]->out_vc = val;
+		}
+	}
+
+	dev_dbg(&client->dev, "Link# | MIPI rate | Map | VC\n");
+	for (i = 0; i < priv->n_links; i++)
+		dev_dbg(&client->dev, "%5d | %9d | %3d | %2d\n", i, priv->csi_rate[i], priv->link[i]->out_mipi, priv->link[i]->out_vc);
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct max9296_link *link;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > MAX9296_MAX_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+			of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == MAX9296_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		link = priv->link[ep.port];
+		link->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!link->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		link->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		link->asd.match.fwnode = link->fwnode;
+		link->pad = ep.port;
+
+		priv->subdevs[ep.port] = &link->asd;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int max9296_probe(struct i2c_client *client,
+			  const struct i2c_device_id *did)
+{
+	struct max9296_priv *priv;
+	struct gpio_desc *pwdn_gpio;
+	int ret, i;
+	int val = 0;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* update client i2c addr for PnP case */
+	i = of_property_match_string(client->dev.of_node, "reg-names", "max9296");
+	if (i >= 0)
+		of_property_read_u32_index(client->dev.of_node, "reg", i, (unsigned int *)&client->addr);
+
+	priv->regmap = devm_regmap_init_i2c(client, &max9296_regmap[0]);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+
+	priv->ref_clk = v4l2_clk_get(&client->dev, "ref_clk");
+	if (!IS_ERR(priv->ref_clk)) {
+		dev_info(&client->dev, "ref_clk = %luKHz", v4l2_clk_get_rate(priv->ref_clk) / 1000);
+		v4l2_clk_enable(priv->ref_clk);
+	}
+
+	pwdn_gpio = devm_gpiod_get_optional(&client->dev, "shutdown", GPIOD_OUT_HIGH);
+	if (!IS_ERR(pwdn_gpio)) {
+		udelay(5);
+		gpiod_set_value_cansleep(pwdn_gpio, 0);
+		usleep_range(3000, 5000);
+	}
+
+	des_read(MAX9296_REG13, &val);
+	if (val != MAX9296A_ID)
+		return -ENODEV;
+
+	for (i = 0; i < MAX9296_MAX_LINKS; i++) {
+		priv->link[i] = devm_kzalloc(&client->dev, sizeof(*priv->link[i]), GFP_KERNEL);
+		if (!priv->link[i])
+			return -ENOMEM;
+	}
+
+	ret = max9296_parse_dt(client);
+	if (ret)
+		goto out;
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->link[i]->poc_reg = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->link[i]->poc_reg) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		priv->link[i]->client = i2c_new_dummy_device(client->adapter, priv->link[i]->ser_addr);
+		if (!priv->link[i]->client)
+			return -ENOMEM;
+
+		priv->link[i]->regmap = regmap_init_i2c(priv->link[i]->client, &max9296_regmap[priv->gmsl_mode]);
+		if (IS_ERR(priv->link[i]->regmap))
+			return PTR_ERR(priv->link[i]->regmap);
+	}
+
+	ret = max9296_i2c_mux_init(priv);
+	if (ret) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	ret = max9296_initialize(priv);
+	if (ret < 0)
+		goto out;
+
+	ret = max9296_v4l2_init(client);
+	if (ret < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+
+	priv->reboot_nb.notifier_call = max9296_reboot_notifier;
+	ret = register_reboot_notifier(&priv->reboot_nb);
+	if (ret) {
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+		goto out;
+	}
+
+	//max9296_debug_add(priv);
+out:
+	return ret;
+}
+
+static int max9296_remove(struct i2c_client *client)
+{
+	struct max9296_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	//max9296_debug_remove(priv);
+	i2c_mux_del_adapters(priv->mux);
+	unregister_reboot_notifier(&priv->reboot_nb);
+
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg))
+			regulator_disable(priv->link[i]->poc_reg); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id max9296_dt_ids[] = {
+	{ .compatible = "maxim,max9296" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9296_dt_ids);
+
+static const struct i2c_device_id max9296_id[] = {
+	{ "max9296", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max9296_id);
+
+static struct i2c_driver max9296_i2c_driver = {
+	.driver	= {
+		.name		= "max9296",
+		.of_match_table	= of_match_ptr(max9296_dt_ids),
+	},
+	.probe		= max9296_probe,
+	.remove		= max9296_remove,
+	.id_table	= max9296_id,
+};
+
+module_i2c_driver(max9296_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL2 driver for MAX9296");
+MODULE_AUTHOR("Andrey Gusakov, Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/gmsl/max9296.h b/drivers/media/i2c/gmsl/max9296.h
new file mode 100644
index 0000000..f6d9dac
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9296.h
@@ -0,0 +1,306 @@
+/*
+ * MAXIM max9296 GMSL2 driver header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define MAX9296_MAX_LINKS		2
+#define MAX9296_MAX_PIPES		4
+#define MAX9296_MAX_PIPE_MAPS		16
+#define MAX9296_MAX_MIPI		4
+
+enum max9296_pads {
+	MAX9296_SINK_LINK0,
+	MAX9296_SINK_LINK1,
+	MAX9296_SINK_LINK2,
+	MAX9296_SINK_LINK3,
+	MAX9296_SOURCE,
+	MAX9296_N_PADS,
+};
+
+struct max9296_link {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+	int			pad;
+
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	int			ser_id;
+	int			ser_addr;
+	int			pipes_mask;	/* mask of pipes used by this link */
+	int			out_mipi;	/* MIPI# */
+	int			out_vc;		/* VC# */
+	struct regulator	*poc_reg;	/* PoC power supply */
+};
+
+#define asd_to_max9296_link(_asd) \
+	container_of(_asd, struct max9296_link, asd)
+
+struct max9296_priv {
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[MAX9296_N_PADS];
+
+	struct i2c_mux_core	*mux;
+
+	int			n_links;
+	int			links_mask;
+	enum gmsl_mode		gmsl_mode;
+	struct max9296_link	*link[MAX9296_MAX_LINKS];
+	struct v4l2_async_subdev *subdevs[MAX9296_MAX_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			gpio_resetb;
+	int			active_low_resetb;
+	bool			pclk_rising_edge;
+	bool			is_coax;
+	int			him;
+	int			bws;
+	int			dbl;
+	int			hibw;
+	int			hven;
+	int			hsync;
+	int			vsync;
+	int			dt;
+	u64			crossbar;
+	char			cb[16];
+	const char		*mbus;
+	int			gpio[11];
+	int			timeout;
+	int			poc_delay;
+	struct v4l2_clk		*ref_clk;
+	int			lanes;
+	int			csi_rate[MAX9296_MAX_MIPI];
+	int			fsync_period;
+	atomic_t		use_count;
+	struct notifier_block	reboot_nb;
+};
+
+#define MAX9296_REG1			0x01
+#define MAX9296_REG2			0x02
+#define MAX9296_REG3			0x03
+#define MAX9296_REG4			0x04
+#define MAX9296_REG5			0x05
+#define MAX9296_REG6			0x06
+#define MAX9296_REG13			0x0d
+#define MAX9296_REG14			0x0e
+#define MAX9296_REG26			0x26
+
+#define MAX9296_INTR3			0x1b
+#define MAX9296_INTR5			0x1d
+#define MAX9296_INTR7			0x1f
+#define MAX9296_DEC_ERR_A		0x22
+#define MAX9296_DEC_ERR_B		0x23
+#define MAX9296_IDLE_ERR		0x24
+#define MAX9296_PKT_CNT			0x25
+#define MAX9296_RX_0			0x2c
+#define MAX9296_RX_3			0x2f
+
+#define MAX9296_CTRL0			0x17
+#define MAX9296_CTRL1			0x18
+#define MAX9296_CTRL2			0x19
+#define MAX9296_CTRL3			0x1a
+#define MAX9296_CTRL11			0x22
+#define MAX9296_CTRL12			0x0a
+#define MAX9296_CTRL13			0x0b
+#define MAX9296_CTRL14			0x0c
+
+#define MAX9296_CNT(n)			(0x22 + n)
+
+#define MAX9296_I2C_PT_0		0x4c
+#define MAX9296_I2C_PT_1		0x4d
+
+#define MAX9296_CNT4			0x55c
+
+#define MAX9296_GMSL1_EN		0xf00
+#define MAX9296_COMMON1			0xf02
+#define MAX9296_I2C_0			0xf05
+#define MAX9296_I2C_1			0xf06
+#define MAX9296_I2C_2			0xf07
+#define MAX9296_I2C_3			0xf08
+#define MAX9296_I2C_4			0xf09
+#define MAX9296_I2C_5			0xf0a
+
+#define MAX9296_RX0(n)			(0x50 + n)
+
+#define MAX_VIDEO_RX_BASE(n)		(n < 5 ? (0x100 + (0x12 * n)) : \
+						 (0x160 + (0x12 * (n - 5))))
+#define MAX_VIDEO_RX0(n)		(MAX_VIDEO_RX_BASE(n) + 0x00)
+#define MAX_VIDEO_RX3(n)		(MAX_VIDEO_RX_BASE(n) + 0x03)
+#define MAX_VIDEO_RX8(n)		(MAX_VIDEO_RX_BASE(n) + 0x08)
+#define MAX_VIDEO_RX10(n)		(MAX_VIDEO_RX_BASE(n) + 0x0a)
+
+#define MAX_VPRBS(n)			(0x1dc + (0x20 * n))
+
+#define MAX_CROSS_BASE(n)		(0x1c0 + (0x20 * n))
+#define MAX_CROSS(n, m)			(MAX_CROSS_BASE(n) + m)
+
+#define MAX_BACKTOP_BASE(bank)		(0x400 + (0x20 * bank))
+#define MAX_BACKTOP1(bank)		(MAX_BACKTOP_BASE(bank) + 0x00)
+#define MAX_BACKTOP11(bank)		(MAX_BACKTOP_BASE(bank) + 0x0a)
+#define MAX_BACKTOP12(bank)		(MAX_BACKTOP_BASE(bank) + 0x0b)
+#define MAX_BACKTOP13(bank)		(MAX_BACKTOP_BASE(bank) + 0x0c)
+#define MAX_BACKTOP14(bank)		(MAX_BACKTOP_BASE(bank) + 0x0d)
+#define MAX_BACKTOP15(bank)		(MAX_BACKTOP_BASE(bank) + 0x0e)
+#define MAX_BACKTOP16(bank)		(MAX_BACKTOP_BASE(bank) + 0x0f)
+#define MAX_BACKTOP17(bank)		(MAX_BACKTOP_BASE(bank) + 0x10)
+#define MAX_BACKTOP18(bank)		(MAX_BACKTOP_BASE(bank) + 0x11)
+#define MAX_BACKTOP19(bank)		(MAX_BACKTOP_BASE(bank) + 0x12)
+#define MAX_BACKTOP20(bank)		(MAX_BACKTOP_BASE(bank) + 0x13)
+#define MAX_BACKTOP21(bank)		(MAX_BACKTOP_BASE(bank) + 0x14)
+#define MAX_BACKTOP22(bank)		(MAX_BACKTOP_BASE(bank) + 0x15)
+#define MAX_BACKTOP23(bank)		(MAX_BACKTOP_BASE(bank) + 0x16)
+#define MAX_BACKTOP24(bank)		(MAX_BACKTOP_BASE(bank) + 0x17)
+#define MAX_BACKTOP25(bank)		(MAX_BACKTOP_BASE(bank) + 0x18)
+#define MAX_BACKTOP26(bank)		(MAX_BACKTOP_BASE(bank) + 0x19)
+#define MAX_BACKTOP27(bank)		(MAX_BACKTOP_BASE(bank) + 0x1a)
+#define MAX_BACKTOP28(bank)		(MAX_BACKTOP_BASE(bank) + 0x1b)
+#define MAX_BACKTOP29(bank)		(MAX_BACKTOP_BASE(bank) + 0x1c)
+#define MAX_BACKTOP30(bank)		(MAX_BACKTOP_BASE(bank) + 0x1d)
+#define MAX_BACKTOP31(bank)		(MAX_BACKTOP_BASE(bank) + 0x1e)
+#define MAX_BACKTOP32(bank)		(MAX_BACKTOP_BASE(bank) + 0x1f)
+
+#define MAX9296_FSYNC_0			0x3a0
+#define MAX9296_FSYNC_5			0x3a5
+#define MAX9296_FSYNC_6			0x3a6
+#define MAX9296_FSYNC_7			0x3a7
+#define MAX9296_FSYNC_8			0x3a8
+#define MAX9296_FSYNC_9			0x3a9
+#define MAX9296_FSYNC_10		0x3aa
+#define MAX9296_FSYNC_11		0x3ab
+#define MAX9296_FSYNC_15		0x3af
+#define MAX9296_FSYNC_17		0x3b1
+
+#define MAX_MIPI_PHY_BASE		0x8a0
+#define MAX_MIPI_PHY0			(MAX_MIPI_PHY_BASE + 0x00)
+#define MAX_MIPI_PHY2			(MAX_MIPI_PHY_BASE + 0x02)
+#define MAX_MIPI_PHY3			(MAX_MIPI_PHY_BASE + 0x03)
+#define MAX_MIPI_PHY4			(MAX_MIPI_PHY_BASE + 0x04)
+#define MAX_MIPI_PHY5			(MAX_MIPI_PHY_BASE + 0x05)
+#define MAX_MIPI_PHY6			(MAX_MIPI_PHY_BASE + 0x06)
+#define MAX_MIPI_PHY8			(MAX_MIPI_PHY_BASE + 0x08)
+#define MAX_MIPI_PHY9			(MAX_MIPI_PHY_BASE + 0x09)
+#define MAX_MIPI_PHY10			(MAX_MIPI_PHY_BASE + 0x0a)
+#define MAX_MIPI_PHY11			(MAX_MIPI_PHY_BASE + 0x0b)
+#define MAX_MIPI_PHY13			(MAX_MIPI_PHY_BASE + 0x0d)
+#define MAX_MIPI_PHY14			(MAX_MIPI_PHY_BASE + 0x0e)
+
+#define MAX_MIPI_TX_BASE(n)		(0x900 + 0x40 * n)
+#define MAX_MIPI_TX2(n)			(MAX_MIPI_TX_BASE(n) + 0x02)
+#define MAX_MIPI_TX10(n)		(MAX_MIPI_TX_BASE(n) + 0x0a)
+#define MAX_MIPI_TX11(n)		(MAX_MIPI_TX_BASE(n) + 0x0b)
+#define MAX_MIPI_TX12(n)		(MAX_MIPI_TX_BASE(n) + 0x0c)
+
+/* 16 pairs of source-dest registers */
+#define MAX_MIPI_MAP_SRC(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x0d + (2 * n))
+#define MAX_MIPI_MAP_DST(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x0e + (2 * n))
+/* Phy dst. Each reg contains 4 dest */
+#define MAX_MIPI_MAP_DST_PHY(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x2d + n)
+
+#define MAX_GMSL1_2(ch)			(0xb02 + (0x100 * ch))
+#define MAX_GMSL1_4(ch)			(0xb04 + (0x100 * ch))
+#define MAX_GMSL1_6(ch)			(0xb06 + (0x100 * ch))
+#define MAX_GMSL1_7(ch)			(0xb07 + (0x100 * ch))
+#define MAX_GMSL1_8(ch)			(0xb08 + (0x100 * ch))
+#define MAX_GMSL1_D(ch)			(0xb0d + (0x100 * ch))
+#define MAX_GMSL1_F(ch)			(0xb0f + (0x100 * ch))
+#define MAX_GMSL1_19(ch)		(0xb19 + (0x100 * ch))
+#define MAX_GMSL1_1B(ch)		(0xb1b + (0x100 * ch))
+#define MAX_GMSL1_1D(ch)		(0xb1d + (0x100 * ch))
+#define MAX_GMSL1_20(ch)		(0xb20 + (0x100 * ch))
+#define MAX_GMSL1_96(ch)		(0xb96 + (0x100 * ch))
+#define MAX_GMSL1_CA(ch)		(0xbca + (0x100 * ch))
+#define MAX_GMSL1_CB(ch)		(0xbcb + (0x100 * ch))
+
+#define MAX_RLMS4(ch)			(0x1404 + (0x100 * ch))
+#define MAX_RLMSA(ch)			(0x140A + (0x100 * ch))
+#define MAX_RLMSB(ch)			(0x140B + (0x100 * ch))
+#define MAX_RLMSA4(ch)			(0x14a4 + (0x100 * ch))
+
+#define MAX_RLMS58(ch)			(0x1458 + (0x100 * ch))
+#define MAX_RLMS59(ch)			(0x1459 + (0x100 * ch))
+#define MAX_RLMS95(ch)			(0x1495 + (0x100 * ch))
+#define MAX_RLMSC4(ch)			(0x14c4 + (0x100 * ch))
+#define MAX_RLMSC5(ch)			(0x14c5 + (0x100 * ch))
+
+static inline int max9296_write(struct max9296_priv *priv, int reg, int val)
+{
+	int ret;
+
+	ret = regmap_write(priv->regmap, reg, val);
+	if (ret)
+		dev_dbg(&priv->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max9296_read(struct max9296_priv *priv, int reg, int *val)
+{
+	int ret;
+
+	ret = regmap_read(priv->regmap, reg, val);
+	if (ret)
+		dev_dbg(&priv->client->dev, "read register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max9296_update_bits(struct max9296_priv *priv, int reg, int mask, int bits)
+{
+	int ret;
+
+	ret = regmap_update_bits(priv->regmap, reg, mask, bits);
+	if (ret)
+		dev_dbg(&priv->client->dev, "update register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+#define des_read(reg, val)			max9296_read(priv, reg, val)
+#define des_write(reg, val)			max9296_write(priv, reg, val)
+#define des_update_bits(reg, mask, bits)	max9296_update_bits(priv, reg, mask, bits)
+
+static inline int max9296_ser_write(struct max9296_link *link, int reg, int val)
+{
+	int ret;
+
+	ret = regmap_write(link->regmap, reg, val);
+	if (ret < 0)
+		dev_dbg(&link->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max9296_ser_read(struct max9296_link *link, int reg, int *val)
+{
+	int ret;
+
+	ret = regmap_read(link->regmap, reg, val);
+	if (ret)
+		dev_dbg(&link->client->dev, "read register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max9296_ser_update_bits(struct max9296_link *link, int reg, int mask, int bits)
+{
+	int ret;
+
+	ret = regmap_update_bits(link->regmap, reg, mask, bits);
+	if (ret)
+		dev_dbg(&link->client->dev, "update register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+#define ser_read(reg, val)			max9296_ser_read(link, reg, (int *)val)
+#define ser_write(reg, val)			max9296_ser_write(link, reg, val)
+#define ser_update_bits(reg, mask, bits)	max9296_ser_update_bits(link, reg, mask, bits)
diff --git a/drivers/media/i2c/gmsl/max9296_debug.h b/drivers/media/i2c/gmsl/max9296_debug.h
new file mode 100644
index 0000000..6bf03a2
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max9296_debug.h
@@ -0,0 +1,462 @@
+/*
+ * MAXIM max9296 GMSL2 driver debug stuff
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+static char *max9296_link_mode[4] = {
+	"Splitter mode",
+	"Link A",
+	"Link B",
+	"Dual link",
+};
+
+static char *line_status[8] = {
+	"Short to battery",
+	"Short to GND",
+	"Normal operation",
+	"Line open",
+	"Line-to-line short",
+	"Line-to-line short",
+	"Line-to-line short",
+	"Line-to-line short"
+};
+
+static char *paxket_cnt_types[] = {
+	"None",
+	"VIDEO",
+	"AUDIO",
+	"INFO Frame",
+	"SPI",
+	"I2C",
+	"UART",
+	"GPIO",
+	"AHDCP",
+	"RGMII",
+	"Reserved",
+	"Reserved",
+	"Reserved",
+	"Reserved",
+	"All",
+	"Unknown and packets with error",
+};
+
+static int max9296_gmsl1_get_link_lock(struct max9296_priv *priv, int link_n);
+static int max9296_gmsl2_get_link_lock(struct max9296_priv *priv, int link_n);
+
+#define reg_bits(x, y)	((reg >> (x)) & ((1 << (y)) - 1))
+
+static ssize_t max_link_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9296_priv *priv = i2c_get_clientdata(client);
+	int i = -1;
+	int j;
+	int gmsl2;
+	u32 crc = 0 ;
+	char *_buf = buf;
+	int reg = 0;
+
+	if (!sscanf(attr->attr.name, "link_%d", &i))
+                return -EINVAL;
+
+	if (i < 0)
+		return -EINVAL;
+
+	if (i >= priv->n_links) {
+		buf += sprintf(buf, "\n");
+		return (buf - _buf);
+	}
+
+	buf += sprintf(buf, "Link %c status\n", 'A' + i);
+
+	des_read(MAX9296_REG6, &reg);
+	gmsl2 = !!(reg & BIT(6 + i));
+	buf += sprintf(buf, "Link mode: %s\n", gmsl2 ? "GMSL2" : "GMSL1");
+
+	if (gmsl2) {
+		buf += sprintf(buf, "GMSL2 Link lock: %d\n",
+				max9296_gmsl2_get_link_lock(priv, i));
+	} else {
+		reg = max9296_gmsl1_get_link_lock(priv, i);
+		buf += sprintf(buf,
+				"GMSL1_CB: 0x%02x:\t"
+				"LOCKED_G1: %d\n",
+				reg, reg_bits(0, 1));
+
+		des_read(MAX_GMSL1_CA(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_CA: 0x%02x:\t"
+				"PHASELOCK: %d, WBLOCK_G1: %d, DATAOK: %d\n",
+				reg, reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+
+		des_read(MAX_GMSL1_1B(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_1B: 0x%02x:\t"
+				"LINE_CRC_ERR: %d ",
+				reg, reg_bits(2, 1));
+		for (j = 0; j < 4; j++) {
+			des_read(MAX_GMSL1_20(i) + j, &reg);
+			crc = crc | ((reg & 0xff) << (j * 8));
+		}
+		buf += sprintf(buf, "last crc 0x%08x\n", crc);
+
+		des_read(MAX_GMSL1_19(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_19: CC_CRC_ERRCNT %d\n",
+				reg);
+
+		des_read(MAX_GMSL1_1D(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_1D: 0x%02x:\t"
+				"UNDERBOOST: %d, AEQ-BST: %d\n",
+				reg, reg_bits(4, 1), reg_bits(0, 4));
+
+		{
+			des_read(MAX9296_CTRL1, &reg);
+			buf += sprintf(buf,
+					"CTRL1: 0x%02x:\t"
+					"Cable: %s\n",
+					reg,
+					reg_bits(i * 2, 1) ? "coax" : "stp");
+
+			des_read(MAX9296_REG26, &reg);
+			buf += sprintf(buf,
+					"REG26: 0x%02x:\t"
+					"Line status: %s\n",
+					reg,
+					line_status[reg_bits(i * 4, 3)]);
+
+			des_read(MAX9296_CNT(i), &reg);
+			buf += sprintf(buf,
+					"CNT%d: DEC_ERR_x: %d\n",
+					i, reg);
+		}
+		/* TODO: add same for 96712 */
+	}
+
+	return (buf - _buf);
+}
+
+static ssize_t max_pipe_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9296_priv *priv = i2c_get_clientdata(client);
+	char *_buf = buf;
+	int pipe = 0;
+	int map;
+	int maps_en = 0;
+	int pipes_en;
+	int reg = 0;
+
+	if (!sscanf(attr->attr.name, "pipe_%d", &pipe))
+                return -EINVAL;
+
+	if (pipe < 0)
+		return -EINVAL;
+
+	if (pipe >= MAX9296_MAX_PIPES) {
+		buf += sprintf(buf, "\n");
+		return (buf - _buf);
+	}
+
+	des_read(MAX9296_REG2, &pipes_en);
+	pipes_en = pipes_en >> 4;
+
+	buf += sprintf(buf, "Video Pipe %d %s\n",
+		pipe, (pipes_en & BIT(pipe)) ? "ENABLED" : "disabled");
+	if (!(pipes_en & BIT(pipe)))
+		goto out;
+
+	des_read(MAX_VPRBS(pipe), &reg);
+	/* bit 5 is not valid for MAX96712 */
+	buf += sprintf(buf,
+			"\tVPRBS: 0x%02x\t"
+			"VPRBS_FAIL: %d,"
+			"VIDEO_LOCK: %d\n",
+			reg,
+			reg_bits(5, 1), reg_bits(0, 1));
+
+	/* show source */
+	/* TODO */
+
+	/* show maps */
+	des_read(MAX_MIPI_TX11(pipe), &maps_en);
+	des_read(MAX_MIPI_TX12(pipe), &reg);
+	maps_en |= reg << 8;
+
+	for (map = 0; map < MAX9296_MAX_PIPE_MAPS; map++) {
+		int src, dst, mipi;
+		if (!(maps_en & BIT(map)))
+			continue;
+
+		des_read(MAX_MIPI_MAP_SRC(pipe, map), &src);
+		des_read(MAX_MIPI_MAP_DST(pipe, map), &dst);
+		des_read(MAX_MIPI_MAP_DST_PHY(pipe, map / 4), &mipi);
+
+		buf += sprintf(buf, " MAP%d: DT %02x, VC %d -> DT %02x, VC %d MIPI %d\n",
+			map,
+			src & 0x3f, (src >> 6) & 0x03, dst & 0x3f, (dst >> 6) & 0x03,
+			(mipi >> ((map % 4) * 2)) & 0x03);
+	}
+
+	des_read(MAX9296_CNT4 + pipe, &reg);
+	buf += sprintf(buf, "VID_PXL_CRC_ERR: 0x%02x\n", reg);
+
+	des_read(MAX_VIDEO_RX0(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX0: 0x%02x\t"
+			"LCRC_ERR: %d, "
+			"LINE_CRC_SEL: %d, "
+			"LINE_CRC_EN: %d, "
+			"DIS_PKT_DET: %d\n",
+			reg,
+			reg_bits(7, 1),
+			reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+	des_read(MAX_VIDEO_RX3(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX3: 0x%02x\t"
+			"HD_TR_MODE: %d, "
+			"DLOCKED: %d, "
+			"VLOCKED: %d, "
+			"HLOCKED: %d, "
+			"DTRACKEN: %d, "
+			"VTRACKEN: %d, "
+			"HTRACKEN: %d\n",
+			reg,
+			reg_bits(6, 1),
+			reg_bits(5, 1), reg_bits(4, 1), reg_bits(3, 1),
+			reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+	des_read(MAX_VIDEO_RX8(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX8: 0x%02x\t"
+			"VID_BLK_LEN_ERR: %d, "
+			"VID_LOCK: %d, "
+			"VID_PKT_DET: %d, "
+			"VID_SEQ_ERR: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1),
+			reg_bits(5, 1), reg_bits(4, 1));
+	des_read(MAX_VIDEO_RX10(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX10: 0x%02x\t"
+			"MASK_VIDEO_DE: %d\n",
+			reg,
+			reg_bits(6, 1));
+
+out:
+	return (buf - _buf);
+}
+
+static ssize_t max_stat_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max9296_priv *priv = i2c_get_clientdata(client);
+	int i;
+	char *_buf = buf;
+	int reg = 0, reg2 = 0;
+
+	des_read(MAX9296_REG3, &reg);
+	buf += sprintf(buf,
+			"REG_REG3: 0x%02x\t"
+			"LOCK_CFG: %d\n",
+			reg, reg_bits(7, 1));
+
+	des_read(MAX9296_CTRL0, &reg);
+	buf += sprintf(buf,
+			"CTRL0: 0x%02x\n",
+			reg);
+
+	des_read(MAX9296_CTRL3, &reg);
+	buf += sprintf(buf,
+			"CTRL3: 0x%02x:\t"
+				"LINK_MODE: %s, "
+			"GMSL2 LOCKED: %d, ERROR: %d, "
+			"CMU_LOCKED: %d\n",
+			reg,
+			max9296_link_mode[reg_bits(4, 2)],
+			reg_bits(3, 1), reg_bits(2 ,1),
+			reg_bits(1, 1));
+	/* get errors */
+	if (reg_bits(2, 1)) {
+		des_read(MAX9296_INTR3, &reg);
+		buf += sprintf(buf,
+			"INTR3: 0x%02x:\t"
+			"PHY_INT_OEN_B: %d "
+			"PHY_INT_OEN_A: %d "
+			"REM_ERR_FLAG: %d "
+			"MEM_INT_ERR_FLAG: %d "
+			"LFLT_INT: %d "
+			"IDLE_ERR_FLAG: %d "
+			"DEC_ERR_FLAG_B: %d "
+			"DEC_ERR_FLAG_A: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1),
+			reg_bits(3, 1), reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+		des_read(MAX9296_INTR5, &reg);
+		buf += sprintf(buf,
+			"INTR5: 0x%02x:\t"
+			"EOM_ERR_FLAG_B: %d "
+			"EOM_ERR_FLAG_A: %d "
+			"MAX_RT_FLAG: %d "
+			"RT_CNT_FLAG: %d "
+			"PKT_CNT_FLAG: %d "
+			"WM_ERR_FLAG: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1),
+			reg_bits(3, 1), reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+		des_read(MAX9296_INTR7, &reg);
+		buf += sprintf(buf,
+				"INTR7: 0x%02x:\t"
+				"VDDCMP_INT_FLAG: %d "
+				"PORZ_INT_FLAG: %d "
+				"VDDBAD_INT_FLAG: %d "
+				"LCRC_ERR_FLAG: %d "
+				"VPRBS_ERR_FLAG: %d "
+				"VID_PXL_CRC_ERR: %d\n",
+				reg,
+				reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1),
+				reg_bits(3, 1), reg_bits(2, 1), reg_bits(0, 1));
+
+			des_read(MAX9296_DEC_ERR_A, &reg);
+			buf += sprintf(buf,
+					"ERR_A: 0x%02x\n", reg);
+			des_read(MAX9296_DEC_ERR_B, &reg);
+			buf += sprintf(buf,
+					"ERR_B: 0x%02x\n", reg);
+			des_read(MAX9296_IDLE_ERR, &reg);
+			buf += sprintf(buf,
+					"IDLE_ERR: 0x%02x\n", reg);
+			des_read(MAX9296_PKT_CNT, &reg);
+			buf += sprintf(buf,
+					"PKT_CNT: 0x%02x\n", reg);
+
+		}
+
+		des_read(MAX9296_CNT(2), &reg);
+		buf += sprintf(buf,
+				"CNT2: IDLE_ERR: %d\n",
+				reg);
+
+		des_read(MAX9296_CNT(3), &reg);
+		des_read(MAX9296_RX_0, &reg2);
+		buf += sprintf(buf,
+				"CNT3: PKT_CNT: 0x%02x (type %x: %s)\n",
+				reg, reg2 & 0x0f,
+				paxket_cnt_types[reg2 & 0x0f]);
+
+		des_read(MAX9296_RX_3, &reg);
+		buf += sprintf(buf,
+				"RX3: 0x%02x:\t"
+				"PRBS_SYNCED_B: %d, "
+				"SYNC_LOCKED_B: %d, "
+				"WBLOCK_B: %d, "
+				"FAILLOCK_B: %d, "
+				"PRBS_SYNCED_A: %d, "
+				"SYNC_LOCKED_A: %d, "
+				"WBLOCK_A: %d, "
+				"FAILLOCK_A: %d\n",
+				reg,
+				reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1),
+				reg_bits(3, 1), reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+
+		des_read(MAX_BACKTOP1(0), &reg);
+		buf += sprintf(buf,
+				"BACKTOP1: 0x%02x:\t"
+				"CSIPLLU_LOCK: %d, "
+				"CSIPLLZ_LOCK: %d, "
+				"CSIPLLY_LOCK: %d, "
+				"CSIPLLX_LOCK: %d, "
+				"LINE_SPL2: %d, "
+				"LINE_SPL1: %d\n",
+				reg,
+				reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1),
+				reg_bits(3, 1), reg_bits(2, 1));
+
+		des_read(MAX_BACKTOP11(0), &reg);
+		buf += sprintf(buf,
+				"BACKTOP11: 0x%02x:\t"
+				"CMD_OWERFLOW4: %d, "
+				"CMD_OWERFLOW3: %d, "
+				"CMD_OWERFLOW2: %d, "
+				"CMD_OWERFLOW1: %d, "
+				"LMO_Z: %d, "
+				"LMO_Y: %d\n",
+				reg,
+				reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1),
+				reg_bits(2, 1), reg_bits(1, 1));
+
+	for (i = 0; i < MAX9296_MAX_MIPI; i++) {
+		buf += sprintf(buf, "MIPI %d\n", i);
+		des_read(MAX_MIPI_TX2(i), &reg);
+		buf += sprintf(buf,
+				"\tMIPI_TX2: 0x%02x\n",
+				reg);
+	}
+
+	return (buf - _buf);
+}
+
+static DEVICE_ATTR(link_0, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_1, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_2, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_3, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(pipe_0, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_1, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_2, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_3, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_4, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_5, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_6, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_7, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(stat, S_IRUGO, max_stat_show, NULL);
+
+static struct attribute *max9296_attributes[] = {
+	&dev_attr_link_0.attr,
+	&dev_attr_link_1.attr,
+	&dev_attr_link_2.attr,
+	&dev_attr_link_3.attr,
+	&dev_attr_pipe_0.attr,
+	&dev_attr_pipe_1.attr,
+	&dev_attr_pipe_2.attr,
+	&dev_attr_pipe_3.attr,
+	&dev_attr_pipe_4.attr,
+	&dev_attr_pipe_5.attr,
+	&dev_attr_pipe_6.attr,
+	&dev_attr_pipe_7.attr,
+	&dev_attr_stat.attr,
+	NULL
+};
+
+static const struct attribute_group max9296_group = {
+	.attrs = max9296_attributes,
+};
+
+int max9296_debug_add(struct max9296_priv *priv)
+{
+	int ret;
+
+	ret = sysfs_create_group(&priv->client->dev.kobj, &max9296_group);
+	if (ret < 0) {
+		dev_err(&priv->client->dev, "Sysfs registration failed\n");
+		return ret;
+	}
+
+	/* count video packets */
+	des_update_bits(MAX9296_RX_0, 0x0f, 0x01);
+
+	return ret;
+}
+
+void max9296_debug_remove(struct max9296_priv *priv)
+{
+	sysfs_remove_group(&priv->client->dev.kobj, &max9296_group);
+}
diff --git a/drivers/media/i2c/gmsl/max96712.c b/drivers/media/i2c/gmsl/max96712.c
new file mode 100644
index 0000000..6efaba8
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max96712.c
@@ -0,0 +1,1604 @@
+/*
+ * MAXIM max96712 GMSL2 driver
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+#include <linux/of_gpio.h>
+#include <linux/of_graph.h>
+#include <linux/reboot.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-clk.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "common.h"
+#include "max96712.h"
+#include "max96712_debug.h"
+
+static char mbus_default[10] = "dvp"; /* mipi, dvp */
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int poc_trig;
+module_param(poc_trig, int, 0644);
+MODULE_PARM_DESC(poc_trig, " Use PoC triggering during RC setup. Useful on systems with dedicated PoC and unstable ser-des lock");
+
+static int him;
+module_param(him, int, 0644);
+MODULE_PARM_DESC(him, " Use High-Immunity mode (default: leagacy mode)");
+
+static int fsync_period;
+module_param(fsync_period, int, 0644);
+MODULE_PARM_DESC(fsync_period, " Frame sync period (default: 3.2MHz)");
+
+static int hsync;
+module_param(hsync, int, 0644);
+MODULE_PARM_DESC(hsync, " HSYNC invertion (default: 0 - not inverted)");
+
+static int vsync = 1;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 1 - inverted)");
+
+static int gpio_resetb;
+module_param(gpio_resetb, int, 0644);
+MODULE_PARM_DESC(gpio_resetb, " Serializer GPIO reset (default: 0 - not used)");
+
+static int active_low_resetb;
+module_param(active_low_resetb, int, 0644);
+MODULE_PARM_DESC(active_low_resetb, " Serializer GPIO reset level (default: 0 - active high)");
+
+static int timeout_n = 100;
+module_param(timeout_n, int, 0644);
+MODULE_PARM_DESC(timeout_n, " Timeout of link detection (default: 100 retries)");
+
+static int poc_delay = 50;
+module_param(poc_delay, int, 0644);
+MODULE_PARM_DESC(poc_delay, " Delay in ms after POC enable (default: 50 ms)");
+
+static int bws;
+module_param(bws, int, 0644);
+MODULE_PARM_DESC(bws, " BWS mode (default: 0 - 24-bit gmsl packets)");
+
+static int dbl = 1;
+module_param(dbl, int, 0644);
+MODULE_PARM_DESC(dbl, " DBL mode (default: 1 - DBL mode enabled)");
+
+static int dt = MIPI_DT_YUV8;
+module_param(dt, int, 0644);
+MODULE_PARM_DESC(dt, " DataType (default: 0x1e - YUV8)");
+
+static unsigned long crossbar = 0xba9876543210;
+module_param(crossbar, ulong, 0644);
+MODULE_PARM_DESC(crossbar, " Serializer crossbar setup (default: ba9876543210 - reversed)");
+
+static int gmsl = MODE_GMSL2;
+module_param(gmsl, int, 0644);
+MODULE_PARM_DESC(gmsl, " GMSL mode (default: 2 - GMSL2)");
+
+static char *mbus = mbus_default;
+module_param(mbus, charp, 0644);
+MODULE_PARM_DESC(mbus, " Interfaces mipi,dvp (default: dvp)");
+
+static int gpio0 = -1, gpio1 = -1, gpio7 = -1, gpio8 = -1;
+module_param(gpio0, int, 0644);
+MODULE_PARM_DESC(gpio0, "  GPIO0 function select (default: GPIO0 tri-state)");
+module_param(gpio1, int, 0644);
+MODULE_PARM_DESC(gpio1, "  GPIO1 function select (default: GPIO1 tri-state)");
+module_param(gpio7, int, 0644);
+MODULE_PARM_DESC(gpio7, "  GPIO7 function select (default: GPIO7 tri-state)");
+module_param(gpio8, int, 0644);
+MODULE_PARM_DESC(gpio8, "  GPIO8 function select (default: GPIO8 tri-state)");
+
+static const struct regmap_config max96712_regmap[] = {
+	{
+		/* max96712 */
+		.reg_bits = 16,
+		.val_bits = 8,
+		.max_register = 0x1f03,
+	}, {
+		/* max9271/max96705 */
+		.reg_bits = 8,
+		.val_bits = 8,
+		.max_register = 0xff,
+	}, {
+		/* max9695 */
+		.reg_bits = 16,
+		.val_bits = 8,
+		.max_register = 0x1b03,
+	}
+};
+
+static void max96712_write_remote_verify(struct max96712_priv *priv, int link_n, u8 reg, int val)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int timeout;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		u8 val2 = 0;
+
+		ser_write(reg, val);
+		ser_read(reg, &val2);
+		if (val2 == val)
+			break;
+
+		usleep_range(1000, 1500);
+	}
+
+	if (timeout >= 10)
+		dev_err(&priv->client->dev, "timeout remote write acked\n");
+}
+
+static void max96712_reset_oneshot(struct max96712_priv *priv, int mask)
+{
+	int timeout;
+	int reg = 0;
+
+	mask &= 0x0f;
+	des_update_bits(MAX96712_CTRL1, mask, mask); /* set reset one-shot */
+
+	/* wait for one-shot bit self-cleared */
+	for (timeout = 0; timeout < 100; timeout++) {
+		des_read(MAX96712_CTRL1, &reg);
+		if (!(reg & mask))
+			break;
+
+		mdelay(1);
+	}
+
+	if (reg & mask)
+		dev_err(&priv->client->dev, "Failed reset oneshot 0x%x\n", mask);
+}
+
+/* -----------------------------------------------------------------------------
+ * MIPI, mapping, routing
+ */
+
+static void max96712_pipe_override(struct max96712_priv *priv, unsigned int pipe,
+				   unsigned int dt, unsigned int vc)
+{
+	int bpp, bank;
+
+	bpp = mipi_dt_to_bpp(dt);
+	bank = pipe / 4;
+	pipe %= 4;
+
+	if (priv->dbl == 1) {
+		/* DBL=1 is MUX mode, DBL=0 is Normal mode */
+		des_update_bits(MAX_BACKTOP27(bank), BIT(pipe + 4), BIT(pipe + 4));	/* enable MUX mode */
+		bpp = bpp / 2;								/* divide because of MUX=1 */
+	}
+
+	switch (pipe) {
+	case 0:
+		/* Pipe X: 0 or 4 */
+		des_update_bits(MAX_BACKTOP12(bank), 0x1f << 3, bpp << 3);
+		des_update_bits(MAX_BACKTOP13(bank), 0x0f, vc);
+		des_update_bits(MAX_BACKTOP15(bank), 0x3f, dt);
+		des_update_bits(bank ? MAX_BACKTOP28(0) : MAX_BACKTOP22(0), BIT(6), BIT(6)); /* enalbe s/w override */
+		break;
+	case 1:
+		/* Pipe Y: 1 or 5 */
+		des_update_bits(MAX_BACKTOP18(bank), 0x1f, bpp);
+		des_update_bits(MAX_BACKTOP13(bank), 0x0f << 4, vc << 4);
+		des_update_bits(MAX_BACKTOP16(bank), 0x0f, dt & 0x0f);
+		des_update_bits(MAX_BACKTOP15(bank), 0x03 << 6, (dt & 0x30) << 2);
+		des_update_bits(bank ? MAX_BACKTOP28(0) : MAX_BACKTOP22(0), BIT(7), BIT(7)); /* enable s/w override */
+		break;
+	case 2:
+		/* Pipe Z: 2 or 6 */
+		des_update_bits(MAX_BACKTOP19(bank), 0x03, bpp & 0x03);
+		des_update_bits(MAX_BACKTOP18(bank), 0xe0, (bpp & 0x1c) << 3);
+		des_update_bits(MAX_BACKTOP14(bank), 0x0f, vc);
+		des_update_bits(MAX_BACKTOP17(bank), 0x03, dt & 0x03);
+		des_update_bits(MAX_BACKTOP16(bank), 0x0f << 4, (dt & 0x3c) << 2);
+		des_update_bits(bank ? MAX_BACKTOP30(0) : MAX_BACKTOP25(0), BIT(6), BIT(6)); /* enable s/w override */
+		break;
+	case 3:
+		/* Pipe U: 3 or 7 */
+		des_update_bits(MAX_BACKTOP19(bank), 0xfc, bpp << 2);
+		des_update_bits(MAX_BACKTOP14(bank), 0x0f << 4, vc << 4);
+		des_update_bits(MAX_BACKTOP17(bank), 0x3f << 2, dt << 2);
+		des_update_bits(bank ? MAX_BACKTOP30(0) : MAX_BACKTOP25(0), BIT(7), BIT(7)); /* enable s/w override */
+		break;
+	}
+}
+
+static void max96712_set_pipe_to_mipi_mapping(struct max96712_priv *priv,
+					      unsigned int pipe, unsigned int map_n,
+					      unsigned int in_dt, unsigned int in_vc,
+					      unsigned int out_dt, unsigned int out_vc, unsigned int out_mipi)
+{
+	int offset = 2 * (map_n % 4);
+
+	des_write(MAX_MIPI_MAP_SRC(pipe, map_n), (in_vc << 6) | in_dt);
+	des_write(MAX_MIPI_MAP_DST(pipe, map_n), (out_vc << 6) | out_dt);
+	des_update_bits(MAX_MIPI_MAP_DST_PHY(pipe, map_n / 4), 0x03 << offset, out_mipi << offset);
+	des_update_bits(MAX_MIPI_TX11(pipe), BIT(map_n), BIT(map_n));	/* enable SRC_n to DST_n mapping */
+}
+
+static void max96712_mipi_setup(struct max96712_priv *priv)
+{
+	des_write(MAX96712_VIDEO_PIPE_EN, 0);	/* disable all pipes */
+	des_update_bits(MAX_MIPI_PHY0, 0x80, 0x00); /* Disable all MIPI clocks running force */
+	des_update_bits(MAX_BACKTOP12(0), 0x02, 0); /* CSI output disable */
+
+	des_write(MAX_MIPI_PHY0, 0x04);		/* MIPI Phy 2x4 mode */
+	des_write(MAX_MIPI_PHY3, 0xe4);		/* Lane map: straight */
+	des_write(MAX_MIPI_PHY4, 0xe4);		/* Lane map: straight */
+	//des_write(MAX_MIPI_PHY5, 0x00);	/* HS_prepare time, non-inverted polarity */
+	//des_write(MAX_MIPI_PHY6, 0x00);
+
+	des_write(MAX_MIPI_TX10(1), 0xc0);	/* MIPI1: 4 lanes */
+	des_write(MAX_MIPI_TX10(2), 0xc0);	/* MIPI2: 4 lanes */
+
+	des_update_bits(MAX_BACKTOP22(0), 0x3f, ((priv->csi_rate[1] / 100) & 0x1f) | BIT(5)); /* MIPI rate */
+	des_update_bits(MAX_BACKTOP25(0), 0x3f, ((priv->csi_rate[1] / 100) & 0x1f) | BIT(5));
+	des_update_bits(MAX_BACKTOP28(0), 0x3f, ((priv->csi_rate[2] / 100) & 0x1f) | BIT(5));
+	des_update_bits(MAX_BACKTOP31(0), 0x3f, ((priv->csi_rate[2] / 100) & 0x1f) | BIT(5));
+
+	des_update_bits(MAX_MIPI_PHY2, 0xf0, 0xf0); /* enable all MIPI PHYs */
+}
+
+/* -----------------------------------------------------------------------------
+ * GMSL1
+ */
+
+static int max96712_gmsl1_sensor_reset(struct max96712_priv *priv, int link_n, int reset_on)
+{
+	struct max96712_link *link = priv->link[link_n];
+
+	if (priv->gpio_resetb < 1 || priv->gpio_resetb > 5)
+		return -EINVAL;
+
+	/* sensor reset/unreset */
+	ser_write(0x0f, (0xfe & ~BIT(priv->gpio_resetb)) | /* set GPIOn value to reset/unreset */
+		  ((priv->active_low_resetb ? BIT(priv->gpio_resetb) : 0) ^ reset_on));
+	ser_write(0x0e, 0x42 | BIT(priv->gpio_resetb)); /* set GPIOn direction output */
+
+	return 0;
+}
+
+static void max96712_gmsl1_cc_enable(struct max96712_priv *priv, int link, int on)
+{
+	des_update_bits(MAX_GMSL1_4(link), 0x03, on ? 0x03 : 0x00);
+	usleep_range(2000, 2500);
+}
+
+static int max96712_gmsl1_get_link_lock(struct max96712_priv *priv, int link_n)
+{
+	int val = 0;
+
+	des_read(MAX_GMSL1_CB(link_n), &val);
+
+	return !!(val & BIT(0));
+}
+
+static void max96712_gmsl1_link_crossbar_setup(struct max96712_priv *priv, int link, int dt)
+{
+	/* Always decode reversed bus, since we always reverse on serializer (old imagers need this) */
+	switch (dt) {
+	case MIPI_DT_YUV8:
+		des_write(MAX_CROSS(link, 0), 7);
+		des_write(MAX_CROSS(link, 1), 6);
+		des_write(MAX_CROSS(link, 2), 5);
+		des_write(MAX_CROSS(link, 3), 4);
+		des_write(MAX_CROSS(link, 4), 3);
+		des_write(MAX_CROSS(link, 5), 2);
+		des_write(MAX_CROSS(link, 6), 1);
+		des_write(MAX_CROSS(link, 7), 0);
+
+		if (priv->dbl == 0) {
+			/* deserializer DBL=1 is MUX, DBL=0 is Normal */
+			des_write(MAX_CROSS(link, 8), 15);
+			des_write(MAX_CROSS(link, 9), 14);
+			des_write(MAX_CROSS(link, 10), 13);
+			des_write(MAX_CROSS(link, 11), 12);
+			des_write(MAX_CROSS(link, 12), 11);
+			des_write(MAX_CROSS(link, 13), 10);
+			des_write(MAX_CROSS(link, 14), 9);
+			des_write(MAX_CROSS(link, 15), 8);
+		}
+		break;
+	case MIPI_DT_RAW12:
+		des_write(MAX_CROSS(link, 0), 11);
+		des_write(MAX_CROSS(link, 1), 10);
+		des_write(MAX_CROSS(link, 2), 9);
+		des_write(MAX_CROSS(link, 3), 8);
+		des_write(MAX_CROSS(link, 4), 7);
+		des_write(MAX_CROSS(link, 5), 6);
+		des_write(MAX_CROSS(link, 6), 5);
+		des_write(MAX_CROSS(link, 7), 4);
+		des_write(MAX_CROSS(link, 8), 3);
+		des_write(MAX_CROSS(link, 9), 2);
+		des_write(MAX_CROSS(link, 10), 1);
+		des_write(MAX_CROSS(link, 11), 0);
+
+		if (priv->dbl == 0) {
+			/* deserializer DBL=1 is MUX, DBL=0 is Normal */
+			des_write(MAX_CROSS(link, 12), 23);
+			des_write(MAX_CROSS(link, 13), 22);
+			des_write(MAX_CROSS(link, 14), 21);
+			des_write(MAX_CROSS(link, 15), 20);
+			des_write(MAX_CROSS(link, 16), 19);
+			des_write(MAX_CROSS(link, 17), 18);
+			des_write(MAX_CROSS(link, 18), 17);
+			des_write(MAX_CROSS(link, 19), 16);
+			des_write(MAX_CROSS(link, 20), 15);
+			des_write(MAX_CROSS(link, 21), 14);
+			des_write(MAX_CROSS(link, 22), 13);
+			des_write(MAX_CROSS(link, 23), 12);
+		}
+		break;
+	default:
+		dev_err(&priv->client->dev, "crossbar for dt %d is not supported\n", dt);
+		break;
+	}
+
+	des_write(MAX_CROSS(link, 24), (priv->hsync ? 0x40 : 0) + 24);	/* invert HS polarity */
+	des_write(MAX_CROSS(link, 25), (priv->vsync ? 0 : 0x40) + 25);	/* invert VS polarity */
+	des_write(MAX_CROSS(link, 26), (priv->hsync ? 0x40 : 0) + 26);	/* invert DE polarity */
+}
+
+static void max96712_gmsl1_initial_setup(struct max96712_priv *priv)
+{
+	int i;
+
+	des_update_bits(MAX96712_REG6, 0xf0, 0);			/* set GMSL1 mode */
+	des_write(MAX96712_REG26, 0x11);				/* 187.5M/3G */
+	des_write(MAX96712_REG27, 0x11);				/* 187.5M/3G */
+
+	for (i = 0; i < priv->n_links; i++) {
+		des_write(MAX_GMSL1_2(i), 0x03);			/* Autodetect serial data rate range */
+		des_write(MAX_GMSL1_4(i), 0);				/* disable REV/FWD CC */
+		des_update_bits(MAX_GMSL1_6(i), BIT(7), priv->him ? BIT(7) : 0); /* HIM/Legacy mode */
+		des_write(MAX_GMSL1_7(i), (priv->dbl ? BIT(7) : 0) |	/* DBL mode */
+					  (priv->bws ? BIT(5) : 0) |	/* BWS 32/24-bit */
+					  (priv->hibw ? BIT(3) : 0) |	/* High-bandwidth mode */
+					  (priv->hven ? BIT(2) : 0));	/* HS/VS encoding enable */
+		des_write(MAX_GMSL1_D(i), 0);				/* disable artificial ACKs, RC conf disable */
+		des_write(MAX_GMSL1_F(i), 0);				/* disable DE processing */
+		des_write(MAX_GMSL1_96(i), (0x13 << 3) | 0x3);		/* color map: RAW12 double - i.e. bypass packet as is */
+	}
+}
+
+static int max96712_gmsl1_reverse_channel_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int ser_addrs[] = { 0x40 };					/* possible MAX9271/MAX96705 addresses on i2c bus */
+	int lock_sts;
+	int timeout = priv->timeout;
+	char timeout_str[40];
+	u8 val = 0;
+	int ret = 0;
+
+	des_write(MAX_GMSL1_D(link_n), 0x81);			/* enable artificial ACKs, RC conf mode */
+	des_write(MAX_RLMSC5(link_n), 0xa0);			/* override RC pulse length */
+	des_write(MAX_RLMSC4(link_n), 0x80);			/* override RC rise/fall time */
+	usleep_range(2000, 2500);
+	des_write(MAX_GMSL1_4(link_n), 0x3);			/* enable REV/FWD CC */
+	des_write(MAX96712_REG6, BIT(link_n));			/* GMSL1 mode, enable GMSL link# */
+	max96712_reset_oneshot(priv, BIT(link_n));
+	usleep_range(2000, 2500);
+
+	for (; timeout > 0; timeout--) {
+		if (priv->him) {
+			/* HIM mode setup */
+			__reg8_write(ser_addrs[0], 0x4d, 0xc0);
+			usleep_range(2000, 2500);
+			__reg8_write(ser_addrs[0], 0x04, 0x43);	/* wake-up, enable RC, conf_link */
+			usleep_range(2000, 2500);
+			if (priv->bws) {
+				__reg8_write(ser_addrs[0], 0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+								 (priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+								 (0x80) |				/* DBL=1 in serializer */
+								 (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+				usleep_range(2000, 2500);
+			}
+		} else {
+			/* Legacy mode setup */
+			des_write(MAX_RLMS95(link_n), 0x88);		/* override RC Tx amplitude */
+			usleep_range(2000, 2500);
+
+			__reg8_write(ser_addrs[0], 0x04, 0x43);		/* wake-up, enable RC, conf_link */
+			usleep_range(2000, 2500);
+			__reg8_write(ser_addrs[0], 0x08, 0x01);		/* RC receiver high threshold enable */
+			__reg8_write(ser_addrs[0], 0x97, 0x5f);		/* enable RC programming (MAX96705-MAX96711 only) */
+			usleep_range(2000, 2500);
+
+			if (priv->bws) {
+				__reg8_write(ser_addrs[0], 0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+								 (priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+								 (0x80) |				/* DBL=1 in serializer */
+								 (priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+				usleep_range(2000, 2500);
+			}
+
+			des_write(MAX_RLMS95(link_n), 0xd3);	/* increase RC Tx amplitude */
+			usleep_range(2000, 2500);
+		}
+
+		__reg8_read(ser_addrs[0], 0x1e, &val);
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			link->ser_id = val;
+			__reg8_write(ser_addrs[0], 0x00, link->ser_addr << 1);	 /* relocate serizlizer on I2C bus */
+			usleep_range(2000, 2500);
+			break;
+		}
+
+		/* Check if already initialized (after reboot/reset ?) */
+		ser_read(0x1e, &val);
+		if (val == MAX9271_ID || val == MAX96705_ID || val == MAX96707_ID) {
+			link->ser_id = val;
+			ser_write(0x04, 0x43);			/* enable RC, conf_link */
+			usleep_range(2000, 2500);
+			ret = -EADDRINUSE;
+			break;
+		}
+
+		if (poc_trig) {
+			if (!IS_ERR(link->poc_reg) && (timeout % poc_trig == 0)) {
+				regulator_disable(link->poc_reg); /* POC power off */
+				mdelay(200);
+				ret = regulator_enable(link->poc_reg); /* POC power on */
+				if (ret)
+					dev_err(&link->client->dev, "failed to enable poc regulator\n");
+				mdelay(priv->poc_delay);
+			}
+		}
+	}
+
+	max96712_gmsl1_sensor_reset(priv, link_n, 0);		/* sensor un-reset */
+
+	des_write(MAX_GMSL1_D(link_n), 0);			/* disable artificial ACKs, RC conf disable */
+	usleep_range(2000, 2500);
+	des_read(MAX_GMSL1_CB(link_n), &lock_sts);
+	lock_sts = !!(lock_sts & 0x01);
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	priv->links_mask |= BIT(link_n);
+
+out:
+	sprintf(timeout_str, " retries=%d lock_sts=%d", priv->timeout - timeout, lock_sts);
+	dev_info(&priv->client->dev, "GMSL1 link%d %s %sat 0x%x %s %s\n", link_n, chip_name(link->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", link->ser_addr,
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL link establish" : "",
+			       priv->timeout - timeout ? timeout_str : "");
+	return ret;
+}
+
+static int max96712_gmsl1_link_serializer_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+
+	/* GMSL setup */
+	ser_write(0x0d, 0x22 | MAXIM_I2C_I2C_SPEED);		/* disable artificial ACK, I2C speed set */
+	ser_write(0x07, (priv->hven ? 0x04 : 0) |		/* HS/VS encoding enable */
+			(priv->pclk_rising_edge ? 0 : 0x10) |	/* PCLK edge */
+			(0x80) |				/* DBL=1 in serializer */
+			(priv->bws ? 0x20 : 0));		/* BWS 32/24-bit */
+	usleep_range(2000, 2500);
+	ser_write(0x02, 0xff);					/* spread spectrum +-4%, pclk range automatic, Gbps automatic */
+	usleep_range(2000, 2500);
+
+	if (link->ser_id != MAX9271_ID) {
+		switch (priv->dt) {
+		case MIPI_DT_YUV8:
+			if (priv->dbl == 1) {
+				/* setup crossbar for YUV8/RAW8: reverse DVP bus */
+				ser_write(0x20, priv->cb[7]);
+				ser_write(0x21, priv->cb[6]);
+				ser_write(0x22, priv->cb[5]);
+				ser_write(0x23, priv->cb[4]);
+				ser_write(0x24, priv->cb[3]);
+				ser_write(0x25, priv->cb[2]);
+				ser_write(0x26, priv->cb[1]);
+				ser_write(0x27, priv->cb[0]);
+
+				/* this is second byte in the packet (DBL=1 in serializer always) */
+				ser_write(0x30, priv->cb[7] + 16);
+				ser_write(0x31, priv->cb[6] + 16);
+				ser_write(0x32, priv->cb[5] + 16);
+				ser_write(0x33, priv->cb[4] + 16);
+				ser_write(0x34, priv->cb[3] + 16);
+				ser_write(0x35, priv->cb[2] + 16);
+				ser_write(0x36, priv->cb[1] + 16);
+				ser_write(0x37, priv->cb[0] + 16);
+			} else {
+				/* setup crossbar for YUV8/RAW8: reversed DVP bus */
+				ser_write(0x20, priv->cb[4]);
+				ser_write(0x21, priv->cb[3]);
+				ser_write(0x22, priv->cb[2]);
+				ser_write(0x23, priv->cb[1]);
+				ser_write(0x24, priv->cb[0]);
+				ser_write(0x25, 0x40);
+				ser_write(0x26, 0x40);
+				if (link->ser_id == MAX96705_ID) {
+					ser_write(0x27, 14); /* HS: D14->D18  */
+					ser_write(0x28, 15); /* VS: D15->D19 */
+					ser_write(0x29, 14); /* DE: D14->D20 */
+				}
+				if (link->ser_id == MAX96707_ID) {
+					ser_write(0x27, 12); /* HS: D12->D18, this is a virtual NC pin, hence it is D14 at HS */
+					ser_write(0x28, 13); /* VS: D13->D19 */
+					ser_write(0x29, 12); /* DE: D12->D20 */
+				}
+				ser_write(0x2A, 0x40);
+
+				/* this is second byte in the packet (DBL=1 in serializer) */
+				ser_write(0x30, 0x10 + priv->cb[7]);
+				ser_write(0x31, 0x10 + priv->cb[6]);
+				ser_write(0x32, 0x10 + priv->cb[5]);
+				ser_write(0x33, 0x10 + priv->cb[4]);
+				ser_write(0x34, 0x10 + priv->cb[3]);
+				ser_write(0x35, 0x10 + priv->cb[2]);
+				ser_write(0x36, 0x10 + priv->cb[1]);
+				ser_write(0x37, 0x10 + priv->cb[0]);
+				ser_write(0x38, priv->cb[7]);
+				ser_write(0x39, priv->cb[6]);
+				ser_write(0x3A, priv->cb[5]);
+
+				ser_write(0x67, 0xC4); /* DBL_ALIGN_TO = 100b */
+			}
+			break;
+		case MIPI_DT_RAW12:
+			/* setup crossbar for RAW12: reverse DVP bus */
+			ser_write(0x20, priv->cb[11]);
+			ser_write(0x21, priv->cb[10]);
+			ser_write(0x22, priv->cb[9]);
+			ser_write(0x23, priv->cb[8]);
+			ser_write(0x24, priv->cb[7]);
+			ser_write(0x25, priv->cb[6]);
+			ser_write(0x26, priv->cb[5]);
+			ser_write(0x27, priv->cb[4]);
+			ser_write(0x28, priv->cb[3]);
+			ser_write(0x29, priv->cb[2]);
+			ser_write(0x2a, priv->cb[1]);
+			ser_write(0x2b, priv->cb[0]);
+
+			/* this is second byte in the packet (DBL=1 in serializer) */
+			ser_write(0x30, priv->cb[11] + 16);
+			ser_write(0x31, priv->cb[10] + 16);
+			ser_write(0x32, priv->cb[9] + 16);
+			ser_write(0x33, priv->cb[8] + 16);
+			ser_write(0x34, priv->cb[7] + 16);
+			ser_write(0x35, priv->cb[6] + 16);
+			ser_write(0x36, priv->cb[5] + 16);
+			ser_write(0x37, priv->cb[4] + 16);
+			ser_write(0x38, priv->cb[3] + 16);
+			ser_write(0x39, priv->cb[2] + 16);
+			ser_write(0x3a, priv->cb[1] + 16);
+			ser_write(0x3b, priv->cb[0] + 16);
+
+			if (!(priv->bws || priv->hibw) && priv->dbl)
+				dev_err(&priv->client->dev, " BWS must be 27/32-bit for RAW12 in DBL mode\n");
+			break;
+		}
+	}
+
+	/* I2C translator setup */
+	//ser_write(0x09, OV490_I2C_ADDR_NEW << 1);	/* sensor I2C translated - must be set by sensor driver */
+	//ser_write(0x0A, OV490_I2C_ADDR << 1);		/* sensor I2C native - must be set by sensor driver */
+	ser_write(0x0B, BROADCAST << 1);		/* serializer broadcast I2C translated */
+	ser_write(0x0C, link->ser_addr << 1);		/* serializer broadcast I2C native */
+	/* put serializer in configuration link state  */
+	ser_write(0x04, 0x43);				/* enable RC, conf_link */
+	usleep_range(2000, 2500);
+
+	return 0;
+}
+
+static void max96712_gmsl1_link_pipe_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int pipe = link_n; /* straight map */
+	int dt = priv->dt; /* should come from imager */
+	int in_vc = 0;
+
+	max96712_pipe_override(priv, pipe, dt, in_vc);		/* override dt, vc */
+
+	des_write(MAX_MIPI_TX11(pipe), 0x00);			/* disable all mappings */
+	des_write(MAX_MIPI_TX12(pipe), 0x00);
+
+	/* use map #0 for payload data */
+	max96712_set_pipe_to_mipi_mapping(priv, pipe, 0,	/* pipe, map# */
+					  dt, in_vc,		/* src DT, VC */
+					  dt, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	/* use map #1 for FS */
+	max96712_set_pipe_to_mipi_mapping(priv, pipe, 1,	/* pipe, map# */
+					  0x00, in_vc,		/* src DT, VC */
+					  0x00, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	/* use map #2 for FE */
+	max96712_set_pipe_to_mipi_mapping(priv, pipe, 2,	/* pipe, map# */
+					  0x01, in_vc,		/* src DT, VC */
+					  0x01, link->out_vc,	/* dst DT, VC */
+					  link->out_mipi);	/* dst MIPI PHY */
+	usleep_range(5000, 5500);
+
+	link->pipes_mask |= BIT(pipe);
+}
+
+static void max96712_gmsl1_postinit(struct max96712_priv *priv)
+{
+	int i;
+	u8 val = 0;
+
+	for (i = 0; i < priv->n_links; i++) {
+		struct max96712_link *link = priv->link[i];
+
+		if (!(priv->links_mask & BIT(i)))
+			continue;
+
+		des_write(MAX_GMSL1_4(i), 0x3);			/* enable REV/FWD CC */
+		des_write(MAX96712_REG6, BIT(i));		/* GMSL1 mode, enable GMSL link# */
+		max96712_reset_oneshot(priv, BIT(i));
+		usleep_range(2000, 2500);
+
+		ser_read(0x15, &val);
+		if (!(val & BIT(1)))
+			dev_warn(&priv->client->dev, "link%d valid PCLK is not detected\n", i);
+
+		/* switch to GMSL serial_link for streaming video */
+		max96712_write_remote_verify(priv, i, 0x04, conf_link ? 0x43 : 0x83);
+		usleep_range(2000, 2500);
+
+		des_write(MAX_GMSL1_4(i), 0x00);		/* disable REV/FWD CC */
+
+		switch (priv->link[i]->ser_id) {
+		case MAX9271_ID:
+			des_update_bits(MAX_GMSL1_6(i), 0x07, 0x01); /* use D14/15 for HS/VS */
+			break;
+		case MAX96705_ID:
+		case MAX96707_ID:
+			des_update_bits(MAX_GMSL1_6(i), 0x07, 0x00); /* use D18/D19 for HS/VS */
+			break;
+		}
+	}
+
+	for (i = 0; i < priv->n_links; i++)
+		des_write(MAX_GMSL1_4(i), priv->links_mask & BIT(i) ? 0x03 : 0); /* enable REV/FWD CC */
+
+	des_update_bits(MAX96712_REG6, 0x0f, priv->links_mask);	/* enable detected links */
+	max96712_reset_oneshot(priv, priv->links_mask);		/* one-shot reset valid links */
+}
+
+static void max96712_gmsl1_fsync_setup(struct max96712_priv *priv)
+{
+	des_write(MAX96712_FSYNC_5, priv->fsync_period & 0xff);	/* Fsync Period L */
+	des_write(MAX96712_FSYNC_6, (priv->fsync_period >> 8) & 0xff);/* Fsync Period M */
+	des_write(MAX96712_FSYNC_7, priv->fsync_period >> 16);	/* Fsync Period H */
+	//des_write(MAX96712_FSYNC_8, 0x00);			/* Disable Err Thresh */
+	//des_write(MAX96712_FSYNC_9, 0x00);			/* Disable Err Thresh */
+	des_write(MAX96712_FSYNC_10, 0x00);			/* Disable Overlap */
+	des_write(MAX96712_FSYNC_11, 0x00);
+
+	des_write(MAX96712_FSYNC_0, 0x00);			/* Manual method, Internal GMSL1 generator mode */
+
+	des_write(MAX_GMSL1_8(0), 0x11);			/* Fsync Tx Enable on Link A */
+	des_write(MAX_GMSL1_8(1), 0x11);			/* Fsync Tx Enable on Link B */
+	des_write(MAX_GMSL1_8(2), 0x11);			/* Fsync Tx Enable on Link C */
+	des_write(MAX_GMSL1_8(3), 0x11);			/* Fsync Tx Enable on Link D */
+
+	des_write(MAX96712_FSYNC_15, 0x1f);			/* GMSL1 Type Fsync, Enable all pipes */
+}
+
+/* -----------------------------------------------------------------------------
+ * GMSL2
+ */
+
+static void max96712_gmsl2_cc_enable(struct max96712_priv *priv, int link, int on)
+{
+	/* nothing */
+}
+
+static int max96712_gmsl2_get_link_lock(struct max96712_priv *priv, int link_n)
+{
+	int lock_reg[] = {MAX96712_CTRL3, MAX96712_CTRL12, MAX96712_CTRL13, MAX96712_CTRL14};
+	int val = 0;
+
+	des_read(lock_reg[link_n], &val);
+
+	return !!(val & BIT(3));
+}
+
+static void max96712_gmsl2_initial_setup(struct max96712_priv *priv)
+{
+	des_update_bits(MAX96712_REG6, 0xf0, 0xf0);	/* set GMSL2 mode */
+	des_write(MAX96712_REG26, 0x22);		/* 187.5M/6G */
+	des_write(MAX96712_REG27, 0x22);		/* 187.5M/6G */
+}
+
+static int max96712_gmsl2_reverse_channel_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int ser_addrs[] = {0x40, 0x42, 0x60, 0x62}; /* possible MAX9295 addresses on i2c bus */
+	int timeout = priv->timeout;
+	int ret = 0;
+	int i = 0;
+
+	des_write(MAX96712_REG6, 0xf0 | BIT(link_n));		/* GMSL2 mode, enable GMSL link# */
+	max96712_reset_oneshot(priv, BIT(link_n));
+
+	/* wait the link to be established, indicated when status bit LOCKED goes high */
+	for (; timeout > 0; timeout--) {
+		if (max96712_gmsl2_get_link_lock(priv, link_n))
+			break;
+		mdelay(1);
+	}
+
+	if (!timeout) {
+		ret = -ETIMEDOUT;
+		goto out;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(ser_addrs); i++) {
+		int val = 0;
+
+		__reg16_read(ser_addrs[i], 0x000d, &val);	/* read serializer ID */
+		if (val == MAX9295A_ID || val == MAX9295B_ID) {
+			link->ser_id = val;
+			__reg16_write(ser_addrs[i], 0x0000, link->ser_addr << 1); /* relocate serizlizer on I2C bus */
+			usleep_range(2000, 2500);
+			break;
+		}
+	}
+
+	if (i == ARRAY_SIZE(ser_addrs)) {
+		dev_err(&priv->client->dev, "serializer not found\n");
+		goto out;
+	}
+
+	priv->links_mask |= BIT(link_n);
+
+out:
+	dev_info(&priv->client->dev, "link%d %s %sat 0x%x (0x%x) %s\n", link_n, chip_name(link->ser_id),
+			       ret == -EADDRINUSE ? "already " : "", link->ser_addr, ser_addrs[i],
+			       ret == -ETIMEDOUT ? "not found: timeout GMSL2 link establish" : "");
+	return ret;
+}
+
+static int max96712_gmsl2_link_serializer_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int i;
+
+	if (strcmp(priv->mbus, "dvp") == 0) {
+		ser_write(MAX9295_VIDEO_TX0(0), BIT(6) |	/* line CRC enable */
+						(priv->hven ? BIT(5) : 0)); /* HS/VS encoding */
+		ser_write(MAX9295_VIDEO_TX1(0), 0x0a);	/* BPP = 10 */
+		ser_write(MAX9295_REG7, 0x07);		/* DVP stream, enable HS/VS, rising edge */
+
+		switch (priv->dt) {
+		case MIPI_DT_YUV8:
+		case MIPI_DT_RAW12:
+			/* setup crossbar: strait DVP mapping */
+			ser_write(MAX9295_CROSS(0), priv->cb[0]);
+			ser_write(MAX9295_CROSS(1), priv->cb[1]);
+			ser_write(MAX9295_CROSS(2), priv->cb[2]);
+			ser_write(MAX9295_CROSS(3), priv->cb[3]);
+			ser_write(MAX9295_CROSS(4), priv->cb[4]);
+			ser_write(MAX9295_CROSS(5), priv->cb[5]);
+			ser_write(MAX9295_CROSS(6), priv->cb[6]);
+			ser_write(MAX9295_CROSS(7), priv->cb[7]);
+			ser_write(MAX9295_CROSS(8), priv->cb[8]);
+			ser_write(MAX9295_CROSS(9), priv->cb[9]);
+			ser_write(MAX9295_CROSS(10), priv->cb[10]);
+			ser_write(MAX9295_CROSS(11), priv->cb[11]);
+			break;
+		}
+	} else {
+		/* defaults:
+		 *  REG2	- video enable Pipex X,Z
+		 *  MIPI_RX0	- 1x4 mode (1-port x 4-lanes)
+		 *  MIPI_RX1	- 4-lanes
+		 *  MIPI_RX2, MIPI_RX3 - merge PHY1,PHY2 to 1x4-mode
+		 *  FRONTTOP_9	- start Pipes X,Z from CSI_A,CSI_B
+		 */
+
+		ser_write(MAX9295_FRONTTOP_0, 0x71);			/* enable Pipe X from from CSI_A,CSI_B */
+		ser_write(MAX9295_FRONTTOP_12, BIT(6) | priv->dt);	/* primary DT for Pipe X */
+		ser_write(MAX9295_FRONTTOP_13, BIT(6) | MIPI_DT_EMB);	/* secondary DT for Pipe X */
+	}
+
+	for (i = 0; i < 11; i++) {
+		if (priv->gpio[i] == 0) {
+			/* GPIO set 0 */
+			ser_write(MAX9295_GPIO_A(i), 0x80);	/* 1MOm, GPIO output low */
+			ser_write(MAX9295_GPIO_B(i), 0xa0);	/* push-pull, pull-down */
+		}
+		if (priv->gpio[i] == 1) {
+			/* GPIO set 1 */
+			ser_write(MAX9295_GPIO_A(i), 0x90);	/* 1MOm, GPIO output high */
+			ser_write(MAX9295_GPIO_B(i), 0x60);	/* push-pull, pull-up */
+		}
+		if (priv->gpio[i] == 2) {
+			/* GPIO FSIN */
+			ser_write(MAX9295_GPIO_A(i), 0x84);	/* 1MOm, GMSL2 RX from deserializer */
+			ser_write(MAX9295_GPIO_C(i), 0x08);	/* pull-none, GPIO ID=8 assosiated with FSYNC transmission */
+		}
+		if (priv->gpio[i] == 3) {
+			/* GPIO Interrupt */
+			ser_write(MAX9295_GPIO_A(i), 0x63);	/* 40kOm, GMSL2 TX to deserializer */
+			ser_write(MAX9295_GPIO_B(i), 0x25);	/* push-pull, pull-none, GPIO stream ID=5 */
+		}
+	}
+
+	/* I2C translator setup */
+	//ser_write(MAX9295_I2C2, OV490_I2C_ADDR_NEW << 1); /* sensor I2C translated - must be set by sensor driver */
+	//ser_write(MAX9295_I2C3, OV490_I2C_ADDR << 1);	/* sensor I2C native - must be set by sensor driver */
+	ser_write(MAX9295_I2C4, BROADCAST << 1);	/* serializer broadcast I2C translated */
+	ser_write(MAX9295_I2C5, link->ser_addr << 1);	/* serializer broadcast I2C native */
+	usleep_range(2000, 2500);
+
+	return 0;
+}
+
+static struct {
+	int in_dt;
+	int out_dt;
+} gmsl2_pipe_maps[] = {
+	{0x00,		0x00},		/* FS */
+	{0x01,		0x01},		/* FE */
+	{MIPI_DT_YUV8,	MIPI_DT_YUV8},	/* payload data */
+	{MIPI_DT_RAW8,	MIPI_DT_RAW8},
+	{MIPI_DT_RAW12,	MIPI_DT_RAW12},
+};
+
+static void max96712_gmsl2_pipe_set_source(struct max96712_priv *priv, int pipe, int phy, int in_pipe)
+{
+	int offset = (pipe % 2) * 4;
+
+	des_update_bits(MAX96712_VIDEO_PIPE_SEL(pipe / 2), 0x0f << offset, (phy << (offset + 2)) |
+									   (in_pipe << offset));
+}
+
+static void max96712_gmsl2_link_pipe_setup(struct max96712_priv *priv, int link_n)
+{
+	struct max96712_link *link = priv->link[link_n];
+	int pipe = link_n; /* straight mapping */
+	int dt = priv->dt; /* must come from imager */
+	int in_vc = 0;
+	int i;
+
+	max96712_gmsl2_pipe_set_source(priv, pipe, link_n, 0);			/* route Pipe X only */
+
+	if (strcmp(priv->mbus, "dvp") == 0) {
+		des_write(MAX96712_RX0(pipe), 0);				/* stream_id = 0 */
+		//des_update_bits(MAX_VIDEO_RX0(pipe), BIT(0), BIT(0));		/* disable Packet detector */
+		max96712_pipe_override(priv, pipe, dt, in_vc);			/* override dt, vc */
+	}
+
+	des_write(MAX_MIPI_TX11(pipe), 0x00);					/* disable all mappings */
+	des_write(MAX_MIPI_TX12(pipe), 0x00);
+
+	for (i = 0; i < ARRAY_SIZE(gmsl2_pipe_maps); i++) {
+		max96712_set_pipe_to_mipi_mapping(priv, pipe, i,		/* pipe, map# */
+						  gmsl2_pipe_maps[i].in_dt, in_vc, /* src DT, VC */
+						  gmsl2_pipe_maps[i].out_dt, link->out_vc, /* dst DT, VC */
+						  link->out_mipi);		/* dst MIPI PHY */
+	}
+
+	link->pipes_mask |= BIT(pipe);
+}
+
+static void max96712_gmsl2_postinit(struct max96712_priv *priv)
+{
+	des_update_bits(MAX96712_REG6, 0x0f, priv->links_mask);	/* enable detected links */
+	max96712_reset_oneshot(priv, priv->links_mask);		/* one-shot reset valid links */
+}
+
+static void max96712_gmsl2_link_crossbar_setup(struct max96712_priv *priv, int link, int dt)
+{
+	des_write(MAX_CROSS(link, 24), (priv->hsync ? 0x40 : 0) + 24);	/* invert HS polarity */
+	des_write(MAX_CROSS(link, 25), (priv->vsync ? 0 : 0x40) + 25);	/* invert VS polarity */
+	des_write(MAX_CROSS(link, 26), (priv->hsync ? 0x40 : 0) + 26);	/* invert DE polarity */
+}
+
+static void max96712_gmsl2_fsync_setup(struct max96712_priv *priv)
+{
+	des_write(MAX96712_FSYNC_5, priv->fsync_period & 0xff);	/* Fsync Period L */
+	des_write(MAX96712_FSYNC_6, (priv->fsync_period >> 8) & 0xff);/* Fsync Period M */
+	des_write(MAX96712_FSYNC_7, priv->fsync_period >> 16);	/* Fsync Period H */
+	des_write(MAX96712_FSYNC_10, 0x00);			/* Disable Overlap */
+	des_write(MAX96712_FSYNC_11, 0x00);
+
+	des_write(MAX96712_FSYNC_0, 0x00);			/* Manual method, Internal GMSL2 generator mode */
+	des_write(MAX96712_FSYNC_15, 0x80);			/* GMSL2 Type Fsync, Disable all pipes for manual mode */
+	des_write(MAX96712_FSYNC_17, 8 << 3);			/* GPIO ID=8 assosiated with FSYNC transmission */
+}
+
+/* -----------------------------------------------------------------------------
+ * I2C Multiplexer
+ */
+
+static int max96712_i2c_mux_select(struct i2c_mux_core *muxc, u32 chan)
+{
+	/* Do nothing! */
+	return 0;
+}
+
+static int max96712_i2c_mux_init(struct max96712_priv *priv)
+{
+	struct i2c_client *client = priv->client;
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C))
+		return -ENODEV;
+
+	priv->mux = i2c_mux_alloc(client->adapter, &client->dev,
+				  priv->n_links, 0, I2C_MUX_LOCKED,
+				  max96712_i2c_mux_select, NULL);
+	if (!priv->mux)
+		return -ENOMEM;
+
+	priv->mux->priv = priv;
+
+	return 0;
+}
+
+#define max96712_cc_enable(priv,i,en)		(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_cc_enable(priv, i, en) : \
+										 max96712_gmsl1_cc_enable(priv, i, en))
+#define max96712_initial_setup(priv)		(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_initial_setup(priv) : \
+										 max96712_gmsl1_initial_setup(priv))
+#define max96712_reverse_channel_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_reverse_channel_setup(priv, i) : \
+										 max96712_gmsl1_reverse_channel_setup(priv, i))
+#define max96712_link_serializer_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_link_serializer_setup(priv, i) : \
+										 max96712_gmsl1_link_serializer_setup(priv, i))
+#define max96712_link_pipe_setup(priv,i)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_link_pipe_setup(priv, i) : \
+										 max96712_gmsl1_link_pipe_setup(priv, i))
+#define max96712_link_crossbar_setup(priv,i,dt)	(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_link_crossbar_setup(priv, i, dt) : \
+										 max96712_gmsl1_link_crossbar_setup(priv, i, dt))
+#define max96712_postinit(priv)			(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_postinit(priv) : \
+										 max96712_gmsl1_postinit(priv))
+#define max96712_fsync_setup(priv)		(priv->gmsl_mode == MODE_GMSL2 ? max96712_gmsl2_fsync_setup(priv) : \
+										 max96712_gmsl1_fsync_setup(priv))
+
+static int max96712_preinit(struct max96712_priv *priv)
+{
+	int i;
+
+	des_update_bits(MAX96712_PWR1, BIT(6), BIT(6));		/* reset chip */
+	mdelay(5);
+
+	/* enable internal regulator for 1.2V VDD supply */
+	des_update_bits(MAX96712_CTRL0, BIT(2), BIT(2));	/* REG_ENABLE = 1 */
+	des_update_bits(MAX96712_CTRL2, BIT(4), BIT(4));	/* REG_MNL = 1 */
+
+	//for (i = 0; i < priv->n_links; i++) {
+	//	des_write(MAX_RLMS58(i), 0x28);
+	//	des_write(MAX_RLMS59(i), 0x68);
+	//	max96712_reset_oneshot(priv, BIT(i));
+	//}
+
+	/* I2C-I2C timings */
+	for (i = 0; i < 8; i++) {
+		des_write(MAX96712_I2C_0(i), 0x01);		/* Fast mode Plus, 1mS timeout */
+		des_write(MAX96712_I2C_1(i), 0x51);		/* i2c speed: 397Kbps, 1mS timeout */
+	}
+
+	des_update_bits(MAX96712_CTRL11, 0x55, priv->is_coax ? 0x55 : 0); /* cable mode */
+	des_update_bits(MAX96712_REG6, 0x0f, 0);		/* disable all links */
+
+	return 0;
+}
+
+static int max96712_initialize(struct max96712_priv *priv)
+{
+	int ret, i;
+
+	max96712_preinit(priv);
+	max96712_initial_setup(priv);
+	max96712_mipi_setup(priv);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg)) {
+			ret = regulator_enable(priv->link[i]->poc_reg); /* POC power on */
+			if (ret) {
+				dev_err(&priv->link[i]->client->dev, "failed to enable poc regulator\n");
+				continue;
+			}
+			mdelay(priv->poc_delay);
+		}
+
+		ret = max96712_reverse_channel_setup(priv, i);
+		if (ret == -ETIMEDOUT)
+			continue;
+		if (!ret)
+			max96712_link_serializer_setup(priv, i);
+
+		max96712_link_pipe_setup(priv, i);
+		max96712_link_crossbar_setup(priv, i, priv->dt);
+
+		i2c_mux_add_adapter(priv->mux, 0, i, 0);
+		max96712_cc_enable(priv, i, 0);
+	}
+
+	max96712_postinit(priv);
+	max96712_fsync_setup(priv);
+
+	return 0;
+}
+
+static int max96712_reboot_notifier(struct notifier_block *nb, unsigned long code, void *data)
+{
+	struct max96712_priv *priv = container_of(nb, struct max96712_priv, reboot_nb);
+	int i;
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg))
+			regulator_disable(priv->link[i]->poc_reg); /* POC power off */
+	}
+
+	return NOTIFY_DONE;
+}
+
+static int max96712_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(sd);
+	int i, pipes_mask = 0;
+
+	for (i = 0; i < priv->n_links; i++)
+		pipes_mask |= priv->link[i]->pipes_mask;
+
+	if (enable) {
+		des_update_bits(MAX96712_VIDEO_PIPE_EN, pipes_mask, pipes_mask); /* enable link pipes */
+		if (atomic_inc_return(&priv->use_count) == 1) {
+			des_update_bits(MAX_BACKTOP12(0), 0x02, 0x02); /* CSI output enable */
+			/* Workaround for rev3 silicon: */
+			des_update_bits(MAX_MIPI_PHY0, 0x80, 0x80); /* Force all MIPI clocks running */
+		}
+	} else {
+		if (atomic_dec_return(&priv->use_count) == 0) {
+			des_update_bits(MAX_MIPI_PHY0, 0x80, 0x00); /* Disable all MIPI clocks running force */
+			des_update_bits(MAX_BACKTOP12(0), 0x02, 0); /* CSI output disable */
+		}
+		des_update_bits(MAX96712_VIDEO_PIPE_EN, pipes_mask, 0); /* disable link pipes */
+	}
+
+	return 0;
+}
+
+static const struct v4l2_subdev_video_ops max96712_video_ops = {
+	.s_stream = max96712_s_stream,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int max96712_g_register(struct v4l2_subdev *sd, struct v4l2_dbg_register *reg)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(sd);
+	int ret;
+	int val = 0;
+
+	ret = des_read(reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int max96712_s_register(struct v4l2_subdev *sd, const struct v4l2_dbg_register *reg)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(sd);
+
+	return des_write(reg->reg, (u8)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops max96712_subdev_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = max96712_g_register,
+	.s_register = max96712_s_register,
+#endif
+};
+
+static struct v4l2_subdev_ops max96712_subdev_ops = {
+	.core = &max96712_subdev_core_ops,
+	.video = &max96712_video_ops,
+};
+
+/* -----------------------------------------------------------------------------
+ * Async handling and registration of subdevices and links.
+ */
+
+static int max96712_notify_bound(struct v4l2_async_notifier *notifier,
+				 struct v4l2_subdev *subdev,
+				 struct v4l2_async_subdev *asd)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max96712_link *link = asd_to_max96712_link(asd);
+	int sink_pad = link->pad;
+	int src_pad;
+
+	src_pad = media_entity_get_fwnode_pad(&subdev->entity, link->fwnode, MEDIA_PAD_FL_SOURCE);
+	if (src_pad < 0) {
+		dev_err(&priv->client->dev, "Failed to find pad for %s\n", subdev->name);
+		return src_pad;
+	}
+
+	link->sd = subdev;
+
+	dev_dbg(&priv->client->dev, "Bound %s:%u -> %s:%u\n",
+		subdev->name, src_pad, priv->sd.name, sink_pad);
+
+	return media_create_pad_link(&subdev->entity, src_pad,
+				     &priv->sd.entity, sink_pad,
+				     MEDIA_LNK_FL_ENABLED |
+				     MEDIA_LNK_FL_IMMUTABLE);
+}
+
+static void max96712_notify_unbind(struct v4l2_async_notifier *notifier,
+				   struct v4l2_subdev *subdev,
+				   struct v4l2_async_subdev *asd)
+{
+	struct max96712_priv *priv = v4l2_get_subdevdata(notifier->sd);
+	struct max96712_link *link = asd_to_max96712_link(asd);
+
+	link->sd = NULL;
+
+	dev_dbg(&priv->client->dev, "Unbind %s\n", subdev->name);
+}
+
+static const struct v4l2_async_notifier_operations max96712_notify_ops = {
+	.bound = max96712_notify_bound,
+	.unbind = max96712_notify_unbind,
+};
+
+static int max96712_v4l2_init(struct i2c_client *client)
+{
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	struct device_node *ep;
+	unsigned int i;
+	int err;
+	long pixel_rate;
+
+	v4l2_async_notifier_init(&priv->notifier);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!(priv->links_mask & (1 << i)))
+			continue;
+		err = v4l2_async_notifier_add_subdev(&priv->notifier, priv->subdevs[i]);
+		if (err < 0)
+			return err;
+	}
+
+	priv->notifier.ops = &max96712_notify_ops;
+	err = v4l2_async_subdev_notifier_register(&priv->sd, &priv->notifier);
+	if (err < 0)
+		return err;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &max96712_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	/* Only YUV422 bpp=16 supported atm, decode to pixel_rate from fixed csi_rate */
+	pixel_rate = priv->csi_rate[priv->link[0]->out_mipi] / priv->lanes * 1000000;
+	v4l2_ctrl_handler_init(&priv->ctrls, 1);
+	v4l2_ctrl_new_std(&priv->ctrls, NULL, V4L2_CID_PIXEL_RATE,
+			  pixel_rate, pixel_rate, 1, pixel_rate);
+	priv->sd.ctrl_handler = &priv->ctrls;
+	err = priv->ctrls.error;
+	if (err)
+		return err;
+
+	/* Pads init */
+	priv->sd.entity.function = MEDIA_ENT_F_VID_IF_BRIDGE;
+	priv->pads[MAX96712_SOURCE].flags = MEDIA_PAD_FL_SOURCE;
+	priv->pads[MAX96712_SINK_LINK0].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX96712_SINK_LINK1].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX96712_SINK_LINK2].flags = MEDIA_PAD_FL_SINK;
+	priv->pads[MAX96712_SINK_LINK3].flags = MEDIA_PAD_FL_SINK;
+	err = media_entity_pads_init(&priv->sd.entity, MAX96712_N_PADS, priv->pads);
+	if (err)
+		return err;
+
+	/* Subdevice register */
+	ep = of_graph_get_endpoint_by_regs(client->dev.of_node, MAX96712_SOURCE, -1);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to retrieve endpoint on \"port@4\"\n");
+		return -ENOENT;
+	}
+	priv->sd.fwnode = of_fwnode_handle(ep);
+	v4l2_set_subdevdata(&priv->sd, priv);
+
+	of_node_put(ep);
+
+	err = v4l2_async_register_subdev(&priv->sd);
+	if (err < 0) {
+		dev_err(&client->dev, "Unable to register subdevice\n");
+		goto err_put_node;
+	}
+
+	return 0;
+
+err_put_node:
+	of_node_put(ep);
+	return err;
+}
+
+static int max96712_parse_dt(struct i2c_client *client)
+{
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	struct device_node *np = client->dev.of_node;
+	struct device_node *endpoint = NULL;
+	struct property *prop;
+	char name[16];
+	int i, csi_rate, err;
+	u32 addrs[4], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "regs", sizeof(u32));
+	err = of_property_read_u32_array(client->dev.of_node, "regs", addrs,
+					 naddrs);
+	if (err < 0) {
+		dev_err(&client->dev, "Invalid DT regs property\n");
+		return -EINVAL;
+	}
+
+	priv->n_links = naddrs;
+	for (i = 0; i < priv->n_links; i++)
+		priv->link[i]->ser_addr = addrs[i];
+
+	if (of_property_read_u32(np, "maxim,gmsl", &priv->gmsl_mode))
+		priv->gmsl_mode = MODE_GMSL2;
+	if (of_property_read_bool(np, "maxim,stp"))
+		priv->is_coax = 0;
+	else
+		priv->is_coax = 1;
+	if (of_property_read_u32(np, "maxim,resetb-gpio", &priv->gpio_resetb)) {
+		priv->gpio_resetb = -1;
+	} else {
+		if (of_property_read_bool(np, "maxim,resetb-active-high"))
+			priv->active_low_resetb = 0;
+		else
+			priv->active_low_resetb = 1;
+	}
+	if (of_property_read_u32(np, "maxim,fsync-period", &priv->fsync_period))
+		priv->fsync_period = 3210000;/* 96MHz/30fps */
+	priv->pclk_rising_edge = true;
+	if (of_property_read_bool(np, "maxim,pclk-falling-edge"))
+		priv->pclk_rising_edge = false;
+	if (of_property_read_u32(np, "maxim,timeout", &priv->timeout))
+		priv->timeout = 100;
+	if (of_property_read_u32(np, "maxim,him", &priv->him))
+		priv->him = 0;
+	if (of_property_read_u32(np, "maxim,bws", &priv->bws))
+		priv->bws = 0;
+	if (of_property_read_u32(np, "maxim,dbl", &priv->dbl))
+		priv->dbl = 1;
+	if (of_property_read_u32(np, "maxim,hven", &priv->hven))
+		priv->hven = 1;
+	if (of_property_read_u32(np, "maxim,hibw", &priv->hibw))
+		priv->hibw = 0;
+	if (of_property_read_u32(np, "maxim,hsync", &priv->hsync))
+		priv->hsync = 0;
+	if (of_property_read_u32(np, "maxim,vsync", &priv->vsync))
+		priv->vsync = 1;
+	if (of_property_read_u32(np, "maxim,poc-delay", &priv->poc_delay))
+		priv->poc_delay = 50;
+	if (of_property_read_u32(np, "maxim,dt", &priv->dt))
+		priv->dt = MIPI_DT_YUV8;
+	if (of_property_read_u64(np, "maxim,crossbar", &priv->crossbar))
+		priv->crossbar = crossbar;
+	if (of_property_read_string(np, "maxim,mbus", &priv->mbus))
+		priv->mbus = mbus_default;
+	for (i = 0; i < 11; i++) {
+		sprintf(name, "maxim,gpio%d", i);
+		if (of_property_read_u32(np, name, &priv->gpio[i]))
+			priv->gpio[i] = -1;
+	}
+
+	/* module params override dts */
+	if (gmsl != MODE_GMSL2)
+		priv->gmsl_mode = gmsl;
+	if (him)
+		priv->him = him;
+	if (fsync_period) {
+		priv->fsync_period = fsync_period;
+	//	priv->fsync_mode = fsync_mode_default;
+	}
+	if (hsync)
+		priv->hsync = hsync;
+	if (!vsync)
+		priv->vsync = vsync;
+	if (gpio_resetb)
+		priv->gpio_resetb = gpio_resetb;
+	if (active_low_resetb)
+		priv->active_low_resetb = active_low_resetb;
+	if (timeout_n)
+		priv->timeout = timeout_n;
+	if (poc_delay)
+		priv->poc_delay = poc_delay;
+	if (bws)
+		priv->bws = bws;
+	if (!dbl)
+		priv->dbl = dbl;
+	if (dt != MIPI_DT_YUV8)
+		priv->dt = dt;
+	//if (hsgen)
+	//	priv->hsgen = hsgen;
+	if (gpio0 >= 0)
+		priv->gpio[0] = gpio0;
+	if (gpio1 >= 0)
+		priv->gpio[1] = gpio1;
+	if (gpio7 >= 0)
+		priv->gpio[7] = gpio7;
+	if (gpio8 >= 0)
+		priv->gpio[8] = gpio8;
+	if (strcmp(mbus, "dvp"))
+		priv->mbus = mbus;
+
+	/* parse serializer crossbar setup */
+	for (i = 0; i < 16; i++) {
+		priv->cb[i] = priv->crossbar % 16;
+		priv->crossbar /= 16;
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		priv->link[i]->out_mipi = 1;	/* CSI default forwarding is to MIPI1 */
+		priv->link[i]->out_vc = i;	/* Default VC map: 0 1 2 3 */
+	}
+
+	prop = of_find_property(np, "maxim,links-mipi-map", NULL);
+	if (prop) {
+		const __be32 *map = NULL;
+		u32 val;
+
+		for (i = 0; i < priv->n_links; i++) {
+			map = of_prop_next_u32(prop, map, &val);
+			if (!map)
+				break;
+			if (val >= MAX96712_MAX_MIPI)
+				return -EINVAL;
+			priv->link[i]->out_mipi = val;
+		}
+	}
+
+	if (of_property_read_u32(np, "csi-rate", &csi_rate))
+		csi_rate = 1200;
+
+	for (i = 0; i < priv->n_links; i++)
+		priv->csi_rate[priv->link[i]->out_mipi] = csi_rate;
+
+	prop = of_find_property(np, "maxim,links-vc-map", NULL);
+	if (prop) {
+		const __be32 *map = NULL;
+		u32 val;
+
+		for (i = 0; i < priv->n_links; i++) {
+			map = of_prop_next_u32(prop, map, &val);
+			if (!map)
+				break;
+			if (val >= 4)
+				return -EINVAL;
+			priv->link[i]->out_vc = val;
+		}
+	}
+
+	dev_dbg(&client->dev, "Link# | MIPI rate | Map | VC\n");
+	for (i = 0; i < priv->n_links; i++)
+		dev_dbg(&client->dev, "%5d | %9d | %3d | %2d\n", i, priv->csi_rate[i], priv->link[i]->out_mipi, priv->link[i]->out_vc);
+
+	for_each_endpoint_of_node(np, endpoint) {
+		struct max96712_link *link;
+		struct of_endpoint ep;
+
+		of_graph_parse_endpoint(endpoint, &ep);
+		dev_dbg(&client->dev, "Endpoint %pOF on port %d", ep.local_node, ep.port);
+
+		if (ep.port > MAX96712_MAX_LINKS) {
+			dev_err(&client->dev, "Invalid endpoint %s on port %d",
+			of_node_full_name(ep.local_node), ep.port);
+			continue;
+		}
+
+		if (ep.port == MAX96712_SOURCE) {
+			struct v4l2_fwnode_endpoint v4l2_ep = { .bus_type = 0 };
+
+			err = v4l2_fwnode_endpoint_parse(of_fwnode_handle(endpoint), &v4l2_ep);
+			if (err) {
+				of_node_put(endpoint);
+				return err;
+			}
+
+			if (v4l2_ep.bus_type != V4L2_MBUS_CSI2_DPHY) {
+				dev_err(&client->dev, "Unsupported bus: %u\n", v4l2_ep.bus_type);
+				of_node_put(endpoint);
+				return -EINVAL;
+			}
+
+			priv->lanes = v4l2_ep.bus.mipi_csi2.num_data_lanes;
+
+			continue;
+		}
+
+		link = priv->link[ep.port];
+		link->fwnode = fwnode_graph_get_remote_endpoint(of_fwnode_handle(endpoint));
+		if (!link->fwnode) {
+			dev_err(&client->dev, "Endpoint %pOF has no remote endpoint connection\n", ep.local_node);
+			continue;
+		}
+
+		link->asd.match_type = V4L2_ASYNC_MATCH_FWNODE;
+		link->asd.match.fwnode = link->fwnode;
+		link->pad = ep.port;
+
+		priv->subdevs[ep.port] = &link->asd;
+	}
+
+	of_node_put(endpoint);
+
+	return 0;
+}
+
+static int max96712_probe(struct i2c_client *client,
+			  const struct i2c_device_id *did)
+{
+	struct max96712_priv *priv;
+	struct gpio_desc *pwdn_gpio;
+	int ret, i;
+	int val = 0;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	/* update client i2c addr for PnP case */
+	i = of_property_match_string(client->dev.of_node, "reg-names", "max96712");
+	if (i >= 0)
+		of_property_read_u32_index(client->dev.of_node, "reg", i, (unsigned int *)&client->addr);
+
+	priv->regmap = devm_regmap_init_i2c(client, &max96712_regmap[0]);
+	if (IS_ERR(priv->regmap))
+		return PTR_ERR(priv->regmap);
+
+	i2c_set_clientdata(client, priv);
+	priv->client = client;
+	atomic_set(&priv->use_count, 0);
+
+	priv->ref_clk = v4l2_clk_get(&client->dev, "ref_clk");
+	if (!IS_ERR(priv->ref_clk)) {
+		dev_info(&client->dev, "ref_clk = %luKHz", v4l2_clk_get_rate(priv->ref_clk) / 1000);
+		v4l2_clk_enable(priv->ref_clk);
+	}
+
+	pwdn_gpio = devm_gpiod_get_optional(&client->dev, "shutdown", GPIOD_OUT_HIGH);
+	if (!IS_ERR(pwdn_gpio)) {
+		udelay(5);
+		gpiod_set_value_cansleep(pwdn_gpio, 0);
+		usleep_range(3000, 5000);
+	}
+
+	des_read(MAX96712_DEV_ID, &val);
+	if (val != MAX96712_ID)
+		return -ENODEV;
+
+	for (i = 0; i < MAX96712_MAX_LINKS; i++) {
+		priv->link[i] = devm_kzalloc(&client->dev, sizeof(*priv->link[i]), GFP_KERNEL);
+		if (!priv->link[i])
+			return -ENOMEM;
+	}
+
+	ret = max96712_parse_dt(client);
+	if (ret)
+		goto out;
+
+	for (i = 0; i < priv->n_links; i++) {
+		char poc_name[10];
+
+		sprintf(poc_name, "poc%d", i);
+		priv->link[i]->poc_reg = devm_regulator_get(&client->dev, poc_name);
+		if (PTR_ERR(priv->link[i]->poc_reg) == -EPROBE_DEFER)
+			return -EPROBE_DEFER;
+	}
+
+	for (i = 0; i < priv->n_links; i++) {
+		priv->link[i]->client = i2c_new_dummy_device(client->adapter, priv->link[i]->ser_addr);
+		if (!priv->link[i]->client)
+			return -ENOMEM;
+
+		priv->link[i]->regmap = regmap_init_i2c(priv->link[i]->client, &max96712_regmap[priv->gmsl_mode]);
+		if (IS_ERR(priv->link[i]->regmap))
+			return PTR_ERR(priv->link[i]->regmap);
+	}
+
+	ret = max96712_i2c_mux_init(priv);
+	if (ret) {
+		dev_err(&client->dev, "Unable to initialize I2C multiplexer\n");
+		goto out;
+	}
+
+	ret = max96712_initialize(priv);
+	if (ret < 0)
+		goto out;
+
+	ret = max96712_v4l2_init(client);
+	if (ret < 0)
+		goto out;
+
+	/* FIXIT: v4l2_i2c_subdev_init re-assigned clientdata */
+	i2c_set_clientdata(client, priv);
+
+	priv->reboot_nb.notifier_call = max96712_reboot_notifier;
+	ret = register_reboot_notifier(&priv->reboot_nb);
+	if (ret) {
+		dev_err(&client->dev, "failed to register reboot notifier\n");
+		goto out;
+	}
+
+	//max96712_debug_add(priv);
+out:
+	return ret;
+}
+
+static int max96712_remove(struct i2c_client *client)
+{
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	int i;
+
+	//max96712_debug_remove(priv);
+	i2c_mux_del_adapters(priv->mux);
+	unregister_reboot_notifier(&priv->reboot_nb);
+
+	v4l2_async_notifier_unregister(&priv->notifier);
+	v4l2_async_notifier_cleanup(&priv->notifier);
+	v4l2_async_unregister_subdev(&priv->sd);
+
+	for (i = 0; i < priv->n_links; i++) {
+		if (!IS_ERR(priv->link[i]->poc_reg))
+			regulator_disable(priv->link[i]->poc_reg); /* POC power off */
+	}
+
+	return 0;
+}
+
+static const struct of_device_id max96712_dt_ids[] = {
+	{ .compatible = "maxim,max96712" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, max96712_dt_ids);
+
+static const struct i2c_device_id max96712_id[] = {
+	{ "max96712", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max96712_id);
+
+static struct i2c_driver max96712_i2c_driver = {
+	.driver	= {
+		.name		= "max96712",
+		.of_match_table	= of_match_ptr(max96712_dt_ids),
+	},
+	.probe		= max96712_probe,
+	.remove		= max96712_remove,
+	.id_table	= max96712_id,
+};
+
+module_i2c_driver(max96712_i2c_driver);
+
+MODULE_DESCRIPTION("GMSL2 driver for MAX96712");
+MODULE_AUTHOR("Andrey Gusakov, Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/gmsl/max96712.h b/drivers/media/i2c/gmsl/max96712.h
new file mode 100644
index 0000000..8224abc
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max96712.h
@@ -0,0 +1,288 @@
+/*
+ * MAXIM max96712 GMSL2 driver header
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define MAX96712_MAX_LINKS		4
+#define MAX96712_MAX_PIPES		8
+#define MAX96712_MAX_PIPE_MAPS		16
+#define MAX96712_MAX_MIPI		4
+
+enum max96712_pads {
+	MAX96712_SINK_LINK0,
+	MAX96712_SINK_LINK1,
+	MAX96712_SINK_LINK2,
+	MAX96712_SINK_LINK3,
+	MAX96712_SOURCE,
+	MAX96712_N_PADS,
+};
+
+struct max96712_link {
+	struct v4l2_async_subdev asd;
+	struct v4l2_subdev	*sd;
+	struct fwnode_handle	*fwnode;
+	int			pad;
+
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	int			ser_id;
+	int			ser_addr;
+	int			pipes_mask;	/* mask of pipes used by this link */
+	int			out_mipi;	/* MIPI# */
+	int			out_vc;		/* VC# */
+	struct regulator	*poc_reg;	/* PoC power supply */
+};
+
+#define asd_to_max96712_link(_asd) \
+	container_of(_asd, struct max96712_link, asd)
+
+struct max96712_priv {
+	struct i2c_client	*client;
+	struct regmap		*regmap;
+	struct v4l2_subdev	sd;
+	struct media_pad	pads[MAX96712_N_PADS];
+
+	struct i2c_mux_core	*mux;
+
+	int			n_links;
+	int			links_mask;
+	enum gmsl_mode		gmsl_mode;
+	struct max96712_link	*link[MAX96712_MAX_LINKS];
+	struct v4l2_async_subdev *subdevs[MAX96712_MAX_LINKS];
+	struct v4l2_async_notifier notifier;
+	struct v4l2_ctrl_handler ctrls;
+
+	int			gpio_resetb;
+	int			active_low_resetb;
+	bool			pclk_rising_edge;
+	bool			is_coax;
+	int			him;
+	int			bws;
+	int			dbl;
+	int			hibw;
+	int			hven;
+	int			hsync;
+	int			vsync;
+	int			dt;
+	u64			crossbar;
+	char			cb[16];
+	const char		*mbus;
+	int			gpio[11];
+	int			timeout;
+	int			poc_delay;
+	struct v4l2_clk		*ref_clk;
+	int			lanes;
+	int			csi_rate[MAX96712_MAX_MIPI];
+	int			fsync_period;
+	atomic_t		use_count;
+	struct notifier_block	reboot_nb;
+};
+
+#define MAX96712_REG4			0x04
+#define MAX96712_REG5			0x05
+#define MAX96712_REG6			0x06
+#define MAX96712_REG14			0x0e
+#define MAX96712_REG26			0x10
+#define MAX96712_REG27			0x11
+
+#define MAX96712_CTRL0			0x17
+#define MAX96712_CTRL1			0x18
+#define MAX96712_CTRL2			0x19
+#define MAX96712_CTRL3			0x1a
+#define MAX96712_CTRL11			0x22
+#define MAX96712_CTRL12			0x0a
+#define MAX96712_CTRL13			0x0b
+#define MAX96712_CTRL14			0x0c
+
+#define MAX96712_PWR1			0x13
+
+#define MAX96712_DEV_ID			0x4a
+#define MAX96712_REV			0x4c
+
+#define MAX96712_VIDEO_PIPE_SEL(n)	(0xf0 + n)
+#define MAX96712_VIDEO_PIPE_EN		0xf4
+
+#define MAX96712_I2C_0(n)		(0x640 + (0x10 * n))
+#define MAX96712_I2C_1(n)		(0x641 + (0x10 * n))
+
+#define MAX96712_RX0(n)			(0x50 + n)
+
+#define MAX_VIDEO_RX_BASE(n)		(n < 5 ? (0x100 + (0x12 * n)) : \
+						 (0x160 + (0x12 * (n - 5))))
+#define MAX_VIDEO_RX0(n)		(MAX_VIDEO_RX_BASE(n) + 0x00)
+#define MAX_VIDEO_RX3(n)		(MAX_VIDEO_RX_BASE(n) + 0x03)
+#define MAX_VIDEO_RX8(n)		(MAX_VIDEO_RX_BASE(n) + 0x08)
+#define MAX_VIDEO_RX10(n)		(MAX_VIDEO_RX_BASE(n) + 0x0a)
+
+#define MAX_VPRBS(n)			(0x1dc + (0x20 * n))
+
+#define MAX_CROSS_BASE(n)		(0x1c0 + (0x20 * n))
+#define MAX_CROSS(n, m)			(MAX_CROSS_BASE(n) + m)
+
+#define MAX_BACKTOP_BASE(bank)		(0x400 + (0x20 * bank))
+#define MAX_BACKTOP1(bank)		(MAX_BACKTOP_BASE(bank) + 0x00)
+#define MAX_BACKTOP11(bank)		(MAX_BACKTOP_BASE(bank) + 0x0a)
+#define MAX_BACKTOP12(bank)		(MAX_BACKTOP_BASE(bank) + 0x0b)
+#define MAX_BACKTOP13(bank)		(MAX_BACKTOP_BASE(bank) + 0x0c)
+#define MAX_BACKTOP14(bank)		(MAX_BACKTOP_BASE(bank) + 0x0d)
+#define MAX_BACKTOP15(bank)		(MAX_BACKTOP_BASE(bank) + 0x0e)
+#define MAX_BACKTOP16(bank)		(MAX_BACKTOP_BASE(bank) + 0x0f)
+#define MAX_BACKTOP17(bank)		(MAX_BACKTOP_BASE(bank) + 0x10)
+#define MAX_BACKTOP18(bank)		(MAX_BACKTOP_BASE(bank) + 0x11)
+#define MAX_BACKTOP19(bank)		(MAX_BACKTOP_BASE(bank) + 0x12)
+#define MAX_BACKTOP20(bank)		(MAX_BACKTOP_BASE(bank) + 0x13)
+#define MAX_BACKTOP21(bank)		(MAX_BACKTOP_BASE(bank) + 0x14)
+#define MAX_BACKTOP22(bank)		(MAX_BACKTOP_BASE(bank) + 0x15)
+#define MAX_BACKTOP23(bank)		(MAX_BACKTOP_BASE(bank) + 0x16)
+#define MAX_BACKTOP24(bank)		(MAX_BACKTOP_BASE(bank) + 0x17)
+#define MAX_BACKTOP25(bank)		(MAX_BACKTOP_BASE(bank) + 0x18)
+#define MAX_BACKTOP26(bank)		(MAX_BACKTOP_BASE(bank) + 0x19)
+#define MAX_BACKTOP27(bank)		(MAX_BACKTOP_BASE(bank) + 0x1a)
+#define MAX_BACKTOP28(bank)		(MAX_BACKTOP_BASE(bank) + 0x1b)
+#define MAX_BACKTOP29(bank)		(MAX_BACKTOP_BASE(bank) + 0x1c)
+#define MAX_BACKTOP30(bank)		(MAX_BACKTOP_BASE(bank) + 0x1d)
+#define MAX_BACKTOP31(bank)		(MAX_BACKTOP_BASE(bank) + 0x1e)
+#define MAX_BACKTOP32(bank)		(MAX_BACKTOP_BASE(bank) + 0x1f)
+
+#define MAX96712_FSYNC_0		0x4a0
+#define MAX96712_FSYNC_5		0x4a5
+#define MAX96712_FSYNC_6		0x4a6
+#define MAX96712_FSYNC_7		0x4a7
+#define MAX96712_FSYNC_8		0x4a8
+#define MAX96712_FSYNC_9		0x4a9
+#define MAX96712_FSYNC_10		0x4aa
+#define MAX96712_FSYNC_11		0x4ab
+#define MAX96712_FSYNC_15		0x4af
+#define MAX96712_FSYNC_17		0x4b1
+
+#define MAX_MIPI_PHY_BASE		0x8a0
+#define MAX_MIPI_PHY0			(MAX_MIPI_PHY_BASE + 0x00)
+#define MAX_MIPI_PHY2			(MAX_MIPI_PHY_BASE + 0x02)
+#define MAX_MIPI_PHY3			(MAX_MIPI_PHY_BASE + 0x03)
+#define MAX_MIPI_PHY4			(MAX_MIPI_PHY_BASE + 0x04)
+#define MAX_MIPI_PHY5			(MAX_MIPI_PHY_BASE + 0x05)
+#define MAX_MIPI_PHY6			(MAX_MIPI_PHY_BASE + 0x06)
+#define MAX_MIPI_PHY8			(MAX_MIPI_PHY_BASE + 0x08)
+#define MAX_MIPI_PHY9			(MAX_MIPI_PHY_BASE + 0x09)
+#define MAX_MIPI_PHY10			(MAX_MIPI_PHY_BASE + 0x0a)
+#define MAX_MIPI_PHY11			(MAX_MIPI_PHY_BASE + 0x0b)
+#define MAX_MIPI_PHY13			(MAX_MIPI_PHY_BASE + 0x0d)
+#define MAX_MIPI_PHY14			(MAX_MIPI_PHY_BASE + 0x0e)
+
+#define MAX_MIPI_TX_BASE(n)		(0x900 + 0x40 * n)
+#define MAX_MIPI_TX2(n)			(MAX_MIPI_TX_BASE(n) + 0x02)
+#define MAX_MIPI_TX10(n)		(MAX_MIPI_TX_BASE(n) + 0x0a)
+#define MAX_MIPI_TX11(n)		(MAX_MIPI_TX_BASE(n) + 0x0b)
+#define MAX_MIPI_TX12(n)		(MAX_MIPI_TX_BASE(n) + 0x0c)
+
+/* 16 pairs of source-dest registers */
+#define MAX_MIPI_MAP_SRC(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x0d + (2 * n))
+#define MAX_MIPI_MAP_DST(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x0e + (2 * n))
+/* Phy dst. Each reg contains 4 dest */
+#define MAX_MIPI_MAP_DST_PHY(pipe, n)	(MAX_MIPI_TX_BASE(pipe) + 0x2d + n)
+
+#define MAX_GMSL1_2(ch)			(0xb02 + (0x100 * ch))
+#define MAX_GMSL1_4(ch)			(0xb04 + (0x100 * ch))
+#define MAX_GMSL1_6(ch)			(0xb06 + (0x100 * ch))
+#define MAX_GMSL1_7(ch)			(0xb07 + (0x100 * ch))
+#define MAX_GMSL1_8(ch)			(0xb08 + (0x100 * ch))
+#define MAX_GMSL1_D(ch)			(0xb0d + (0x100 * ch))
+#define MAX_GMSL1_F(ch)			(0xb0f + (0x100 * ch))
+#define MAX_GMSL1_19(ch)		(0xb19 + (0x100 * ch))
+#define MAX_GMSL1_1B(ch)		(0xb1b + (0x100 * ch))
+#define MAX_GMSL1_1D(ch)		(0xb1d + (0x100 * ch))
+#define MAX_GMSL1_20(ch)		(0xb20 + (0x100 * ch))
+#define MAX_GMSL1_96(ch)		(0xb96 + (0x100 * ch))
+#define MAX_GMSL1_CA(ch)		(0xbca + (0x100 * ch))
+#define MAX_GMSL1_CB(ch)		(0xbcb + (0x100 * ch))
+
+#define MAX_RLMS4(ch)			(0x1404 + (0x100 * ch))
+#define MAX_RLMSA(ch)			(0x140A + (0x100 * ch))
+#define MAX_RLMSB(ch)			(0x140B + (0x100 * ch))
+#define MAX_RLMSA4(ch)			(0x14a4 + (0x100 * ch))
+
+#define MAX_RLMS58(ch)			(0x1458 + (0x100 * ch))
+#define MAX_RLMS59(ch)			(0x1459 + (0x100 * ch))
+#define MAX_RLMS95(ch)			(0x1495 + (0x100 * ch))
+#define MAX_RLMSC4(ch)			(0x14c4 + (0x100 * ch))
+#define MAX_RLMSC5(ch)			(0x14c5 + (0x100 * ch))
+
+static inline int max96712_write(struct max96712_priv *priv, int reg, int val)
+{
+	int ret;
+
+	ret = regmap_write(priv->regmap, reg, val);
+	if (ret)
+		dev_dbg(&priv->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_read(struct max96712_priv *priv, int reg, int *val)
+{
+	int ret;
+
+	ret = regmap_read(priv->regmap, reg, val);
+	if (ret)
+		dev_dbg(&priv->client->dev, "read register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_update_bits(struct max96712_priv *priv, int reg, int mask, int bits)
+{
+	int ret;
+
+	ret = regmap_update_bits(priv->regmap, reg, mask, bits);
+	if (ret)
+		dev_dbg(&priv->client->dev, "update register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+#define des_read(reg, val)			max96712_read(priv, reg, val)
+#define des_write(reg, val)			max96712_write(priv, reg, val)
+#define des_update_bits(reg, mask, bits)	max96712_update_bits(priv, reg, mask, bits)
+
+static inline int max96712_ser_write(struct max96712_link *link, int reg, int val)
+{
+	int ret;
+
+	ret = regmap_write(link->regmap, reg, val);
+	if (ret < 0)
+		dev_dbg(&link->client->dev, "write register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_ser_read(struct max96712_link *link, int reg, int *val)
+{
+	int ret;
+
+	ret = regmap_read(link->regmap, reg, val);
+	if (ret)
+		dev_dbg(&link->client->dev, "read register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+static inline int max96712_ser_update_bits(struct max96712_link *link, int reg, int mask, int bits)
+{
+	int ret;
+
+	ret = regmap_update_bits(link->regmap, reg, mask, bits);
+	if (ret)
+		dev_dbg(&link->client->dev, "update register 0x%04x failed (%d)\n", reg, ret);
+
+	return ret;
+}
+
+#define ser_read(reg, val)			max96712_ser_read(link, reg, (int *)val)
+#define ser_write(reg, val)			max96712_ser_write(link, reg, val)
+#define ser_update_bits(reg, mask, bits)	max96712_ser_update_bits(link, reg, mask, bits)
diff --git a/drivers/media/i2c/gmsl/max96712_debug.h b/drivers/media/i2c/gmsl/max96712_debug.h
new file mode 100644
index 0000000..ee47c04
--- /dev/null
+++ b/drivers/media/i2c/gmsl/max96712_debug.h
@@ -0,0 +1,362 @@
+/*
+ * MAXIM max96712 GMSL2 driver debug stuff
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+static char *pipe_names[4] = {
+	"X", "Y", "Z", "U"
+};
+
+static int max96712_gmsl1_get_link_lock(struct max96712_priv *priv, int link_n);
+static int max96712_gmsl2_get_link_lock(struct max96712_priv *priv, int link_n);
+
+#define reg_bits(x, y)	((reg >> (x)) & ((1 << (y)) - 1))
+
+static ssize_t max_link_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	int i = -1;
+	int j;
+	int gmsl2;
+	u32 crc = 0 ;
+	char *_buf = buf;
+	int reg = 0;
+
+	if (!sscanf(attr->attr.name, "link_%d", &i))
+		return -EINVAL;
+
+	if (i < 0)
+		return -EINVAL;
+
+	if (i >= priv->n_links) {
+		buf += sprintf(buf, "\n");
+		return (buf - _buf);
+	}
+
+	buf += sprintf(buf, "Link %c status\n", 'A' + i);
+
+	des_read(MAX96712_REG6, &reg);
+	gmsl2 = !!(reg & BIT(4 + i));
+	buf += sprintf(buf, "Link mode: %s\n", gmsl2 ? "GMSL2" : "GMSL1");
+
+	if (gmsl2) {
+		buf += sprintf(buf, "GMSL2 Link lock: %d\n", max96712_gmsl2_get_link_lock(priv, i));
+	} else {
+		reg = max96712_gmsl1_get_link_lock(priv, i);
+		buf += sprintf(buf,
+				"GMSL1_CB: 0x%02x:\t"
+				"LOCKED_G1: %d\n",
+				reg, reg_bits(0, 1));
+
+		des_read(MAX_GMSL1_CA(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_CA: 0x%02x:\t"
+				"PHASELOCK: %d, WBLOCK_G1: %d, DATAOK: %d\n",
+				reg, reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+
+		des_read(MAX_GMSL1_1B(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_1B: 0x%02x:\t"
+				"LINE_CRC_ERR: %d ",
+				reg, reg_bits(2, 1));
+		for (j = 0; j < 4; j++) {
+			des_read(MAX_GMSL1_20(i) + j, &reg);
+			crc = crc | ((reg & 0xff) << (j * 8));
+		}
+		buf += sprintf(buf, "last crc 0x%08x\n", crc);
+
+		des_read(MAX_GMSL1_19(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_19: CC_CRC_ERRCNT %d\n",
+				reg);
+
+		des_read(MAX_GMSL1_1D(i), &reg);
+		buf += sprintf(buf,
+				"GMSL1_1D: 0x%02x:\t"
+				"UNDERBOOST: %d, AEQ-BST: %d\n",
+				reg, reg_bits(4, 1), reg_bits(0, 4));
+	}
+
+	return (buf - _buf);
+}
+
+static ssize_t max_pipe_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	char *_buf = buf;
+	int pipe = 0;
+	int map;
+	int maps_en = 0;
+	int pipes_en;
+	int reg = 0;
+	int shift;
+
+	if (!sscanf(attr->attr.name, "pipe_%d", &pipe))
+		return -EINVAL;
+
+	if (pipe < 0)
+		return -EINVAL;
+
+	if (pipe >= MAX96712_MAX_PIPES) {
+		buf += sprintf(buf, "\n");
+		return (buf - _buf);
+	}
+
+	des_read(MAX96712_VIDEO_PIPE_EN, &pipes_en);
+
+	buf += sprintf(buf, "Video Pipe %d %s\n",
+		pipe, (pipes_en & BIT(pipe)) ? "ENABLED" : "disabled");
+	if (!(pipes_en & BIT(pipe)))
+		goto out;
+
+	des_read(MAX_VPRBS(pipe), &reg);
+	/* bit 5 is not valid for MAX96712 */
+	buf += sprintf(buf,
+			"\tVPRBS: 0x%02x\t"
+			"VPRBS_FAIL: %d,"
+			"VIDEO_LOCK: %d\n",
+			reg,
+			reg_bits(5, 1), reg_bits(0, 1));
+
+	/* show source */
+	shift = (pipe % 2) * 4;
+	des_read(MAX96712_VIDEO_PIPE_SEL(pipe / 2), &reg);
+	buf += sprintf(buf, "SRC: PHY %c, PIPE %s\n",
+		'A' + (char)((reg >> (shift + 2)) & 0x03),
+		pipe_names[(reg >> shift) & 0x03]);
+
+	/* show maps */
+	des_read(MAX_MIPI_TX11(pipe), &maps_en);
+	des_read(MAX_MIPI_TX12(pipe), &reg);
+	maps_en |= reg << 8;
+
+	for (map = 0; map < MAX96712_MAX_PIPE_MAPS; map++) {
+		int src, dst, mipi;
+		if (!(maps_en & BIT(map)))
+			continue;
+
+		des_read(MAX_MIPI_MAP_SRC(pipe, map), &src);
+		des_read(MAX_MIPI_MAP_DST(pipe, map), &dst);
+		des_read(MAX_MIPI_MAP_DST_PHY(pipe, map / 4), &mipi);
+
+		buf += sprintf(buf, " MAP%d: DT %02x, VC %d -> DT %02x, VC %d MIPI %d\n",
+			map,
+			src & 0x3f, (src >> 6) & 0x03, dst & 0x3f, (dst >> 6) & 0x03,
+			(mipi >> ((map % 4) * 2)) & 0x03);
+	}
+
+	des_read(MAX_VIDEO_RX0(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX0: 0x%02x\t"
+			"LCRC_ERR: %d, "
+			"LINE_CRC_SEL: %d, "
+			"LINE_CRC_EN: %d, "
+			"DIS_PKT_DET: %d\n",
+			reg,
+			reg_bits(7, 1),
+			reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+	des_read(MAX_VIDEO_RX3(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX3: 0x%02x\t"
+			"HD_TR_MODE: %d, "
+			"DLOCKED: %d, "
+			"VLOCKED: %d, "
+			"HLOCKED: %d, "
+			"DTRACKEN: %d, "
+			"VTRACKEN: %d, "
+			"HTRACKEN: %d\n",
+			reg,
+			reg_bits(6, 1),
+			reg_bits(5, 1), reg_bits(4, 1), reg_bits(3, 1),
+			reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+	des_read(MAX_VIDEO_RX8(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX8: 0x%02x\t"
+			"VID_BLK_LEN_ERR: %d, "
+			"VID_LOCK: %d, "
+			"VID_PKT_DET: %d, "
+			"VID_SEQ_ERR: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1),
+			reg_bits(5, 1), reg_bits(4, 1));
+	des_read(MAX_VIDEO_RX10(pipe), &reg);
+	buf += sprintf(buf,
+			"VIDEO_RX10: 0x%02x\t"
+			"MASK_VIDEO_DE: %d\n",
+			reg,
+			reg_bits(6, 1));
+
+out:
+	return (buf - _buf);
+}
+
+static ssize_t max_stat_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct max96712_priv *priv = i2c_get_clientdata(client);
+	int i;
+	char *_buf = buf;
+	int reg = 0;
+
+	/* TODO: add same for 96712 */
+	des_read(MAX96712_REG4, &reg);
+	buf += sprintf(buf,
+			"REG_REG4: 0x%02x\t"
+			"LOCK_CFG: %d\n",
+			reg, reg_bits(5, 1));
+
+	des_read(MAX_BACKTOP1(0), &reg);
+	buf += sprintf(buf,
+			"BACKTOP1: 0x%02x:\t"
+			"CSIPLL3_LOCK: %d, "
+			"CSIPLL2_LOCK: %d, "
+			"CSIPLL1_LOCK: %d, "
+			"CSIPLL0_LOCK: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1));
+
+	des_read(MAX_BACKTOP11(0), &reg);
+	buf += sprintf(buf,
+			"BACKTOP11: 0x%02x:\t"
+			"CMD_OWERFLOW4: %d, "
+			"CMD_OWERFLOW3: %d, "
+			"CMD_OWERFLOW2: %d, "
+			"CMD_OWERFLOW1: %d, "
+			"LMO_3: %d, "
+			"LMO_2: %d, "
+			"LMO_1: %d, "
+			"LMO_0: %d\n",
+			reg,
+			reg_bits(7, 1), reg_bits(6, 1), reg_bits(5, 1), reg_bits(4, 1),
+			reg_bits(3, 1), reg_bits(2, 1), reg_bits(1, 1), reg_bits(0, 1));
+
+	for (i = 0; i < MAX96712_MAX_MIPI; i++) {
+		buf += sprintf(buf, "MIPI %d\n", i);
+		des_read(MAX_MIPI_TX2(i), &reg);
+		buf += sprintf(buf,
+				"\tMIPI_TX2: 0x%02x\n",
+				reg);
+	}
+
+	return (buf - _buf);
+}
+
+static DEVICE_ATTR(link_0, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_1, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_2, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(link_3, S_IRUGO, max_link_show, NULL);
+static DEVICE_ATTR(pipe_0, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_1, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_2, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_3, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_4, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_5, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_6, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(pipe_7, S_IRUGO, max_pipe_show, NULL);
+static DEVICE_ATTR(stat, S_IRUGO, max_stat_show, NULL);
+
+static struct attribute *max96712_attributes[] = {
+	&dev_attr_link_0.attr,
+	&dev_attr_link_1.attr,
+	&dev_attr_link_2.attr,
+	&dev_attr_link_3.attr,
+	&dev_attr_pipe_0.attr,
+	&dev_attr_pipe_1.attr,
+	&dev_attr_pipe_2.attr,
+	&dev_attr_pipe_3.attr,
+	&dev_attr_pipe_4.attr,
+	&dev_attr_pipe_5.attr,
+	&dev_attr_pipe_6.attr,
+	&dev_attr_pipe_7.attr,
+	&dev_attr_stat.attr,
+	NULL
+};
+
+static const struct attribute_group max96712_group = {
+	.attrs = max96712_attributes,
+};
+
+int max96712_debug_add(struct max96712_priv *priv)
+{
+	int ret;
+
+	ret = sysfs_create_group(&priv->client->dev.kobj,  &max96712_group);
+	if (ret < 0) {
+		dev_err(&priv->client->dev, "Sysfs registration failed\n");
+		return ret;
+	}
+
+	return ret;
+}
+
+void max96712_debug_remove(struct max96712_priv *priv)
+{
+	sysfs_remove_group(&priv->client->dev.kobj, &max96712_group);
+}
+
+#if 0
+int max96712_patgen(struct max96712_priv *priv)
+{
+	int ret = 0;
+
+	const u32 xres = 1280;
+	const u32 yres = 800;
+	const u32 hbp = 128;
+	const u32 hfp = 80;
+	const u32 hsa = 32;
+	const u32 vbp = 17;
+	const u32 vfp = 4;
+	const u32 vsa = 3;
+
+	u32 vtotal = vfp + vsa + vbp + yres;
+	u32 htotal = xres + hfp + hbp + hsa;
+	u32 vs_high = vsa * htotal;
+	u32 vs_low = (vfp + yres + vbp) * htotal;
+	u32 v2h = (vsa + vbp) * htotal + hfp;
+	u32 hs_high = hsa;
+	u32 hs_low = xres + hfp + hbp;
+	u32 v2d = v2h + hsa + hbp;
+	u32 de_high = xres;
+	u32 de_low = hfp + hsa + hbp;
+	u32 de_cnt = yres;
+
+	/* DEBUG_EXTRA & PATGEN_CLK_SRC = 75Mhz pclk */
+	des_write(0x0009, 0x01); /* if DEBUG_EXTRA[1:0] = 2b01, PCLK Frequency is 75MHz (don't care PATGEN_CLK_SRC) */
+	des_write(0x01dc, 0x00);
+
+	des_write_n(0x1052, 3, 0);		/* vs delay */
+	des_write_n(0x1055, 3, vs_high);
+	des_write_n(0x1058, 3, vs_low);
+	des_write_n(0x105B, 3, v2h);
+	des_write_n(0x105E, 2, hs_high);
+	des_write_n(0x1060, 2, hs_low);
+	des_write_n(0x1062, 2, vtotal);		/* hs cnt */
+	des_write_n(0x1064, 3, v2d);
+	des_write_n(0x1067, 2, de_high);
+	des_write_n(0x1069, 2, de_low);
+	des_write_n(0x106B, 2, de_cnt);
+
+	des_write_n(0x106E, 3, 0xff0000);	/* color A */
+	des_write_n(0x1071, 3, 0x0000ff);	/* color B */
+
+	des_write(0x1074, 0x50);	/* chkr_rpt_a = 80 */
+	des_write(0x1075, 0x50);	/* chkr_rpt_b = 80 */
+	des_write(0x1076, 0x50);	/* chkr_alt = 80 */
+
+	des_write(0x1050, 0xfb);	/* gen_vs,gen_hs,gen_de, vtg[0:1] */
+	des_write(0x1051, 0x10);	/* patgen_mode[5:4] = 0b1,checkerboard */
+
+out:
+	return ret;
+}
+#endif
diff --git a/drivers/media/i2c/imagers/Kconfig b/drivers/media/i2c/imagers/Kconfig
new file mode 100644
index 0000000..8bd402f
--- /dev/null
+++ b/drivers/media/i2c/imagers/Kconfig
@@ -0,0 +1,13 @@
+#
+# LVDS camera video device configuration
+#
+
+config VIDEO_LVDS_CAMERA
+	tristate "LVDS camera support"
+	depends on I2C && VIDEO_V4L2_SUBDEV_API && MEDIA_CONTROLLER
+	select V4L2_FWNODE
+	help
+	  This is a GMSL/FPDLink cameras support
+
+	  This camera should be used in conjunction with a GMSL or
+	  or FPDLink deserialiser
diff --git a/drivers/media/i2c/imagers/Makefile b/drivers/media/i2c/imagers/Makefile
new file mode 100644
index 0000000..5617bc1
--- /dev/null
+++ b/drivers/media/i2c/imagers/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0101.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ap0201.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= isx016.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= isx019.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov10635.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov2311.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov490.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= ov495.o
+obj-$(CONFIG_VIDEO_LVDS_CAMERA)	+= dummy.o
diff --git a/drivers/media/i2c/imagers/ap0101.c b/drivers/media/i2c/imagers/ap0101.c
new file mode 100644
index 0000000..2a67d5d
--- /dev/null
+++ b/drivers/media/i2c/imagers/ap0101.c
@@ -0,0 +1,639 @@
+/*
+ * ON Semiconductor AP0101-AR014X sensor camera driver
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ap0101.h"
+
+static const int ap0101_i2c_addr[] = {0x5d, 0x48};
+
+#define AP0101_PID_REG		0x0000
+#define AP0101_REV_REG		0x0058
+#define AP0100_PID		0x0062
+#define AP0101_PID		0x0160
+#define AP0102_PID		0x0064
+
+#define AP0101_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ap0101_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				hts;
+	int				vts;
+	int				frame_preamble;
+};
+
+static inline struct ap0101_priv *to_ap0101(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ap0101_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ap0101_priv, hdl)->sd;
+}
+
+static int ap0101_set_regs(struct i2c_client *client,
+			   const struct ap0101_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == AP0101_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		reg16_write16(client, regs[i].reg, regs[i].val);
+	}
+
+	return 0;
+}
+
+static u16 ap0101_ar014x_read(struct i2c_client *client, u16 addr)
+{
+	u16 reg_val = 0;
+
+	reg16_write16(client, 0x0040, 0x8d00);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0xfc00, addr);
+	reg16_write16(client, 0xfc02, 0x0200); /* 2 bytes */
+	reg16_write16(client, 0x0040, 0x8d05);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d08);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_read16(client, 0xfc00, &reg_val);
+	reg16_write16(client, 0x0040, 0x8d02);
+	usleep_range(1000, 1500); /* wait 1000 us */
+
+	return reg_val;
+}
+
+static void ap0101_ar014x_write(struct i2c_client *client, u16 addr, u16 val)
+{
+	reg16_write16(client, 0x0040, 0x8d00);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0xfc00, addr);
+	reg16_write16(client, 0xfc02, 0x0200 | (val >> 8)); /* 2 bytes */
+	reg16_write16(client, 0xfc04, (val & 0xff) << 8);
+	reg16_write16(client, 0x0040, 0x8d06);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d08);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d02);
+	usleep_range(1000, 1500); /* wait 1000 us */
+}
+
+static void ap0101_otp_id_read(struct i2c_client *client)
+{
+	struct ap0101_priv *priv = to_ap0101(client);
+	int i;
+
+	/* read camera id from ar014x OTP memory */
+	ap0101_ar014x_write(client, 0x3054, 0x400);
+	ap0101_ar014x_write(client, 0x304a, 0x110);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i += 2) {
+		/* first 4 bytes are equal on all ar014x */
+		priv->id[i]     = (ap0101_ar014x_read(client, 0x3800 + i + 4) >> 8)   ^ (ap0101_ar014x_read(client, 0x3800 + i + 16) >> 8);
+		priv->id[i + 1] = (ap0101_ar014x_read(client, 0x3800 + i + 4) & 0xff) ^ (ap0101_ar014x_read(client, 0x3800 + i + 16) & 0xff);
+	}
+}
+
+static int ap0101_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ap0101_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = AP0101_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ap0101_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = AP0101_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ap0101_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = AP0101_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ap0101_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	ap0101_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = AP0101_PID >> 8;
+	edid->edid[9] = AP0101_PID & 0xff;
+
+	return 0;
+}
+
+static int ap0101_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ap0101_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ap0101_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ap0101_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u16);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ap0101_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u16);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	return reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+}
+#endif
+
+static struct v4l2_subdev_core_ops ap0101_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ap0101_g_register,
+	.s_register = ap0101_s_register,
+#endif
+};
+
+static int ap0101_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+	int ret = -EINVAL;
+	u16 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		break;
+	case V4L2_CID_HFLIP:
+		reg16_read16(client, 0xc846, &val);
+		if (ctrl->val)
+			val |= 0x01;
+		else
+			val &= ~0x01;
+		reg16_write16(client, 0xc846, val);
+		reg16_write16(client, 0xfc00, 0x2800);
+		ret = reg16_write16(client, 0x0040, 0x8100);
+		break;
+	case V4L2_CID_VFLIP:
+		reg16_read16(client, 0xc846, &val);
+		if (ctrl->val)
+			val |= 0x02;
+		else
+			val &= ~0x02;
+		reg16_write16(client, 0xc846, val);
+		reg16_write16(client, 0xfc00, 0x2800);
+		ret = reg16_write16(client, 0x0040, 0x8100);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ap0101_ctrl_ops = {
+	.s_ctrl = ap0101_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ap0101_video_ops = {
+	.s_stream	= ap0101_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ap0101_subdev_pad_ops = {
+	.get_edid	= ap0101_get_edid,
+	.enum_mbus_code	= ap0101_enum_mbus_code,
+	.get_selection	= ap0101_get_selection,
+	.set_selection	= ap0101_set_selection,
+	.get_fmt	= ap0101_get_fmt,
+	.set_fmt	= ap0101_set_fmt,
+	.get_mbus_config	= ap0101_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ap0101_subdev_ops = {
+	.core	= &ap0101_core_ops,
+	.video	= &ap0101_video_ops,
+	.pad	= &ap0101_subdev_pad_ops,
+};
+
+static ssize_t ap0101_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0101_priv *priv = to_ap0101(client);
+
+	ap0101_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ap0101, S_IRUGO, ap0101_otp_id_show, NULL);
+
+static int ap0101_initialize(struct i2c_client *client)
+{
+	struct ap0101_priv *priv = to_ap0101(client);
+	u16 pid = 0, rev = 0, val = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ap0101_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, ap0101_i2c_addr[i]);
+
+		/* check model ID */
+		reg16_read16(client, AP0101_PID_REG, &pid);
+		if (pid == AP0101_PID)
+			break;
+	}
+
+	if (pid != AP0101_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	reg16_read16(client, AP0101_REV_REG, &rev);
+#if 1
+	/* read resolution used by current firmware */
+	reg16_read16(client, 0xca90, &val);
+	priv->max_width = val;
+	reg16_read16(client, 0xca92, &val);
+	priv->max_height = val;
+#else
+	priv->max_width = AP0101_MAX_WIDTH;
+	priv->max_height = AP0101_MAX_HEIGHT;
+#endif
+	/* Program wizard registers */
+	switch (pid) {
+	case AP0100_PID:
+	case AP0101_PID:
+		ap0101_set_regs(client, ap0101_regs, ARRAY_SIZE(ap0101_regs));
+		break;
+	case AP0102_PID:
+		ap0101_set_regs(client, ap0102_regs, ARRAY_SIZE(ap0102_regs));
+		break;
+	}
+	/* Read OTP IDs */
+	ap0101_otp_id_read(client);
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		/* setup serializer HS generator */
+		priv->frame_preamble = 5;
+		priv->hts = 1280 * 2 + 548;
+		priv->vts = 960;
+		reg8_write_addr(client, priv->ser_addr, 0x4e, priv->frame_preamble >> 16);	/* HS delay */
+		reg8_write_addr(client, priv->ser_addr, 0x4f, (priv->frame_preamble >> 8) & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x50, priv->frame_preamble & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x54, (priv->max_width * 2) >> 8);	/* HS high period */
+		reg8_write_addr(client, priv->ser_addr, 0x55, (priv->max_width * 2) & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x56, (priv->hts - priv->max_width * 2) >> 8); /* HS low period */
+		reg8_write_addr(client, priv->ser_addr, 0x57, (priv->hts - priv->max_width * 2) & 0xff);
+		reg8_write_addr(client, priv->ser_addr, 0x58, priv->vts >> 8);			/* HS count */
+		reg8_write_addr(client, priv->ser_addr, 0x59, priv->vts & 0xff);
+		break;
+	}
+
+	dev_info(&client->dev, "PID %x (%x), res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, rev, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ap0101_parse_dt(struct device_node *np, struct ap0101_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ap0101_probe(struct i2c_client *client,
+		        const struct i2c_device_id *did)
+{
+	struct ap0101_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ap0101_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 1);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ap0101_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ap0101_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ap0101_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ap0101) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ap0101_remove(struct i2c_client *client)
+{
+	struct ap0101_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ap0101);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ap0101_id[] = {
+	{ "ap0101", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ap0101_id);
+
+static const struct of_device_id ap0101_of_ids[] = {
+	{ .compatible = "onnn,ap0101", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ap0101_of_ids);
+
+static struct i2c_driver ap0101_i2c_driver = {
+	.driver	= {
+		.name		= "ap0101",
+		.of_match_table	= ap0101_of_ids,
+	},
+	.probe		= ap0101_probe,
+	.remove		= ap0101_remove,
+	.id_table	= ap0101_id,
+};
+
+module_i2c_driver(ap0101_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for AP0101");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ap0101.h b/drivers/media/i2c/imagers/ap0101.h
new file mode 100644
index 0000000..2dd0fdf
--- /dev/null
+++ b/drivers/media/i2c/imagers/ap0101.h
@@ -0,0 +1,36 @@
+/*
+ * ON Semiconductor ap0101-ar014x sensor camera setup 1280x720@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define AP0101_MAX_WIDTH	1280
+#define AP0101_MAX_HEIGHT	720
+
+#define AP0101_DELAY		0xffff
+
+struct ap0101_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct ap0101_reg ap0101_regs[] = {
+/* enable FSIN */
+{0xc88c, 0x0303},
+{0xfc00, 0x2800},
+{0x0040, 0x8100},
+{AP0101_DELAY, 100},
+};
+
+static const struct ap0101_reg ap0102_regs[] = {
+/* enable FSIN */
+{0xc890, 0x0303},
+{0xfc00, 0x2800},
+{0x0040, 0x8100},
+{AP0101_DELAY, 100},
+};
diff --git a/drivers/media/i2c/imagers/ap0201.c b/drivers/media/i2c/imagers/ap0201.c
new file mode 100644
index 0000000..fec4875
--- /dev/null
+++ b/drivers/media/i2c/imagers/ap0201.c
@@ -0,0 +1,607 @@
+/*
+ * ON Semiconductor AP020X-AR023X sensor camera driver
+ *
+ * Copyright (C) 2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-subdev.h>
+
+#include "ap0201.h"
+#include "../gmsl/common.h"
+
+static const int ap0201_i2c_addr[] = {0x5d, 0x48};
+
+#define AP0201_PID_REG		0x0000
+#define AP0201_REV_REG		0x0058
+#define AP0200_PID		0x0062
+#define AP0201_PID		0x0160
+#define AP0202_PID		0x0064
+
+#define AP0201_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ap0201_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializer */
+	int				ser_addr;
+};
+
+static inline struct ap0201_priv *to_ap0201(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ap0201_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ap0201_priv, hdl)->sd;
+}
+
+static int ap0201_set_regs(struct i2c_client *client,
+			  const struct ap0201_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == AP0201_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		reg16_write16(client, regs[i].reg, regs[i].val);
+	}
+
+	return 0;
+}
+
+static u16 ap0201_ar023x_read(struct i2c_client *client, u16 addr)
+{
+	u16 reg_val = 0;
+
+	reg16_write16(client, 0x0040, 0x8d00);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0xfc00, addr);
+	reg16_write16(client, 0xfc02, 0x0200); /* 2 bytes */
+	reg16_write16(client, 0x0040, 0x8d05);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d08);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_read16(client, 0xfc00, &reg_val);
+	reg16_write16(client, 0x0040, 0x8d02);
+	usleep_range(1000, 1500); /* wait 1000 us */
+
+	return reg_val;
+}
+
+static void ap0201_ar023x_write(struct i2c_client *client, u16 addr, u16 val)
+{
+	reg16_write16(client, 0x0040, 0x8d00);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0xfc00, addr);
+	reg16_write16(client, 0xfc02, 0x0200 | (val >> 8)); /* 2 bytes */
+	reg16_write16(client, 0xfc04, (val & 0xff) << 8);
+	reg16_write16(client, 0x0040, 0x8d06);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d08);
+	usleep_range(1000, 1500); /* wait 1000 us */
+	reg16_write16(client, 0x0040, 0x8d02);
+	usleep_range(1000, 1500); /* wait 1000 us */
+}
+
+static void ap0201_otp_id_read(struct i2c_client *client)
+{
+	struct ap0201_priv *priv = to_ap0201(client);
+	int i;
+
+	/* read camera id from ar023x OTP memory */
+	ap0201_ar023x_write(client, 0x3054, 0x400);
+	ap0201_ar023x_write(client, 0x304a, 0x110);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i += 2) {
+		u16 val = 0;
+		/* first 4 bytes are equal on all ar023x */
+		val = ap0201_ar023x_read(client, 0x3800 + i + 4);
+		priv->id[i]     = val >> 8;
+		priv->id[i + 1] = val & 0xff;
+	}
+}
+
+static int ap0201_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ap0201_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0201_priv *priv = to_ap0201(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = AP0201_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ap0201_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = AP0201_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ap0201_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = AP0201_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ap0201_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0201_priv *priv = to_ap0201(client);
+
+	ap0201_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = AP0201_PID >> 8;
+	edid->edid[9] = AP0201_PID & 0xff;
+
+	return 0;
+}
+
+static int ap0201_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0201_priv *priv = to_ap0201(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ap0201_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0201_priv *priv = to_ap0201(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ap0201_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+				struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ap0201_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = reg16_read16(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ap0201_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return reg16_write16(client, (u16)reg->reg, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops ap0201_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ap0201_g_register,
+	.s_register = ap0201_s_register,
+#endif
+};
+
+static int ap0201_change_config(struct i2c_client *client)
+{
+	reg16_write16(client, 0x098e, 0x7c00);
+	usleep_range(1000, 1500); /* wait 1 ms */
+	reg16_write16(client, 0xfc00, 0x2800);
+	reg16_write16(client, 0x0040, 0x8100);
+
+	return 0;
+}
+
+static int ap0201_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0201_priv *priv = to_ap0201(client);
+	int ret = -EINVAL;
+	u16 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		break;
+	case V4L2_CID_HFLIP:
+		reg16_read16(client, 0xc846, &val);
+		if (ctrl->val)
+			val |= 0x01;
+		else
+			val &= ~0x01;
+		reg16_write16(client, 0xc846, val);
+		ret = ap0201_change_config(client);
+		break;
+	case V4L2_CID_VFLIP:
+		reg16_read16(client, 0xc846, &val);
+		if (ctrl->val)
+			val |= 0x02;
+		else
+			val &= ~0x02;
+		reg16_write16(client, 0xc846, val);
+		ret = ap0201_change_config(client);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ap0201_ctrl_ops = {
+	.s_ctrl = ap0201_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ap0201_video_ops = {
+	.s_stream	= ap0201_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ap0201_subdev_pad_ops = {
+	.get_edid	= ap0201_get_edid,
+	.enum_mbus_code	= ap0201_enum_mbus_code,
+	.get_selection	= ap0201_get_selection,
+	.set_selection	= ap0201_set_selection,
+	.get_fmt	= ap0201_get_fmt,
+	.set_fmt	= ap0201_set_fmt,
+	.get_mbus_config	= ap0201_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ap0201_subdev_ops = {
+	.core	= &ap0201_core_ops,
+	.video	= &ap0201_video_ops,
+	.pad	= &ap0201_subdev_pad_ops,
+};
+
+static ssize_t ap0201_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ap0201_priv *priv = to_ap0201(client);
+
+	ap0201_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ap0201, S_IRUGO, ap0201_otp_id_show, NULL);
+
+static int ap0201_initialize(struct i2c_client *client)
+{
+	struct ap0201_priv *priv = to_ap0201(client);
+	u16 pid = 0, rev = 0, val = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ap0201_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, ap0201_i2c_addr[i]);
+
+		/* check product ID */
+		reg16_read16(client, AP0201_PID_REG, &pid);
+		if (pid == AP0200_PID || pid == AP0201_PID || pid == AP0202_PID)
+			break;
+	}
+
+	if (pid != AP0200_PID && pid != AP0201_PID && pid != AP0202_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	reg16_read16(client, AP0201_REV_REG, &rev);
+	/* Program wizard registers */
+	switch (pid) {
+	case AP0200_PID:
+	case AP0201_PID:
+		ap0201_set_regs(client, ap0201_regs_wizard, ARRAY_SIZE(ap0201_regs_wizard));
+		break;
+	case AP0202_PID:
+		ap0201_set_regs(client, ap0202_regs_wizard, ARRAY_SIZE(ap0202_regs_wizard));
+		break;
+	}
+	/* Read OTP IDs */
+	ap0201_otp_id_read(client);
+#if 1
+	/* read resolution used by current firmware */
+	reg16_read16(client, 0xcae4, &val);
+	priv->max_width = val;
+	reg16_read16(client, 0xcae6, &val);
+	priv->max_height = val;
+#else
+	priv->max_width = AP0201_MAX_WIDTH;
+	priv->max_height = AP0201_MAX_HEIGHT;
+#endif
+	dev_info(&client->dev, "PID %x (rev%x), res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, rev, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ap0201_parse_dt(struct device_node *np, struct ap0201_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ap0201_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct ap0201_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ap0201_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ap0201_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ap0201_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ap0201_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ap0201) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ap0201_remove(struct i2c_client *client)
+{
+	struct ap0201_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ap0201);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ap0201_id[] = {
+	{ "ap0201", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ap0201_id);
+
+static const struct of_device_id ap0201_of_ids[] = {
+	{ .compatible = "onnn,ap0201", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ap0201_of_ids);
+
+static struct i2c_driver ap0201_i2c_driver = {
+	.driver	= {
+		.name = "ap0201",
+		.of_match_table = ap0201_of_ids,
+	},
+	.probe = ap0201_probe,
+	.remove = ap0201_remove,
+	.id_table = ap0201_id,
+};
+
+module_i2c_driver(ap0201_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for AP020X");
+MODULE_AUTHOR("Andrey Gusakov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ap0201.h b/drivers/media/i2c/imagers/ap0201.h
new file mode 100644
index 0000000..0225407
--- /dev/null
+++ b/drivers/media/i2c/imagers/ap0201.h
@@ -0,0 +1,36 @@
+/*
+ * ON Semiconductor AP020X-AR023X sensor camera
+ *
+ * Copyright (C) 2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define AP0201_MAX_WIDTH	1920
+#define AP0201_MAX_HEIGHT	1200
+
+#define AP0201_DELAY		0xffff
+
+struct ap0201_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct ap0201_reg ap0201_regs_wizard[] = {
+/* enable FSIN */
+{0xc88c, 0x0303},
+{0xfc00, 0x2800},
+{0x0040, 0x8100},
+{AP0201_DELAY, 100},
+};
+
+static const struct ap0201_reg ap0202_regs_wizard[] = {
+/* enable FSIN */
+{0xc890, 0x0303},
+{0xfc00, 0x2800},
+{0x0040, 0x8100},
+{AP0201_DELAY, 100},
+};
diff --git a/drivers/media/i2c/imagers/dummy.c b/drivers/media/i2c/imagers/dummy.c
new file mode 100644
index 0000000..5d64378
--- /dev/null
+++ b/drivers/media/i2c/imagers/dummy.c
@@ -0,0 +1,504 @@
+/*
+ * Dummy sensor camera driver
+ *
+ * Copyright (C) 2019 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+struct dummy_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	u8				id[6];
+	int				max_width;
+	int				max_height;
+	const char *			media_bus_format;
+	int				mbus_format;
+};
+
+static int width = 1920;
+module_param(width, int, 0644);
+MODULE_PARM_DESC(width, " width (default: 1920)");
+
+static int height = 1080;
+module_param(height, int, 0644);
+MODULE_PARM_DESC(height, " height (default: 1080)");
+
+static char *mbus = "uyvy";
+module_param(mbus, charp, 0644);
+MODULE_PARM_DESC(mbus, " MEDIA_BUS_FORMAT (default: UYVY)");
+
+static inline struct dummy_priv *to_dummy(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct dummy_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct dummy_priv, hdl)->sd;
+}
+
+static int dummy_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int dummy_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = priv->mbus_format;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int dummy_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	mf->code = priv->mbus_format;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int dummy_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = priv->mbus_format;
+
+	return 0;
+}
+
+static int dummy_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = 'D' >> 8;
+	edid->edid[9] = 'Y' & 0xff;
+
+	return 0;
+}
+
+static int dummy_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int dummy_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int dummy_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int dummy_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	reg->val = 0;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int dummy_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	return 0;
+}
+#endif
+
+static struct v4l2_subdev_core_ops dummy_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = dummy_g_register,
+	.s_register = dummy_s_register,
+#endif
+};
+
+static int dummy_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_ANALOGUE_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		break;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops dummy_ctrl_ops = {
+	.s_ctrl = dummy_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops dummy_video_ops = {
+	.s_stream	= dummy_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops dummy_subdev_pad_ops = {
+	.get_edid	= dummy_get_edid,
+	.enum_mbus_code	= dummy_enum_mbus_code,
+	.get_selection	= dummy_get_selection,
+	.set_selection	= dummy_set_selection,
+	.get_fmt	= dummy_get_fmt,
+	.set_fmt	= dummy_set_fmt,
+	.get_mbus_config	= dummy_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops dummy_subdev_ops = {
+	.core	= &dummy_core_ops,
+	.video	= &dummy_video_ops,
+	.pad	= &dummy_subdev_pad_ops,
+};
+
+static void dummy_otp_id_read(struct i2c_client *client)
+{
+	struct dummy_priv *priv = to_dummy(client);
+
+	/* dummy camera id */
+	priv->id[0] = 'd';
+	priv->id[1] = 'u';
+	priv->id[2] = 'm';
+	priv->id[3] = 'm';
+	priv->id[4] = 'y';
+	priv->id[5] = '.';
+}
+
+static ssize_t dummy_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct dummy_priv *priv = to_dummy(client);
+
+	dummy_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_dummy, S_IRUGO, dummy_otp_id_show, NULL);
+
+static int dummy_initialize(struct i2c_client *client)
+{
+	struct dummy_priv *priv = to_dummy(client);
+
+	if (strcmp(priv->media_bus_format, "yuyv") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_YUYV8_2X8;
+	else if (strcmp(priv->media_bus_format, "uyvy") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_UYVY8_2X8;
+	else if (strcmp(priv->media_bus_format, "grey") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_Y8_1X8;
+	else if (strcmp(priv->media_bus_format, "rggb8") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB8_1X8;
+	else if (strcmp(priv->media_bus_format, "bggr8") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR8_1X8;
+	else if (strcmp(priv->media_bus_format, "grbg8") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG8_1X8;
+	else if (strcmp(priv->media_bus_format, "rggb12") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB12_1X12;
+	else if (strcmp(priv->media_bus_format, "bggr12") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR12_1X12;
+	else if (strcmp(priv->media_bus_format, "grbg12") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG12_1X12;
+	else if (strcmp(priv->media_bus_format, "rggb14") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB14_1X14;
+	else if (strcmp(priv->media_bus_format, "bggr14") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR14_1X14;
+	else if (strcmp(priv->media_bus_format, "grbg14") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG14_1X14;
+	else if (strcmp(priv->media_bus_format, "rggb16") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SRGGB16_1X16;
+	else if (strcmp(priv->media_bus_format, "bggr16") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SBGGR16_1X16;
+	else if (strcmp(priv->media_bus_format, "grbg16") == 0)
+		priv->mbus_format = MEDIA_BUS_FMT_SGRBG16_1X16;
+	else {
+		v4l_err(client, "failed to parse mbus format (%s)\n", priv->media_bus_format);
+		return -EINVAL;
+	}
+
+	/* Read OTP IDs */
+	dummy_otp_id_read(client);
+
+	dev_info(&client->dev, "res %dx%d, mbus %s, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 priv->max_width, priv->max_height, priv->media_bus_format, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+
+	return 0;
+}
+
+static const struct i2c_device_id dummy_id[] = {
+	{ "dummy-camera", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, dummy_id);
+
+static const struct of_device_id dummy_of_ids[] = {
+	{ .compatible = "dummy,camera", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, dummy_of_ids);
+
+static int dummy_parse_dt(struct device_node *np, struct dummy_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+
+	if (of_property_read_u32(np, "dummy,width", &priv->max_width))
+		priv->max_width = width;
+
+	if (of_property_read_u32(np, "dummy,height", &priv->max_height))
+		priv->max_height = height;
+
+	if (of_property_read_string(np, "dummy,mbus", &priv->media_bus_format))
+		priv->media_bus_format = mbus;
+
+	/* module params override dts */
+	if (strcmp(mbus, "uyvy"))
+		priv->media_bus_format = mbus;
+	if (width != 1920)
+		priv->max_width = width;
+	if (height != 1080)
+		priv->max_height = height;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int dummy_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct dummy_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &dummy_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_GAIN, 1, 0x7ff, 1, 0x200);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_ANALOGUE_GAIN, 1, 0xe, 1, 0xa);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 1, 0x600, 1, 0x144);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &dummy_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = dummy_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = dummy_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_dummy) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	v4l_err(client, "failed to probe @ 0x%02x (%s)\n",
+		client->addr, client->adapter->name);
+	return ret;
+}
+
+static int dummy_remove(struct i2c_client *client)
+{
+	struct dummy_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_dummy);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static struct i2c_driver dummy_i2c_driver = {
+	.driver	= {
+		.name		= "dummy-camera",
+		.of_match_table	= dummy_of_ids,
+	},
+	.probe		= dummy_probe,
+	.remove		= dummy_remove,
+	.id_table	= dummy_id,
+};
+module_i2c_driver(dummy_i2c_driver);
+
+MODULE_DESCRIPTION("Dummy camera glue driver");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/isx016.c b/drivers/media/i2c/imagers/isx016.c
new file mode 100644
index 0000000..324f737
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx016.c
@@ -0,0 +1,550 @@
+/*
+ * Sony ISX016 (isp) camera driver
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "isx016.h"
+
+static const int isx016_i2c_addr[] = {0x1a};
+
+#define ISX016_PID_REG		0x0000
+#define ISX016_PID		0x0D20
+
+#define ISX016_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+static void isx016_otp_id_read(struct i2c_client *client);
+
+struct isx016_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+};
+
+static inline struct isx016_priv *to_isx016(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct isx016_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct isx016_priv, hdl)->sd;
+}
+
+static int isx016_read16(struct i2c_client *client, u8 category, u16 reg, u16 *val)
+{
+	reg16_write(client, 0xFFFF, category);
+	reg16_read16(client, reg, val);
+
+	return 0;
+}
+
+static int isx016_write16(struct i2c_client *client, u8 category, u16 reg, u16 val)
+{
+	reg16_write(client, 0xFFFF, category);
+	reg16_write16(client, reg, val);
+
+	return 0;
+}
+
+static int isx016_set_regs(struct i2c_client *client,
+			  const struct isx016_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == ISX016_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		isx016_write16(client, regs[i].reg >> 8, regs[i].reg & 0xff, regs[i].val);
+	}
+
+	return 0;
+}
+
+static void isx016_otp_id_read(struct i2c_client *client)
+{
+	struct isx016_priv *priv = to_isx016(client);
+	int i;
+	u16 val = 0;
+
+	/* read camera id from isx016 FUSEs */
+	for (i = 0; i < 6; i+=2) {
+		isx016_read16(client, 92, 0x0a + i, &val);
+		priv->id[i] = val >> 8;
+		priv->id[i+1] = val & 0xff;
+	}
+}
+
+static int isx016_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int isx016_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = ISX016_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int isx016_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = ISX016_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int isx016_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = ISX016_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int isx016_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	isx016_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = ISX016_PID >> 8;
+	edid->edid[9] = ISX016_PID & 0xff;
+
+	return 0;
+}
+
+static int isx016_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int isx016_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int isx016_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int isx016_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = isx016_read16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int isx016_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return isx016_write16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops isx016_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = isx016_g_register,
+	.s_register = isx016_s_register,
+#endif
+};
+
+static int isx016_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops isx016_ctrl_ops = {
+	.s_ctrl = isx016_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops isx016_video_ops = {
+	.s_stream	= isx016_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops isx016_subdev_pad_ops = {
+	.get_edid	= isx016_get_edid,
+	.enum_mbus_code	= isx016_enum_mbus_code,
+	.get_selection	= isx016_get_selection,
+	.set_selection	= isx016_set_selection,
+	.get_fmt	= isx016_get_fmt,
+	.set_fmt	= isx016_set_fmt,
+	.get_mbus_config	= isx016_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops isx016_subdev_ops = {
+	.core	= &isx016_core_ops,
+	.video	= &isx016_video_ops,
+	.pad	= &isx016_subdev_pad_ops,
+};
+
+static ssize_t isx016_otp_id_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx016_priv *priv = to_isx016(client);
+
+	isx016_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_isx016, S_IRUGO, isx016_otp_id_show, NULL);
+
+static int isx016_initialize(struct i2c_client *client)
+{
+	struct isx016_priv *priv = to_isx016(client);
+	u16 pid = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(isx016_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, isx016_i2c_addr[i]);
+
+		/* check model ID */
+		isx016_read16(client, 0, ISX016_PID_REG, &pid);
+
+		if (pid == ISX016_PID)
+			break;
+	}
+
+	if (pid != ISX016_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	priv->max_width = ISX016_MAX_WIDTH;
+	priv->max_height = ISX016_MAX_HEIGHT;
+
+	/* Read OTP IDs */
+	isx016_otp_id_read(client);
+	/* Program wizard registers */
+	isx016_set_regs(client, isx016_regs, ARRAY_SIZE(isx016_regs));
+
+	dev_info(&client->dev, "PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int isx016_parse_dt(struct device_node *np, struct isx016_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int isx016_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct isx016_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &isx016_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &isx016_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	priv->sd.entity.flags |= MEDIA_ENT_F_CAM_SENSOR;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = isx016_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = isx016_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_isx016) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int isx016_remove(struct i2c_client *client)
+{
+	struct isx016_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_isx016);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id isx016_id[] = {
+	{ "isx016", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, isx016_id);
+
+static const struct of_device_id isx016_of_ids[] = {
+	{ .compatible = "sony,isx016", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, isx016_of_ids);
+
+static struct i2c_driver isx016_i2c_driver = {
+	.driver = {
+		.name = "isx016",
+		.of_match_table = isx016_of_ids,
+	},
+	.probe = isx016_probe,
+	.remove = isx016_remove,
+	.id_table = isx016_id,
+};
+
+module_i2c_driver(isx016_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for ISX016");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/isx016.h b/drivers/media/i2c/imagers/isx016.h
new file mode 100644
index 0000000..caf427f
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx016.h
@@ -0,0 +1,27 @@
+/*
+ * Sony isx016 (isp) camera setup 1280x960@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2019-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#define ISX016_MAX_WIDTH	1280
+#define ISX016_MAX_HEIGHT	960
+
+#define ISX016_DELAY		0xffff
+
+struct isx016_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct isx016_reg isx016_regs[] = {
+#if 0
+/* enable FSIN */
+#endif
+{ISX016_DELAY, 100},
+};
diff --git a/drivers/media/i2c/imagers/isx019.c b/drivers/media/i2c/imagers/isx019.c
new file mode 100644
index 0000000..0860539
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx019.c
@@ -0,0 +1,608 @@
+/*
+ * Sony ISX019 (isp) camera driver
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "isx019.h"
+
+static const int isx019_i2c_addr[] = {0x1a};
+
+#define ISX019_PID_REG		0x0000
+#define ISX019_PID		0x4000
+
+#define ISX019_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+static void isx019_otp_id_read(struct i2c_client *client);
+
+struct isx019_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+};
+
+static char *intf = "command";
+module_param(intf, charp, 0644);
+MODULE_PARM_DESC(intf, " Registers access interface command,address (default: command)");
+
+static inline struct isx019_priv *to_isx019(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct isx019_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct isx019_priv, hdl)->sd;
+}
+
+static int isx019_read16(struct i2c_client *client, u8 category, u16 reg, u16 *val)
+{
+	int ret = -1;
+
+	if (strcmp(intf, "command") == 0) {
+ #define R_NUM_BYTES		9
+ #define R_NUM_CMDS		1
+ #define R_NUM_CMD_BYTES	6
+ #define R_CMD			1
+ #define R_BYTES		2
+		u8 buf[R_NUM_BYTES] = {R_NUM_BYTES, R_NUM_CMDS,
+				       R_NUM_CMD_BYTES, R_CMD,
+				       category, reg >> 8, reg & 0xff,
+				       R_BYTES, 0x00};
+
+		/* calculate checksum */
+		buf[8] = R_NUM_BYTES + R_NUM_CMDS + R_NUM_CMD_BYTES + R_CMD +
+			 category + (reg >> 8) + (reg & 0xff) + R_BYTES;
+
+		ret = i2c_master_send(client, buf, R_NUM_BYTES);
+		if (ret == R_NUM_BYTES)
+			ret = i2c_master_recv(client, buf, R_NUM_BYTES - 2);
+
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"read fail: chip 0x%x register 0x%x: %d\n",
+				client->addr, reg, ret);
+		} else {
+			*val = buf[4] | ((u16)buf[5] << 8);
+		}
+	} else if (strcmp(intf, "address") == 0) {
+		reg16_write(client, 0xFFFF, category);
+		ret = reg16_read16(client, reg, val);
+		*val = swab16p(val);
+	} else {
+		dev_err(&client->dev, "invalid register access interface %s\n", intf);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static int isx019_write16(struct i2c_client *client, u8 category, u16 reg, u16 val)
+{
+	int ret = -1;
+
+	if (strcmp(intf, "command") == 0) {
+ #define W_NUM_BYTES		10
+ #define W_NUM_CMDS		1
+ #define W_NUM_CMD_BYTES	7
+ #define W_CMD			2
+		u8 buf[W_NUM_BYTES] = {W_NUM_BYTES, W_NUM_CMDS,
+				       W_NUM_CMD_BYTES, W_CMD,
+				       category, reg >> 8, reg & 0xff,
+				       val & 0xff, val >> 8};
+
+		/* calculate checksum */
+		buf[9] = W_NUM_BYTES + W_NUM_CMDS + W_NUM_CMD_BYTES + W_CMD +
+			 category + (reg >> 8) + (reg & 0xff) + (val >> 8) + (val & 0xff);
+
+		ret = i2c_master_send(client, buf, W_NUM_BYTES);
+
+		if (ret < 0) {
+			dev_err(&client->dev,
+				"write fail: chip 0x%x register 0x%x: %d\n",
+				client->addr, reg, ret);
+		}
+	} else if (strcmp(intf, "address") == 0) {
+		val = swab16(val);
+		reg16_write(client, 0xFFFF, category);
+		ret = reg16_write16(client, reg, val);
+	} else {
+		dev_err(&client->dev, "invalid register acces interface %s\n", intf);
+	}
+
+	return ret < 0 ? ret : 0;
+}
+
+static int isx019_set_regs(struct i2c_client *client,
+			   const struct isx019_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == ISX019_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		isx019_write16(client, regs[i].reg >> 8, regs[i].reg & 0xff, regs[i].val);
+	}
+
+	return 0;
+}
+
+static void isx019_otp_id_read(struct i2c_client *client)
+{
+	struct isx019_priv *priv = to_isx019(client);
+	int i;
+	u16 val = 0;
+
+	/* read camera id from isx019 OTP memory */
+	for (i = 0; i < 6; i+=2) {
+		isx019_read16(client, 8, 0x60 + i, &val);
+		priv->id[i] = val >> 8;
+		priv->id[i+1] = val & 0xff;
+	}
+}
+
+static int isx019_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int isx019_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = ISX019_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int isx019_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = ISX019_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int isx019_enum_mbus_code(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = ISX019_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int isx019_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	isx019_otp_id_read(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = ISX019_PID >> 8;
+	edid->edid[9] = ISX019_PID & 0xff;
+
+	return 0;
+}
+
+static int isx019_set_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int isx019_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int isx019_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+				struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int isx019_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u16 val = 0;
+
+	ret = isx019_read16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int isx019_s_register(struct v4l2_subdev *sd,
+			     const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	return isx019_write16(client, (u16)reg->reg >> 8, (u16)reg->reg & 0xff, (u16)reg->val);
+}
+#endif
+
+static struct v4l2_subdev_core_ops isx019_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = isx019_g_register,
+	.s_register = isx019_s_register,
+#endif
+};
+
+static int isx019_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+	case V4L2_CID_SHARPNESS:
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+	case V4L2_CID_HFLIP:
+	case V4L2_CID_VFLIP:
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops isx019_ctrl_ops = {
+	.s_ctrl = isx019_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops isx019_video_ops = {
+	.s_stream	= isx019_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops isx019_subdev_pad_ops = {
+	.get_edid	= isx019_get_edid,
+	.enum_mbus_code	= isx019_enum_mbus_code,
+	.get_selection	= isx019_get_selection,
+	.set_selection	= isx019_set_selection,
+	.get_fmt	= isx019_get_fmt,
+	.set_fmt	= isx019_set_fmt,
+	.get_mbus_config	= isx019_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops isx019_subdev_ops = {
+	.core	= &isx019_core_ops,
+	.video	= &isx019_video_ops,
+	.pad	= &isx019_subdev_pad_ops,
+};
+
+static ssize_t isx019_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct isx019_priv *priv = to_isx019(client);
+
+	isx019_otp_id_read(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_isx019, S_IRUGO, isx019_otp_id_show, NULL);
+
+static int isx019_initialize(struct i2c_client *client)
+{
+	struct isx019_priv *priv = to_isx019(client);
+	u16 pid = 0, val = 0;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(isx019_i2c_addr); i++) {
+		setup_i2c_translator(client, priv->ser_addr, isx019_i2c_addr[i]);
+
+		/* check model ID */
+		isx019_read16(client, 0, ISX019_PID_REG, &pid);
+
+		if ((pid & 0xff00) == ISX019_PID)
+			break;
+	}
+
+	if ((pid & 0xff00) != ISX019_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	/* Read OTP IDs */
+	isx019_otp_id_read(client);
+	/* Program wizard registers */
+	isx019_set_regs(client, isx019_regs, ARRAY_SIZE(isx019_regs));
+	/* read resolution used by current firmware */
+	isx019_read16(client, 86, 0x8, &val);
+	priv->max_width = val;
+	isx019_read16(client, 86, 0xa, &val);
+	priv->max_height = val;
+
+	dev_info(&client->dev, "PID %x (rev %x), res %dx%d, if=%s, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid & 0xff00, pid & 0xff, priv->max_width, priv->max_height, intf, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int isx019_parse_dt(struct device_node *np, struct isx019_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int isx019_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct isx019_priv *priv;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &isx019_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &isx019_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = isx019_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = isx019_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_isx019) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int isx019_remove(struct i2c_client *client)
+{
+	struct isx019_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_isx019);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id isx019_id[] = {
+	{ "isx019", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, isx019_id);
+
+static const struct of_device_id isx019_of_ids[] = {
+	{ .compatible = "sony,isx019", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, isx019_of_ids);
+
+static struct i2c_driver isx019_i2c_driver = {
+	.driver	= {
+		.name		= "isx019",
+		.of_match_table	= isx019_of_ids,
+	},
+	.probe		= isx019_probe,
+	.remove		= isx019_remove,
+	.id_table	= isx019_id,
+};
+
+module_i2c_driver(isx019_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for ISX019");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/isx019.h b/drivers/media/i2c/imagers/isx019.h
new file mode 100644
index 0000000..6d936ab
--- /dev/null
+++ b/drivers/media/i2c/imagers/isx019.h
@@ -0,0 +1,30 @@
+/*
+ * Sony isx019 (isp) camera setup 1280x800@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2018-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define ISX019_MAX_WIDTH	1280
+//#define ISX019_MAX_HEIGHT	960
+
+#define ISX019_DELAY		0xffff
+
+struct isx019_reg {
+	u16	reg;
+	u16	val;
+};
+
+static const struct isx019_reg isx019_regs[] = {
+#if 0
+/* enable FSIN */
+{ISX019_DELAY, 100},
+#endif
+/* disable embedded data */
+{0x504c, 0x0},
+{0x504e, 0x0},
+};
diff --git a/drivers/media/i2c/imagers/ov10635.c b/drivers/media/i2c/imagers/ov10635.c
new file mode 100644
index 0000000..dfca965
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov10635.c
@@ -0,0 +1,702 @@
+/*
+ * OmniVision ov10635 sensor camera driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov10635.h"
+
+#define OV10635_I2C_ADDR		0x30
+
+#define OV10635_PID_REGA		0x300a
+#define OV10635_PID_REGB		0x300b
+#define OV10635_PID			0xa635
+
+#define OV10635_MEDIA_BUS_FMT		MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov10635_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				subsampling;
+	int				fps_denominator;
+	int				init_complete;
+	u8				id[6];
+	int				dvp_order;
+	int				vsync;
+	/* serializers */
+	int				ser_addr;
+};
+
+static int dvp_order = 0;
+module_param(dvp_order, int, 0644);
+MODULE_PARM_DESC(dvp_order, " DVP bus bits order");
+
+static int vsync = 0;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 0 - not inverted)");
+
+static inline struct ov10635_priv *to_ov10635(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov10635_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov10635_priv, hdl)->sd;
+}
+
+static int ov10635_set_regs(struct i2c_client *client,
+			    const struct ov10635_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100ns */
+			if (reg16_write(client, regs[i].reg, regs[i].val))
+				printk("ov10635 reg 0x%04x write failed\n", regs[i].reg);
+		}
+	}
+
+	return 0;
+}
+
+static void ov10635_otp_id_read(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = to_ov10635(client);
+	int i;
+
+	/* read camera id from OTP memory */
+	reg16_write(client, 0x3d10, 1);
+
+	usleep_range(15000, 16000); /* wait 15ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0x3d00 + i, &priv->id[i]);
+}
+
+static int ov10635_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov10635_set_window(struct v4l2_subdev *sd, int subsampling)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	/* disable clocks */
+	reg16_write(client, 0x302e, 0x00);
+	reg16_write(client, 0x301b, 0xff);
+	reg16_write(client, 0x301c, 0xff);
+	reg16_write(client, 0x301a, 0xff);
+
+	/* setup resolution */
+	reg16_write(client, 0x3808, priv->rect.width >> 8);
+	reg16_write(client, 0x3809, priv->rect.width & 0xff);
+	reg16_write(client, 0x380a, priv->rect.height >> 8);
+	reg16_write(client, 0x380b, priv->rect.height & 0xff);
+
+	/* enable/disable subsampling */
+	reg16_write(client, 0x5005, subsampling ? 0x89 : 0x08);
+	reg16_write(client, 0x3007, subsampling ? 0x02 : 0x01);
+	reg16_write(client, 0x4004, subsampling ? 0x02 : 0x04);
+
+#if 0 /* This is implemented in VIN via SOC_CAMERA layer, hence skip */
+	/* horiz crop start */
+	reg16_write(client, 0x3800, priv->rect.left >> 8);
+	reg16_write(client, 0x3801, priv->rect.left & 0xff);
+	/* horiz crop end */
+	reg16_write(client, 0x3804, (priv->rect.left + priv->rect.width + 1) >> 8);
+	reg16_write(client, 0x3805, (priv->rect.left + priv->rect.width + 1) & 0xff);
+	/* vert crop start */
+	reg16_write(client, 0x3802, priv->rect.top >> 8);
+	reg16_write(client, 0x3803, priv->rect.top & 0xff);
+	/* vert crop end */
+	reg16_write(client, 0x3806, (priv->rect.top + priv->rect.height + 1) >> 8);
+	reg16_write(client, 0x3807, (priv->rect.top + priv->rect.height + 1) & 0xff);
+#endif
+	/* enable clocks */
+	reg16_write(client, 0x301b, 0xf0);
+	reg16_write(client, 0x301c, 0xf0);
+	reg16_write(client, 0x301a, 0xf0);
+	reg16_write(client, 0x302e, 0x01);
+
+	return 0;
+};
+
+static int ov10635_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV10635_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov10635_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV10635_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov10635_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV10635_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov10635_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV10635_PID >> 8;
+	edid->edid[9] = OV10635_PID & 0xff;
+
+	return 0;
+}
+
+static int ov10635_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int subsampling = 0;
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > OV10635_MAX_WIDTH) ||
+	    (rect->top + rect->height > OV10635_MAX_HEIGHT))
+		*rect = priv->rect;
+
+	if (rect->width == OV10635_MAX_WIDTH / 2 &&
+	    rect->height == OV10635_MAX_HEIGHT / 2)
+		subsampling = 1;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	/* change window only for subsampling, crop is done by VIN */
+	if (subsampling != priv->subsampling) {
+		ov10635_set_window(sd, subsampling);
+		priv->subsampling = subsampling;
+	}
+
+	return 0;
+}
+
+static int ov10635_get_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV10635_MAX_WIDTH;
+		sel->r.height = OV10635_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV10635_MAX_WIDTH;
+		sel->r.height = OV10635_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov10635_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+				 struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+static int ov10635_g_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *ival)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	ival->interval.numerator = 1;
+	ival->interval.denominator = priv->fps_denominator;
+
+	return 0;
+}
+
+static int ov10635_s_frame_interval(struct v4l2_subdev *sd,
+				    struct v4l2_subdev_frame_interval *ival)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int ret = 0;
+
+	if (priv->fps_denominator != ival->interval.denominator) {
+		switch (ival->interval.denominator) {
+		case 5:
+			ret = ov10635_set_regs(client, ov10635_regs_5fps,
+					       ARRAY_SIZE(ov10635_regs_5fps));
+			break;
+		case 10:
+			ret = ov10635_set_regs(client, ov10635_regs_10fps,
+					       ARRAY_SIZE(ov10635_regs_10fps));
+			break;
+		case 15:
+			ret = ov10635_set_regs(client, ov10635_regs_15fps,
+					       ARRAY_SIZE(ov10635_regs_15fps));
+			break;
+		case 30:
+			ret = ov10635_set_regs(client, ov10635_regs_30fps,
+					       ARRAY_SIZE(ov10635_regs_30fps));
+			break;
+		default:
+			ret = -EINVAL;
+			goto out;
+		}
+
+		priv->fps_denominator = ival->interval.denominator;
+	}
+out:
+	return ret;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov10635_g_register(struct v4l2_subdev *sd,
+			      struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u8);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ov10635_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	int ret;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u8);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	ret = reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov10635_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov10635_g_register,
+	.s_register = ov10635_s_register,
+#endif
+};
+
+static int ov10635_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+	int ret = -EINVAL;
+	u8 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		/* AEC/AGC target */
+		ret = reg16_write(client, 0xc46a, ctrl->val);
+		break;
+	case V4L2_CID_CONTRAST:
+		udelay(100);
+		ret = ov10635_set_regs(client, &ov10635_regs_contrast[ctrl->val][0], 18);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = reg16_write(client, 0xc316, ctrl->val);
+		break;
+	case V4L2_CID_HUE:
+		/* CMX ? */
+		ret = 0;
+		break;
+	case V4L2_CID_GAMMA:
+		ret = reg16_write(client, 0xc4be, ctrl->val >> 8);
+		ret |= reg16_write(client, 0xc4bf, ctrl->val & 0xff);
+		break;
+	case V4L2_CID_AUTOGAIN:
+		/* automatic gain/exposure */
+		ret = reg16_write(client, 0x56d0, !ctrl->val);
+		break;
+	case V4L2_CID_GAIN:
+		/* manual gain */
+		ret = reg16_write(client, 0x3504, 0);
+		ret |= reg16_write(client, 0x56d1, ctrl->val >> 8);
+		ret |= reg16_write(client, 0x56d2, ctrl->val & 0xff);
+		ret |= reg16_write(client, 0x3504, 1); /* validate gain */
+		break;
+	case V4L2_CID_EXPOSURE:
+		/* manual exposure */
+		ret = reg16_write(client, 0x3504, 0);
+		ret |= reg16_write(client, 0x56d5, ctrl->val >> 8);
+		ret |= reg16_write(client, 0x56d6, ctrl->val & 0xff);
+		ret |= reg16_write(client, 0x3504, 1); /* validate exposure */
+		break;
+	case V4L2_CID_HFLIP:
+		ret = reg16_read(client, 0x381d, &val);
+		if (ctrl->val)
+			val |= 0x3;
+		else
+			val &= ~0x3;
+		ret |= reg16_write(client, 0x381d, val);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = reg16_read(client, 0x381c, &val);
+		if (ctrl->val)
+			val |= 0xc0;
+		else
+			val &= ~0xc0;
+		ret |= reg16_write(client, 0x381c, val);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov10635_ctrl_ops = {
+	.s_ctrl = ov10635_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov10635_video_ops = {
+	.s_stream	= ov10635_s_stream,
+	.g_frame_interval = ov10635_g_frame_interval,
+	.s_frame_interval = ov10635_s_frame_interval,
+};
+
+static const struct v4l2_subdev_pad_ops ov10635_subdev_pad_ops = {
+	.get_edid	= ov10635_get_edid,
+	.enum_mbus_code	= ov10635_enum_mbus_code,
+	.get_selection	= ov10635_get_selection,
+	.set_selection	= ov10635_set_selection,
+	.get_fmt	= ov10635_get_fmt,
+	.set_fmt	= ov10635_set_fmt,
+	.get_mbus_config	= ov10635_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ov10635_subdev_ops = {
+	.core	= &ov10635_core_ops,
+	.video	= &ov10635_video_ops,
+	.pad	= &ov10635_subdev_pad_ops,
+};
+
+static ssize_t ov10635_otp_id_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov10635_priv *priv = to_ov10635(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov10635, S_IRUGO, ov10635_otp_id_show, NULL);
+
+static int ov10635_initialize(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = to_ov10635(client);
+	u8 val = 0;
+	u16 pid = 0;
+
+	setup_i2c_translator(client, priv->ser_addr, OV10635_I2C_ADDR);
+	udelay(100);
+
+	reg16_read(client, OV10635_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV10635_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV10635_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	/* s/w reset sensor */
+	reg16_write(client, 0x103, 0x1);
+	udelay(100);
+	/* Program wizard registers */
+	ov10635_set_regs(client, ov10635_regs, ARRAY_SIZE(ov10635_regs));
+	/* Set DVP bit swap */
+	reg16_write(client, 0x4709, priv->dvp_order << 4);
+	/* Set VSYNC inversion */
+	reg16_write(client, 0x4708, priv->vsync ? 0x3 : 0x1);
+	/* Read OTP IDs */
+	ov10635_otp_id_read(client);
+
+	dev_info(&client->dev, "PID %x, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov10635_parse_dt(struct device_node *np, struct ov10635_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+	priv->ser_addr = addrs[1];
+
+	if (of_property_read_u32(np, "dvp-order", &priv->dvp_order))
+		priv->dvp_order = 0;
+	if (of_property_read_u32(np, "vsync", &priv->vsync))
+		priv->vsync = 0;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	/* module params override dts */
+	if (dvp_order)
+		priv->dvp_order = dvp_order;
+	if (vsync)
+		priv->vsync = vsync;
+
+	return 0;
+}
+
+static int ov10635_probe(struct i2c_client *client,
+			 const struct i2c_device_id *did)
+{
+	struct ov10635_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov10635_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = OV10635_MAX_WIDTH;
+	priv->rect.height = OV10635_MAX_HEIGHT;
+	priv->fps_denominator = 30;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x30);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 4, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 0xff, 1, 0xff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_HUE, 0, 255, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_GAMMA, 0, 0xffff, 1, 0x233);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0x3ff, 1, 0x10);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, 0x80);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov10635_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov10635_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov10635_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov10635) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov10635_remove(struct i2c_client *client)
+{
+	struct ov10635_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov10635);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov10635_id[] = {
+	{ "ov10635", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov10635_id);
+
+static const struct of_device_id ov10635_of_ids[] = {
+	{ .compatible = "ovti,ov10635", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov10635_of_ids);
+
+static struct i2c_driver ov10635_i2c_driver = {
+	.driver	= {
+		.name		= "ov10635",
+		.of_match_table	= ov10635_of_ids,
+	},
+	.probe		= ov10635_probe,
+	.remove		= ov10635_remove,
+	.id_table	= ov10635_id,
+};
+
+module_i2c_driver(ov10635_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV10635");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov10635.h b/drivers/media/i2c/imagers/ov10635.h
new file mode 100644
index 0000000..03346b8
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov10635.h
@@ -0,0 +1,1143 @@
+/*
+ * OmniVision ov10635 sensor camera setup 1280x800@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV10635_DISPLAY_PATTERN
+
+#define OV10635_SENSOR_WIDTH		1312
+#define OV10635_SENSOR_HEIGHT		814
+
+#define OV10635_MAX_WIDTH		1280
+#define OV10635_MAX_HEIGHT		800
+
+#define OV10635_PCLK_96MHZ
+//#define OV10635_PCLK_88MHZ
+
+#if defined(OV10635_PCLK_96MHZ)
+/* VTS=PCLK/FPS/HTS/2 (=96MHz/30/1750/2) */
+ #define OV10635_HTS			1750
+ #define OV10635_VTS			914 /* fps=30 */
+#elif defined(OV10635_PCLK_88MHZ)
+/* VTS=PCLK/FPS/HTS/2 (=88MHz/1572/30/2) */
+ #define OV10635_HTS			1572
+ #define OV10635_VTS			933 /* fps=29.9998 */
+#else
+ #error PCLK not defined
+#endif
+
+struct ov10635_reg {
+	u16	reg;
+	u8	val;
+};
+
+static const struct ov10635_reg ov10635_regs[] = {
+//{0x0103, 0x01},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x300C, 0x61},
+{0x301B, 0xFF},
+{0x301C, 0xFF},
+{0x301A, 0xFF},
+{0x3011, 0x42},
+{0x6900, 0x0C},
+{0x6901, 0x19},
+{0x3503, 0x10},
+{0x3025, 0x03},
+#if defined(OV10635_PCLK_96MHZ)
+{0x3003, 0x20},
+{0x3004, 0x21},
+#elif defined(OV10635_PCLK_88MHZ)
+{0x3003, 0x16},
+{0x3004, 0x30},
+#endif
+{0x3005, 0x40},
+{0x3006, 0x91},
+{0x3600, 0x74},
+{0x3601, 0x2B},
+{0x3612, 0x00},
+{0x3611, 0x67},
+{0x3633, 0xCA},
+{0x3602, 0xAF},
+{0x3603, 0x04},
+{0x3630, 0x28},
+{0x3631, 0x16},
+{0x3714, 0x10},
+{0x371D, 0x01},
+{0x4300, 0x3A},
+{0x3007, 0x01},
+{0x3024, 0x03},
+{0x3020, 0x0A},
+{0x3702, 0x0D},
+{0x3703, 0x20},
+{0x3704, 0x15},
+{0x3709, 0xA8},
+{0x370C, 0xC7},
+{0x370D, 0x80},
+{0x3712, 0x00},
+{0x3713, 0x20},
+{0x3715, 0x04},
+{0x381D, 0x40},
+{0x381C, 0x00},
+{0x3822, 0x50},
+{0x3824, 0x10},
+{0x3815, 0x8C},
+{0x3804, 0x05},
+{0x3805, 0x1F},
+{0x3800, 0x00},
+{0x3801, 0x00},
+{0x3806, 0x03},
+{0x3807, 0x28},
+{0x3802, 0x00},
+{0x3803, 0x07},
+{0x3808, 0x05},
+{0x3809, 0x00},
+{0x380A, 0x03},
+{0x380B, 0x20},
+{0x380C, OV10635_HTS >> 8},
+{0x380D, OV10635_HTS & 0xff},
+{0x380E, OV10635_VTS >> 8},
+{0x380F, OV10635_VTS & 0xff},
+{0x3813, 0x02},
+{0x3811, 0x08},
+{0x381F, 0x0C},
+{0x3819, 0x04},
+{0x3804, 0x01},
+{0x3805, 0x00},
+{0x3828, 0x03},
+{0x3829, 0x10},
+{0x382A, 0x10},
+{0x3621, 0x63},
+{0x5005, 0x08},
+{0x56D5, 0x00},
+{0x56D6, 0x80},
+{0x56D7, 0x00},
+{0x56D8, 0x00},
+{0x56D9, 0x00},
+{0x56DA, 0x80},
+{0x56DB, 0x00},
+{0x56DC, 0x00},
+{0x56E8, 0x00},
+{0x56E9, 0x7F},
+{0x56EA, 0x00},
+{0x56EB, 0x7F},
+{0x5100, 0x00},
+{0x5101, 0x80},
+{0x5102, 0x00},
+{0x5103, 0x80},
+{0x5104, 0x00},
+{0x5105, 0x80},
+{0x5106, 0x00},
+{0x5107, 0x80},
+{0x5108, 0x00},
+{0x5109, 0x00},
+{0x510A, 0x00},
+{0x510B, 0x00},
+{0x510C, 0x00},
+{0x510D, 0x00},
+{0x510E, 0x00},
+{0x510F, 0x00},
+{0x5110, 0x00},
+{0x5111, 0x80},
+{0x5112, 0x00},
+{0x5113, 0x80},
+{0x5114, 0x00},
+{0x5115, 0x80},
+{0x5116, 0x00},
+{0x5117, 0x80},
+{0x5118, 0x00},
+{0x5119, 0x00},
+{0x511A, 0x00},
+{0x511B, 0x00},
+{0x511C, 0x00},
+{0x511D, 0x00},
+{0x511E, 0x00},
+{0x511F, 0x00},
+{0x56D0, 0x00},
+{0x5006, 0x04},
+{0x5608, 0x05},
+{0x52D7, 0x06},
+{0x528D, 0x08},
+{0x5293, 0x12},
+{0x52D3, 0x12},
+{0x5288, 0x06},
+{0x5289, 0x20},
+{0x52C8, 0x06},
+{0x52C9, 0x20},
+{0x52CD, 0x04},
+{0x5381, 0x00},
+{0x5382, 0xFF},
+{0x5589, 0x76},
+{0x558A, 0x47},
+{0x558B, 0xEF},
+{0x558C, 0xC9},
+{0x558D, 0x49},
+{0x558E, 0x30},
+{0x558F, 0x67},
+{0x5590, 0x3F},
+{0x5591, 0xF0},
+{0x5592, 0x10},
+{0x55A2, 0x6D},
+{0x55A3, 0x55},
+{0x55A4, 0xC3},
+{0x55A5, 0xB5},
+{0x55A6, 0x43},
+{0x55A7, 0x38},
+{0x55A8, 0x5F},
+{0x55A9, 0x4B},
+{0x55AA, 0xF0},
+{0x55AB, 0x10},
+{0x5581, 0x52},
+{0x5300, 0x01},
+{0x5301, 0x00},
+{0x5302, 0x00},
+{0x5303, 0x0E},
+{0x5304, 0x00},
+{0x5305, 0x0E},
+{0x5306, 0x00},
+{0x5307, 0x36},
+{0x5308, 0x00},
+{0x5309, 0xD9},
+{0x530A, 0x00},
+{0x530B, 0x0F},
+{0x530C, 0x00},
+{0x530D, 0x2C},
+{0x530E, 0x00},
+{0x530F, 0x59},
+{0x5310, 0x00},
+{0x5311, 0x7B},
+{0x5312, 0x00},
+{0x5313, 0x22},
+{0x5314, 0x00},
+{0x5315, 0xD5},
+{0x5316, 0x00},
+{0x5317, 0x13},
+{0x5318, 0x00},
+{0x5319, 0x18},
+{0x531A, 0x00},
+{0x531B, 0x26},
+{0x531C, 0x00},
+{0x531D, 0xDC},
+{0x531E, 0x00},
+{0x531F, 0x02},
+{0x5320, 0x00},
+{0x5321, 0x24},
+{0x5322, 0x00},
+{0x5323, 0x56},
+{0x5324, 0x00},
+{0x5325, 0x85},
+{0x5326, 0x00},
+{0x5327, 0x20},
+{0x5609, 0x01},
+{0x560A, 0x40},
+{0x560B, 0x01},
+{0x560C, 0x40},
+{0x560D, 0x00},
+{0x560E, 0xFA},
+{0x560F, 0x00},
+{0x5610, 0xFA},
+{0x5611, 0x02},
+{0x5612, 0x80},
+{0x5613, 0x02},
+{0x5614, 0x80},
+{0x5615, 0x01},
+{0x5616, 0x2C},
+{0x5617, 0x01},
+{0x5618, 0x2C},
+{0x563B, 0x01},
+{0x563C, 0x01},
+{0x563D, 0x01},
+{0x563E, 0x01},
+{0x563F, 0x03},
+{0x5640, 0x03},
+{0x5641, 0x03},
+{0x5642, 0x05},
+{0x5643, 0x09},
+{0x5644, 0x05},
+{0x5645, 0x05},
+{0x5646, 0x05},
+{0x5647, 0x05},
+{0x5651, 0x00},
+{0x5652, 0x80},
+{0x521A, 0x01},
+{0x521B, 0x03},
+{0x521C, 0x06},
+{0x521D, 0x0A},
+{0x521E, 0x0E},
+{0x521F, 0x12},
+{0x5220, 0x16},
+{0x5223, 0x02},
+{0x5225, 0x04},
+{0x5227, 0x08},
+{0x5229, 0x0C},
+{0x522B, 0x12},
+{0x522D, 0x18},
+{0x522F, 0x1E},
+{0x5241, 0x04},
+{0x5242, 0x01},
+{0x5243, 0x03},
+{0x5244, 0x06},
+{0x5245, 0x0A},
+{0x5246, 0x0E},
+{0x5247, 0x12},
+{0x5248, 0x16},
+{0x524A, 0x03},
+{0x524C, 0x04},
+{0x524E, 0x08},
+{0x5250, 0x0C},
+{0x5252, 0x12},
+{0x5254, 0x18},
+{0x5256, 0x1E},
+{0x4606, (2*OV10635_HTS) >> 8}, /* fifo_line_length = 2*hts */
+{0x4607, (2*OV10635_HTS) & 0xff},
+{0x460a, (2*(OV10635_HTS-OV10635_MAX_WIDTH)) >> 8}, /* fifo_hsync_start = 2*(hts - xres) */
+{0x460b, (2*(OV10635_HTS-OV10635_MAX_WIDTH)) & 0xff },
+{0x460C, 0x00},
+{0x4620, 0x0E},
+#if 0
+{0x4700, 0x02}, // BT656: mode is acceptable but artefact lines on left/bottom due to BT656 SAV/EAV are parsed as image data
+#else
+{0x4700, 0x04}, // BT601: 0x08 is also accaptable as HS/VS mode
+#endif
+{0x4701, 0x00},
+{0x4702, 0x01},
+{0x4004, 0x04},
+{0x4005, 0x18},
+{0x4001, 0x06},
+{0x4050, 0x22},
+{0x4051, 0x24},
+{0x4052, 0x02},
+{0x4057, 0x9C},
+{0x405A, 0x00},
+{0x4202, 0x02},
+{0x3023, 0x10},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x0100, 0x01},
+{0x6F10, 0x07},
+{0x6F11, 0x82},
+{0x6F12, 0x04},
+{0x6F13, 0x00},
+{0xD000, 0x19},
+{0xD001, 0xA0},
+{0xD002, 0x00},
+{0xD003, 0x01},
+{0xD004, 0xA9},
+{0xD005, 0xAD},
+{0xD006, 0x10},
+{0xD007, 0x40},
+{0xD008, 0x44},
+{0xD009, 0x00},
+{0xD00A, 0x68},
+{0xD00B, 0x00},
+{0xD00C, 0x15},
+{0xD00D, 0x00},
+{0xD00E, 0x00},
+{0xD00F, 0x00},
+{0xD040, 0x9C},
+{0xD041, 0x21},
+{0xD042, 0xFF},
+{0xD043, 0xF8},
+{0xD044, 0xD4},
+{0xD045, 0x01},
+{0xD046, 0x48},
+{0xD047, 0x00},
+{0xD048, 0xD4},
+{0xD049, 0x01},
+{0xD04A, 0x50},
+{0xD04B, 0x04},
+{0xD04C, 0x18},
+{0xD04D, 0x60},
+{0xD04E, 0x00},
+{0xD04F, 0x01},
+{0xD050, 0xA8},
+{0xD051, 0x63},
+{0xD052, 0x02},
+{0xD053, 0xA4},
+{0xD054, 0x85},
+{0xD055, 0x43},
+{0xD056, 0x00},
+{0xD057, 0x00},
+{0xD058, 0x18},
+{0xD059, 0x60},
+{0xD05A, 0x00},
+{0xD05B, 0x01},
+{0xD05C, 0xA8},
+{0xD05D, 0x63},
+{0xD05E, 0x03},
+{0xD05F, 0xF0},
+{0xD060, 0x98},
+{0xD061, 0xA3},
+{0xD062, 0x00},
+{0xD063, 0x00},
+{0xD064, 0x8C},
+{0xD065, 0x6A},
+{0xD066, 0x00},
+{0xD067, 0x6E},
+{0xD068, 0xE5},
+{0xD069, 0x85},
+{0xD06A, 0x18},
+{0xD06B, 0x00},
+{0xD06C, 0x10},
+{0xD06D, 0x00},
+{0xD06E, 0x00},
+{0xD06F, 0x10},
+{0xD070, 0x9C},
+{0xD071, 0x80},
+{0xD072, 0x00},
+{0xD073, 0x03},
+{0xD074, 0x18},
+{0xD075, 0x60},
+{0xD076, 0x00},
+{0xD077, 0x01},
+{0xD078, 0xA8},
+{0xD079, 0x63},
+{0xD07A, 0x07},
+{0xD07B, 0x80},
+{0xD07C, 0x07},
+{0xD07D, 0xFF},
+{0xD07E, 0xF9},
+{0xD07F, 0x03},
+{0xD080, 0x8C},
+{0xD081, 0x63},
+{0xD082, 0x00},
+{0xD083, 0x00},
+{0xD084, 0xA5},
+{0xD085, 0x6B},
+{0xD086, 0x00},
+{0xD087, 0xFF},
+{0xD088, 0x18},
+{0xD089, 0x80},
+{0xD08A, 0x00},
+{0xD08B, 0x01},
+{0xD08C, 0xA8},
+{0xD08D, 0x84},
+{0xD08E, 0x01},
+{0xD08F, 0x04},
+{0xD090, 0xE1},
+{0xD091, 0x6B},
+{0xD092, 0x58},
+{0xD093, 0x00},
+{0xD094, 0x94},
+{0xD095, 0x6A},
+{0xD096, 0x00},
+{0xD097, 0x70},
+{0xD098, 0xE1},
+{0xD099, 0x6B},
+{0xD09A, 0x20},
+{0xD09B, 0x00},
+{0xD09C, 0x95},
+{0xD09D, 0x6B},
+{0xD09E, 0x00},
+{0xD09F, 0x00},
+{0xD0A0, 0xE4},
+{0xD0A1, 0x8B},
+{0xD0A2, 0x18},
+{0xD0A3, 0x00},
+{0xD0A4, 0x0C},
+{0xD0A5, 0x00},
+{0xD0A6, 0x00},
+{0xD0A7, 0x23},
+{0xD0A8, 0x15},
+{0xD0A9, 0x00},
+{0xD0AA, 0x00},
+{0xD0AB, 0x00},
+{0xD0AC, 0x18},
+{0xD0AD, 0x60},
+{0xD0AE, 0x80},
+{0xD0AF, 0x06},
+{0xD0B0, 0xA8},
+{0xD0B1, 0x83},
+{0xD0B2, 0x40},
+{0xD0B3, 0x08},
+{0xD0B4, 0xA8},
+{0xD0B5, 0xE3},
+{0xD0B6, 0x38},
+{0xD0B7, 0x2A},
+{0xD0B8, 0xA8},
+{0xD0B9, 0xC3},
+{0xD0BA, 0x40},
+{0xD0BB, 0x09},
+{0xD0BC, 0xA8},
+{0xD0BD, 0xA3},
+{0xD0BE, 0x38},
+{0xD0BF, 0x29},
+{0xD0C0, 0x8C},
+{0xD0C1, 0x65},
+{0xD0C2, 0x00},
+{0xD0C3, 0x00},
+{0xD0C4, 0xD8},
+{0xD0C5, 0x04},
+{0xD0C6, 0x18},
+{0xD0C7, 0x00},
+{0xD0C8, 0x8C},
+{0xD0C9, 0x67},
+{0xD0CA, 0x00},
+{0xD0CB, 0x00},
+{0xD0CC, 0xD8},
+{0xD0CD, 0x06},
+{0xD0CE, 0x18},
+{0xD0CF, 0x00},
+{0xD0D0, 0x18},
+{0xD0D1, 0x60},
+{0xD0D2, 0x80},
+{0xD0D3, 0x06},
+{0xD0D4, 0xA8},
+{0xD0D5, 0xE3},
+{0xD0D6, 0x67},
+{0xD0D7, 0x02},
+{0xD0D8, 0xA9},
+{0xD0D9, 0x03},
+{0xD0DA, 0x67},
+{0xD0DB, 0x03},
+{0xD0DC, 0xA8},
+{0xD0DD, 0xC3},
+{0xD0DE, 0x3D},
+{0xD0DF, 0x05},
+{0xD0E0, 0x8C},
+{0xD0E1, 0x66},
+{0xD0E2, 0x00},
+{0xD0E3, 0x00},
+{0xD0E4, 0xB8},
+{0xD0E5, 0x63},
+{0xD0E6, 0x00},
+{0xD0E7, 0x18},
+{0xD0E8, 0xB8},
+{0xD0E9, 0x63},
+{0xD0EA, 0x00},
+{0xD0EB, 0x98},
+{0xD0EC, 0xBC},
+{0xD0ED, 0x03},
+{0xD0EE, 0x00},
+{0xD0EF, 0x00},
+{0xD0F0, 0x10},
+{0xD0F1, 0x00},
+{0xD0F2, 0x00},
+{0xD0F3, 0x16},
+{0xD0F4, 0xB8},
+{0xD0F5, 0x83},
+{0xD0F6, 0x00},
+{0xD0F7, 0x19},
+{0xD0F8, 0x8C},
+{0xD0F9, 0x67},
+{0xD0FA, 0x00},
+{0xD0FB, 0x00},
+{0xD0FC, 0xB8},
+{0xD0FD, 0xA4},
+{0xD0FE, 0x00},
+{0xD0FF, 0x98},
+{0xD100, 0xB8},
+{0xD101, 0x83},
+{0xD102, 0x00},
+{0xD103, 0x08},
+{0xD104, 0x8C},
+{0xD105, 0x68},
+{0xD106, 0x00},
+{0xD107, 0x00},
+{0xD108, 0xE0},
+{0xD109, 0x63},
+{0xD10A, 0x20},
+{0xD10B, 0x04},
+{0xD10C, 0xE0},
+{0xD10D, 0x65},
+{0xD10E, 0x18},
+{0xD10F, 0x00},
+{0xD110, 0xA4},
+{0xD111, 0x83},
+{0xD112, 0xFF},
+{0xD113, 0xFF},
+{0xD114, 0xB8},
+{0xD115, 0x64},
+{0xD116, 0x00},
+{0xD117, 0x48},
+{0xD118, 0xD8},
+{0xD119, 0x07},
+{0xD11A, 0x18},
+{0xD11B, 0x00},
+{0xD11C, 0xD8},
+{0xD11D, 0x08},
+{0xD11E, 0x20},
+{0xD11F, 0x00},
+{0xD120, 0x9C},
+{0xD121, 0x60},
+{0xD122, 0x00},
+{0xD123, 0x00},
+{0xD124, 0xD8},
+{0xD125, 0x06},
+{0xD126, 0x18},
+{0xD127, 0x00},
+{0xD128, 0x00},
+{0xD129, 0x00},
+{0xD12A, 0x00},
+{0xD12B, 0x08},
+{0xD12C, 0x15},
+{0xD12D, 0x00},
+{0xD12E, 0x00},
+{0xD12F, 0x00},
+{0xD130, 0x8C},
+{0xD131, 0x6A},
+{0xD132, 0x00},
+{0xD133, 0x76},
+{0xD134, 0xBC},
+{0xD135, 0x23},
+{0xD136, 0x00},
+{0xD137, 0x00},
+{0xD138, 0x13},
+{0xD139, 0xFF},
+{0xD13A, 0xFF},
+{0xD13B, 0xE6},
+{0xD13C, 0x18},
+{0xD13D, 0x60},
+{0xD13E, 0x80},
+{0xD13F, 0x06},
+{0xD140, 0x03},
+{0xD141, 0xFF},
+{0xD142, 0xFF},
+{0xD143, 0xDD},
+{0xD144, 0xA8},
+{0xD145, 0x83},
+{0xD146, 0x40},
+{0xD147, 0x08},
+{0xD148, 0x85},
+{0xD149, 0x21},
+{0xD14A, 0x00},
+{0xD14B, 0x00},
+{0xD14C, 0x85},
+{0xD14D, 0x41},
+{0xD14E, 0x00},
+{0xD14F, 0x04},
+{0xD150, 0x44},
+{0xD151, 0x00},
+{0xD152, 0x48},
+{0xD153, 0x00},
+{0xD154, 0x9C},
+{0xD155, 0x21},
+{0xD156, 0x00},
+{0xD157, 0x08},
+{0x6F0E, 0x03},
+{0x6F0F, 0x00},
+{0x460E, 0x08},
+{0x460F, 0x01},
+{0x4610, 0x00},
+{0x4611, 0x01},
+{0x4612, 0x00},
+{0x4613, 0x01},
+{0x4605, 0x08}, // 8bit
+//{0x4709, 0x10}, // swap data bits order [9:0] -> [0:9]
+{0x4608, 0x00},
+{0x4609, 0x08},
+{0x6804, 0x00},
+{0x6805, 0x06},
+{0x6806, 0x00},
+{0x5120, 0x00},
+{0x3510, 0x00},
+{0x3504, 0x00},
+{0x6800, 0x00},
+{0x6F0D, 0x01},
+{0x4708, 0x01}, // PCLK rising edge, VSYNC active low
+{0x5000, 0xFF},
+{0x5001, 0xBF},
+{0x5002, 0x7E},
+#ifdef OV10635_DISPLAY_PATTERN
+{0x503d, 0x80},
+#else
+{0x503D, 0x00},
+#endif
+{0xC450, 0x01}, /* AA mode */
+{0xC452, 0x04},
+{0xC453, 0x00},
+{0xC454, 0x00},
+{0xC455, 0x01},
+{0xC456, 0x01},
+{0xC457, 0x00},
+{0xC458, 0x00},
+{0xC459, 0x00},
+{0xC45B, 0x00},
+{0xC45C, 0x01},
+{0xC45D, 0x00},
+{0xC45E, 0x00},
+{0xC45F, 0x00},
+{0xC460, 0x00},
+{0xC461, 0x01},
+{0xC462, 0x01},
+{0xC464, 0x03},
+{0xC465, 0x00},
+{0xC466, 0x8A},
+{0xC467, 0x00},
+{0xC468, 0x86},
+{0xC469, 0x00},
+{0xC46A, 0x30},
+{0xC46B, 0x50},
+{0xC46C, 0x30},
+{0xC46D, 0x28},
+{0xC46E, 0x60},
+{0xC46F, 0x40},
+{0xC47C, 0x01},
+{0xC47D, 0x38},
+{0xC47E, 0x00},
+{0xC47F, 0x00},
+{0xC480, 0x00},
+{0xC481, 0xFF},
+{0xC482, 0x00},
+{0xC483, 0x40},
+{0xC484, 0x00},
+{0xC485, 0x18},
+{0xC486, 0x00},
+{0xC487, 0x18},
+{0xC488, (OV10635_VTS-8)*16 >> 8},
+{0xC489, (OV10635_VTS-8)*16 & 0xff},
+{0xC48A, (OV10635_VTS-8)*16 >> 8},
+{0xC48B, (OV10635_VTS-8)*16 & 0xff},
+{0xC48C, 0x00},
+{0xC48D, 0x04},
+{0xC48E, 0x00},
+{0xC48F, 0x04},
+{0xC490, 0x03},
+{0xC492, 0x20},
+{0xC493, 0x08},
+{0xC498, 0x02},
+{0xC499, 0x00},
+{0xC49A, 0x02},
+{0xC49B, 0x00},
+{0xC49C, 0x02},
+{0xC49D, 0x00},
+{0xC49E, 0x02},
+{0xC49F, 0x60},
+{0xC4A0, 0x03},
+{0xC4A1, 0x00},
+{0xC4A2, 0x04},
+{0xC4A3, 0x00},
+{0xC4A4, 0x00},
+{0xC4A5, 0x10},
+{0xC4A6, 0x00},
+{0xC4A7, 0x40},
+{0xC4A8, 0x00},
+{0xC4A9, 0x80},
+{0xC4AA, 0x0D},
+{0xC4AB, 0x00},
+{0xC4AC, 0x0F},
+{0xC4AD, 0xC0},
+{0xC4B4, 0x01},
+{0xC4B5, 0x01},
+{0xC4B6, 0x00},
+{0xC4B7, 0x01},
+{0xC4B8, 0x00},
+{0xC4B9, 0x01},
+{0xC4BA, 0x01},
+{0xC4BB, 0x00},
+{0xC4BC, 0x01},
+{0xC4BD, 0x60},
+{0xC4BE, 0x02},
+{0xC4BF, 0x33},
+{0xC4C8, 0x03},
+{0xC4C9, 0xD0},
+{0xC4CA, 0x0E},
+{0xC4CB, 0x00},
+{0xC4CC, 0x0E},
+{0xC4CD, 0x51},
+{0xC4CE, 0x0E},
+{0xC4CF, 0x51},
+{0xC4D0, 0x04},
+{0xC4D1, 0x80},
+{0xC4E0, 0x04},
+{0xC4E1, 0x02},
+{0xC4E2, 0x01},
+{0xC4E4, 0x10},
+{0xC4E5, 0x20},
+{0xC4E6, 0x30},
+{0xC4E7, 0x40},
+{0xC4E8, 0x50},
+{0xC4E9, 0x60},
+{0xC4EA, 0x70},
+{0xC4EB, 0x80},
+{0xC4EC, 0x90},
+{0xC4ED, 0xA0},
+{0xC4EE, 0xB0},
+{0xC4EF, 0xC0},
+{0xC4F0, 0xD0},
+{0xC4F1, 0xE0},
+{0xC4F2, 0xF0},
+{0xC4F3, 0x80},
+{0xC4F4, 0x00},
+{0xC4F5, 0x20},
+{0xC4F6, 0x02},
+{0xC4F7, 0x00},
+{0xC4F8, 0x00},
+{0xC4F9, 0x00},
+{0xC4FA, 0x00},
+{0xC4FB, 0x01},
+{0xC4FC, 0x01},
+{0xC4FD, 0x00},
+{0xC4FE, 0x04},
+{0xC4FF, 0x02},
+{0xC500, 0x48},
+{0xC501, 0x74},
+{0xC502, 0x58},
+{0xC503, 0x80},
+{0xC504, 0x05},
+{0xC505, 0x80},
+{0xC506, 0x03},
+{0xC507, 0x80},
+{0xC508, 0x01},
+{0xC509, 0xC0},
+{0xC50A, 0x01},
+{0xC50B, 0xA0},
+{0xC50C, 0x01},
+{0xC50D, 0x2C},
+{0xC50E, 0x01},
+{0xC50F, 0x0A},
+{0xC510, 0x00},
+{0xC511, 0x00},
+{0xC512, 0xE5},
+{0xC513, 0x14},
+{0xC514, 0x04},
+{0xC515, 0x00},
+{0xC518, OV10635_VTS >> 8},
+{0xC519, OV10635_VTS & 0xff},
+{0xC51A, OV10635_HTS >> 8},
+{0xC51B, OV10635_HTS & 0xff},
+{0xC2E0, 0x00},
+{0xC2E1, 0x51},
+{0xC2E2, 0x00},
+{0xC2E3, 0xD6},
+{0xC2E4, 0x01},
+{0xC2E5, 0x5E},
+{0xC2E9, 0x01},
+{0xC2EA, 0x7A},
+{0xC2EB, 0x90},
+{0xC2ED, 0x00},
+{0xC2EE, 0x7A},
+{0xC2EF, 0x64},
+{0xC308, 0x00},
+{0xC309, 0x00},
+{0xC30A, 0x00},
+{0xC30C, 0x00},
+{0xC30D, 0x01},
+{0xC30E, 0x00},
+{0xC30F, 0x00},
+{0xC310, 0x01},
+{0xC311, 0x60},
+{0xC312, 0xFF},
+{0xC313, 0x08},
+{0xC314, 0x01},
+{0xC315, 0x00}, /* min saturation gain */
+{0xC316, 0xFF}, /* max saturation gain */
+{0xC317, 0x0B},
+{0xC318, 0x00},
+{0xC319, 0x0C},
+{0xC31A, 0x00},
+{0xC31B, 0xE0},
+{0xC31C, 0x00},
+{0xC31D, 0x14},
+{0xC31E, 0x00},
+{0xC31F, 0xC5},
+{0xC320, 0xFF},
+{0xC321, 0x4B},
+{0xC322, 0xFF},
+{0xC323, 0xF0},
+{0xC324, 0xFF},
+{0xC325, 0xE8},
+{0xC326, 0x00},
+{0xC327, 0x46},
+{0xC328, 0xFF},
+{0xC329, 0xD2},
+{0xC32A, 0xFF},
+{0xC32B, 0xE4},
+{0xC32C, 0xFF},
+{0xC32D, 0xBB},
+{0xC32E, 0x00},
+{0xC32F, 0x61},
+{0xC330, 0xFF},
+{0xC331, 0xF9},
+{0xC332, 0x00},
+{0xC333, 0xD9},
+{0xC334, 0x00},
+{0xC335, 0x2E},
+{0xC336, 0x00},
+{0xC337, 0xB1},
+{0xC338, 0xFF},
+{0xC339, 0x64},
+{0xC33A, 0xFF},
+{0xC33B, 0xEB},
+{0xC33C, 0xFF},
+{0xC33D, 0xE8},
+{0xC33E, 0x00},
+{0xC33F, 0x48},
+{0xC340, 0xFF},
+{0xC341, 0xD0},
+{0xC342, 0xFF},
+{0xC343, 0xED},
+{0xC344, 0xFF},
+{0xC345, 0xAD},
+{0xC346, 0x00},
+{0xC347, 0x66},
+{0xC348, 0x01},
+{0xC349, 0x00},
+{0x6700, 0x04},
+{0x6701, 0x7B},
+{0x6702, 0xFD},
+{0x6703, 0xF9},
+{0x6704, 0x3D},
+{0x6705, 0x71},
+{0x6706, 0x78},
+{0x6708, 0x05},
+{0x6F06, 0x6F},
+{0x6F07, 0x00},
+{0x6F0A, 0x6F},
+{0x6F0B, 0x00},
+{0x6F00, 0x03},
+{0xC34C, 0x01},
+{0xC34D, 0x00},
+{0xC34E, 0x46},
+{0xC34F, 0x55},
+{0xC350, 0x00},
+{0xC351, 0x40},
+{0xC352, 0x00},
+{0xC353, 0xFF},
+{0xC354, 0x04},
+{0xC355, 0x08},
+{0xC356, 0x01},
+{0xC357, 0xEF},
+{0xC358, 0x30},
+{0xC359, 0x01},
+{0xC35A, 0x64},
+{0xC35B, 0x46},
+{0xC35C, 0x00},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0x3042, 0xF0},
+{0xC261, 0x01},
+{0x301B, 0xF0},
+{0x301C, 0xF0},
+{0x301A, 0xF0},
+{0x6F00, 0xC3},
+{0xC46A, 0x30},
+{0xC46D, 0x20},
+{0xC464, 0x84},
+{0xC465, 0x00},
+{0x6F00, 0x03},
+{0x6F00, 0x43},
+{0x381C, 0x00},
+{0x381D, 0x40},
+{0xC454, 0x01},
+{0x6F00, 0xC3},
+{0xC454, 0x00},
+{0xC4B1, 0x02},
+{0xC4B2, 0x01},
+{0xC4B3, 0x03},
+{0x6F00, 0x03},
+{0x6F00, 0x43},
+/* enable FSIN (FRAMESYNC input) functionality */
+{0x3832, (0x0d+2*0x20+0x15+38) >> 8},
+{0x3833, (0x0d+2*0x20+0x15+38) & 0xff},
+{0x3834, OV10635_VTS >> 8},
+{0x3835, OV10635_VTS & 0xff},
+{0x302E, 0x01},
+};
+
+static const struct ov10635_reg ov10635_regs_30fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+1)=96Mhz, 30fps */
+{0x3003, 0x20},
+{0x3004, 0x21},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_15fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+3)=48Mhz, 15fps */
+{0x3003, 0x20},
+{0x3004, 0x23},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_10fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/2*32/2(1+5)=32Mhz, 10fps */
+{0x3003, 0x20},
+{0x3004, 0x25},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_5fps[] = {
+/* disable clocks */
+{0x301b, 0xff},
+{0x301c, 0xff},
+{0x301a, 0xff},
+/* clk = 24Mhz/4*32/2(1+5)=96Mhz, 5fps */
+{0x3003, 0x20},
+{0x3004, 0x45},
+/* enable clocks */
+{0x301b, 0xf0},
+{0x301c, 0xf0},
+{0x301a, 0xf0},
+};
+
+static const struct ov10635_reg ov10635_regs_contrast[5][18] = {
+{
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x20},
+	{0xc4e5, 0x40},
+	{0xc4e6, 0x60},
+	{0xc4e7, 0x80},
+	{0xc4e8, 0xa0},
+	{0xc4e9, 0xb4},
+	{0xc4ea, 0xc0},
+	{0xc4eb, 0xcb},
+	{0xc4ec, 0xd5},
+	{0xc4ed, 0xde},
+	{0xc4ee, 0xe6},
+	{0xc4ef, 0xed},
+	{0xc4f0, 0xf3},
+	{0xc4f1, 0xf8},
+	{0xc4f2, 0xfc},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x18},
+	{0xc4e5, 0x30},
+	{0xc4e6, 0x48},
+	{0xc4e7, 0x60},
+	{0xc4e8, 0x78},
+	{0xc4e9, 0x90},
+	{0xc4ea, 0xa4},
+	{0xc4eb, 0xb4},
+	{0xc4ec, 0xc2},
+	{0xc4ed, 0xcf},
+	{0xc4ee, 0xdb},
+	{0xc4ef, 0xe5},
+	{0xc4f0, 0xee},
+	{0xc4f1, 0xf6},
+	{0xc4f2, 0xfc},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x10},
+	{0xc4e5, 0x20},
+	{0xc4e6, 0x30},
+	{0xc4e7, 0x40},
+	{0xc4e8, 0x50},
+	{0xc4e9, 0x60},
+	{0xc4ea, 0x70},
+	{0xc4eb, 0x80},
+	{0xc4ec, 0x90},
+	{0xc4ed, 0xa0},
+	{0xc4ee, 0xb0},
+	{0xc4ef, 0xc0},
+	{0xc4f0, 0xd0},
+	{0xc4f1, 0xe0},
+	{0xc4f2, 0xf0},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x0c},
+	{0xc4e5, 0x18},
+	{0xc4e6, 0x24},
+	{0xc4e7, 0x30},
+	{0xc4e8, 0x3c},
+	{0xc4e9, 0x48},
+	{0xc4ea, 0x54},
+	{0xc4eb, 0x62},
+	{0xc4ec, 0x72},
+	{0xc4ed, 0x84},
+	{0xc4ee, 0x94},
+	{0xc4ef, 0xa6},
+	{0xc4f0, 0xb9},
+	{0xc4f1, 0xcd},
+	{0xc4f2, 0xe2},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}, {
+	{0x6f00, 0xc3},
+	{0xc4e4, 0x06},
+	{0xc4e5, 0x0d},
+	{0xc4e6, 0x15},
+	{0xc4e7, 0x1e},
+	{0xc4e8, 0x28},
+	{0xc4e9, 0x32},
+	{0xc4ea, 0x3c},
+	{0xc4eb, 0x48},
+	{0xc4ec, 0x56},
+	{0xc4ed, 0x66},
+	{0xc4ee, 0x78},
+	{0xc4ef, 0x8c},
+	{0xc4f0, 0xa2},
+	{0xc4f1, 0xba},
+	{0xc4f2, 0xd4},
+	{0x6f00, 0x03},
+	{0x6f00, 0x43},
+}
+};
diff --git a/drivers/media/i2c/imagers/ov10635_debug.h b/drivers/media/i2c/imagers/ov10635_debug.h
new file mode 100644
index 0000000..4c3515a
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov10635_debug.h
@@ -0,0 +1,54 @@
+
+#if 0
+{0x4700, 0x02}, // BT656
+{0x381d, 0x40}, // mirror off
+{0x381c, 0x00}, // flip off
+{0x4300, 0x3a}, // YUV: UYVY
+{0x4708, 0x00}, // PCLK rising edge
+
+// clk = 24Mhz/3*22/2= 88Mhz
+{0x3003, 0x16},
+{0x3004, 0x30},
+#endif
+
+#define WIDTH 1280
+#define HEIGHT 720
+
+// DVP frame size
+{0x3808, WIDTH >> 8},
+{0x3809, WIDTH & 0xff},
+{0x380a, HEIGHT >> 8},
+{0x380b, HEIGHT & 0xff},
+
+{0x3802, ((814 - HEIGHT)/2) >> 8}, // vert crop start
+{0x3803, ((814 - HEIGHT)/2) & 0xff},
+{0x3806, ((814 - HEIGHT)/2 + HEIGHT + 1) >> 8}, // vert crop end
+{0x3807, ((814 - HEIGHT)/2 + HEIGHT + 1) & 0xff},
+
+#if 0
+#define HTS 0x6f6 // got from above table 1782
+#define VTS (0x2ec+80) // got from above table 748 + 80
+
+{0x380c, HTS >> 8}, // hts
+{0x380d, HTS & 0xff},
+{0x380e, VTS >> 8}, // vts
+{0x380f, VTS & 0xff},
+
+// fifo
+{0x4606, (2*HTS) >> 8}, // fifo_line_length = 2*hts
+{0x4607, (2*HTS) & 0xff},
+{0x460a, (2*(HTS-1280)) >> 8}, // fifo_hsync_start = 2*(hts - xres)
+{0x460b, (2*(HTS-1280)) & 0xff },
+
+// exposure
+{0xC488, (VTS-8)*16 >> 8},
+{0xC489, (VTS-8)*16 & 0xff},
+{0xC48A, (VTS-8)*16 >> 8},
+{0xC48B, (VTS-8)*16 & 0xff},
+
+// vts/hts
+{0xC518, VTS >> 8},
+{0xC519, VTS & 0xff},
+{0xC51A, HTS >> 8},
+{0xC51B, HTS & 0xff},
+#endif
diff --git a/drivers/media/i2c/imagers/ov2311.c b/drivers/media/i2c/imagers/ov2311.c
new file mode 100644
index 0000000..6f9329b
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov2311.c
@@ -0,0 +1,588 @@
+/*
+ * OmniVision ov2311 sensor camera driver
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov2311.h"
+
+#define OV2311_I2C_ADDR			0x60
+
+#define OV2311_PIDA_REG			0x300a
+#define OV2311_PIDB_REG			0x300b
+#define OV2311_REV_REG			0x300c
+#define OV2311_PID			0x2311
+
+#define OV2311_MEDIA_BUS_FMT		MEDIA_BUS_FMT_Y8_1X8
+
+struct ov2311_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				subsampling;
+	int				fps_denominator;
+	int				init_complete;
+	u8				id[6];
+	int				dvp_order;
+	/* serializers */
+	int				ser_addr;
+};
+
+static inline struct ov2311_priv *to_ov2311(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov2311_priv, sd);
+}
+
+static inline struct v4l2_subdev *ov2311_to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov2311_priv, hdl)->sd;
+}
+
+static int ov2311_set_regs(struct i2c_client *client,
+			   const struct ov2311_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (regs[i].reg == OV2311_DELAY) {
+			mdelay(regs[i].val);
+			continue;
+		}
+
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100ns */
+			reg16_write(client, regs[i].reg, regs[i].val);
+		}
+	}
+
+	return 0;
+}
+
+static void ov2311_otp_id_read(struct i2c_client *client)
+{
+	struct ov2311_priv *priv = to_ov2311(client);
+	int i;
+
+	reg16_write(client, 0x3d81, 1);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++) {
+		/* first 6 bytes are equal on all ov2311 */
+		reg16_read(client, 0x7000 + i + 6, &priv->id[i]);
+	}
+}
+
+static int ov2311_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov2311_set_window(struct v4l2_subdev *sd)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	dev_dbg(&client->dev, "L=%d T=%d %dx%d\n", priv->rect.left, priv->rect.top, priv->rect.width, priv->rect.height);
+#if 0
+	/* setup resolution */
+	reg16_write(client, 0x3808, priv->rect.width >> 8);
+	reg16_write(client, 0x3809, priv->rect.width & 0xff);
+	reg16_write(client, 0x380a, priv->rect.height >> 8);
+	reg16_write(client, 0x380b, priv->rect.height & 0xff);
+
+	/* horiz isp windowstart */
+	reg16_write(client, 0x3810, priv->rect.left >> 8);
+	reg16_write(client, 0x3811, priv->rect.left & 0xff);
+	reg16_write(client, 0x3812, priv->rect.top >> 8);
+	reg16_write(client, 0x3813, priv->rect.top & 0xff);
+#endif
+	return 0;
+};
+
+static int ov2311_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV2311_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov2311_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV2311_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov2311_enum_mbus_code(struct v4l2_subdev *sd,
+				  struct v4l2_subdev_pad_config *cfg,
+				  struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV2311_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov2311_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV2311_PID >> 8;
+	edid->edid[9] = OV2311_PID & 0xff;
+
+	return 0;
+}
+
+static int ov2311_set_selection(struct v4l2_subdev *sd,
+				 struct v4l2_subdev_pad_config *cfg,
+				 struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > OV2311_MAX_WIDTH) ||
+	    (rect->top + rect->height > OV2311_MAX_HEIGHT))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	ov2311_set_window(sd);
+
+	return 0;
+}
+
+static int ov2311_get_selection(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV2311_MAX_WIDTH;
+		sel->r.height = OV2311_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = OV2311_MAX_WIDTH;
+		sel->r.height = OV2311_MAX_HEIGHT;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov2311_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+				struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov2311_g_register(struct v4l2_subdev *sd,
+			     struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	__be64 be_val;
+
+	if (!reg->size)
+		reg->size = sizeof(u8);
+	if (reg->size > sizeof(reg->val))
+		reg->size = sizeof(reg->val);
+
+	ret = reg16_read_n(client, (u16)reg->reg, (u8*)&be_val, reg->size);
+	be_val = be_val << ((sizeof(be_val) - reg->size) * 8);
+	reg->val = be64_to_cpu(be_val);
+
+	return ret;
+}
+
+static int ov2311_s_register(struct v4l2_subdev *sd,
+			      const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	u32 size = reg->size;
+	int ret;
+	__be64 be_val;
+
+	if (!size)
+		size = sizeof(u8);
+	if (size > sizeof(reg->val))
+		size = sizeof(reg->val);
+
+	be_val = cpu_to_be64(reg->val);
+	be_val = be_val >> ((sizeof(be_val) - size) * 8);
+	ret = reg16_write_n(client, (u16)reg->reg, (u8*)&be_val, size);
+
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov2311_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov2311_g_register,
+	.s_register = ov2311_s_register,
+#endif
+};
+
+static int ov2311_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = ov2311_to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+	int ret = 0;
+	u8 val = 0;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+	case V4L2_CID_CONTRAST:
+	case V4L2_CID_SATURATION:
+	case V4L2_CID_HUE:
+	case V4L2_CID_GAMMA:
+		break;
+	case V4L2_CID_GAIN:
+		reg16_write(client, 0x350A, ctrl->val / 0x3ff); // COARSE: 4.10 format
+		reg16_write(client, 0x350B, (ctrl->val % 0x3ff) >> 2); // FINE: 4.10 format
+		reg16_write(client, 0x350C, (ctrl->val % 0x3ff) << 6); // FINE: 4.10 format
+		break;
+	case V4L2_CID_ANALOGUE_GAIN:
+		reg16_write(client, 0x3508, ctrl->val / 0xf); // COARSE: 5.4 format
+		reg16_write(client, 0x3509, (ctrl->val % 0xf) << 4); // FINE: 5.4 format
+		break;
+	case V4L2_CID_EXPOSURE:
+		reg16_write(client, 0x3501, ctrl->val >> 8);
+		reg16_write(client, 0x3502, ctrl->val & 0xff);
+		break;
+	case V4L2_CID_HFLIP:
+		reg16_read(client, 0x3821, &val);
+		val &= ~0x04;
+		val |= (ctrl->val ? 0x04 : 0);
+		reg16_write(client, 0x3821, val);
+		break;
+	case V4L2_CID_VFLIP:
+		reg16_read(client, 0x3820, &val);
+		val &= ~0x44;
+		val |= (ctrl->val ? 0x44 : 0);
+		reg16_write(client, 0x3820, val);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov2311_ctrl_ops = {
+	.s_ctrl = ov2311_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov2311_video_ops = {
+	.s_stream	= ov2311_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov2311_subdev_pad_ops = {
+	.get_edid	= ov2311_get_edid,
+	.enum_mbus_code	= ov2311_enum_mbus_code,
+	.get_selection	= ov2311_get_selection,
+	.set_selection	= ov2311_set_selection,
+	.get_fmt	= ov2311_get_fmt,
+	.set_fmt	= ov2311_set_fmt,
+	.get_mbus_config	= ov2311_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ov2311_subdev_ops = {
+	.core	= &ov2311_core_ops,
+	.video	= &ov2311_video_ops,
+	.pad	= &ov2311_subdev_pad_ops,
+};
+
+static ssize_t ov2311_otp_id_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov2311_priv *priv = to_ov2311(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov2311, S_IRUGO, ov2311_otp_id_show, NULL);
+
+static int ov2311_initialize(struct i2c_client *client)
+{
+	struct ov2311_priv *priv = to_ov2311(client);
+	u16 pid;
+	u8 val = 0, rev = 0;
+
+	setup_i2c_translator(client, priv->ser_addr, OV2311_I2C_ADDR);
+
+	reg16_read(client, OV2311_PIDA_REG, &val);
+	pid = val;
+	reg16_read(client, OV2311_PIDB_REG, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV2311_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	switch (get_des_id(client)) {
+	case UB960_ID:
+		reg8_write_addr(client, priv->ser_addr, 0x02, 0x13); /* MIPI 2-lanes */
+		break;
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		reg16_write_addr(client, priv->ser_addr, MAX9295_MIPI_RX1, 0x11); /* MIPI 2-lanes */
+		break;
+	}
+
+	/* check revision */
+	reg16_read(client, OV2311_REV_REG, &rev);
+	/* Program wizard registers */
+	ov2311_set_regs(client, ov2311_regs_r1c, ARRAY_SIZE(ov2311_regs_r1c));
+	/* Read OTP IDs */
+	ov2311_otp_id_read(client);
+
+	dev_info(&client->dev, "PID %x (rev %x), res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, rev, OV2311_MAX_WIDTH, OV2311_MAX_HEIGHT, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov2311_parse_dt(struct device_node *np, struct ov2311_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	u32 addrs[2], naddrs;
+	struct fwnode_handle *ep;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ov2311_probe(struct i2c_client *client,
+			const struct i2c_device_id *did)
+{
+	struct ov2311_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov2311_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = OV2311_MAX_WIDTH;
+	priv->rect.height = OV2311_MAX_HEIGHT;
+	priv->fps_denominator = 30;
+
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 0xff, 1, 0x30);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 4, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 0xff, 1, 0xff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_HUE, 0, 255, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_GAMMA, 0, 0xffff, 1, 0x233);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0x3ff*4, 1, 0x3ff);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_ANALOGUE_GAIN, 0, 0xf*5, 1, 0xf);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0x580, 1, 0x57c);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov2311_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov2311_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov2311_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov2311) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov2311_remove(struct i2c_client *client)
+{
+	struct ov2311_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov2311);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov2311_id[] = {
+	{ "ov2311", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov2311_id);
+
+static const struct of_device_id ov2311_of_ids[] = {
+	{ .compatible = "ovti,ov2311", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov2311_of_ids);
+
+static struct i2c_driver ov2311_i2c_driver = {
+	.driver	= {
+		.name		= "ov2311",
+		.of_match_table	= ov2311_of_ids,
+	},
+	.probe		= ov2311_probe,
+	.remove		= ov2311_remove,
+	.id_table	= ov2311_id,
+};
+
+module_i2c_driver(ov2311_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV2311");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov2311.h b/drivers/media/i2c/imagers/ov2311.h
new file mode 100644
index 0000000..a525b9f
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov2311.h
@@ -0,0 +1,217 @@
+/*
+ * OmniVision ov2311 sensor camera setup 1600x130@30/GREY8/MIPI
+ *
+ * Copyright (C) 2015-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV2311_DISPLAY_PATTERN
+//#define OV2311_FSIN_ENABLE
+
+#define OV2311_MAX_WIDTH	1600
+#define OV2311_MAX_HEIGHT	1300
+
+#define OV2311_DELAY		0xffff
+
+#define OV2311_SENSOR_WIDTH	1616
+#define OV2311_SENSOR_HEIGHT	1316
+
+#define OV2311_X_START		((OV2311_SENSOR_WIDTH - OV2311_MAX_WIDTH) / 2)
+#define OV2311_Y_START		((OV2311_SENSOR_HEIGHT - OV2311_MAX_HEIGHT) / 2)
+#define OV2311_X_END		(OV2311_X_START + OV2311_MAX_WIDTH - 1)
+#define OV2311_Y_END		(OV2311_Y_START + OV2311_MAX_HEIGHT - 1)
+
+struct ov2311_reg {
+	u16	reg;
+	u8	val;
+};
+
+/* R1600x1300 RAW8 MIPI 60fps */
+static const struct ov2311_reg ov2311_regs_r1c[] = {
+{0x0103, 0x01},
+{0x0100, 0x00},
+{0x010c, 0x02},
+{0x010b, 0x01},
+{0x0300, 0x01},
+{0x0302, 0x32},
+{0x0303, 0x00},
+{0x0304, 0x03},
+{0x0305, 0x02},
+{0x0306, 0x01},
+{0x030d, 0x5a},
+{0x030e, 0x04},
+{0x3001, 0x02},
+{0x3004, 0x00},
+{0x3005, 0x00},
+{0x3006, 0x0a},
+{0x3011, 0x0d},
+{0x3014, 0x04},
+{0x301c, 0xf0},
+{0x3020, 0x20},
+{0x302c, 0x00},
+{0x302d, 0x00},
+{0x302e, 0x00},
+{0x302f, 0x03},
+{0x3030, 0x10},
+{0x303f, 0x03},
+{0x3103, 0x00},
+{0x3106, 0x08},
+{0x31ff, 0x01},
+{0x3501, 0x05},
+{0x3502, 0x7c},
+{0x3506, 0x00},
+{0x3507, 0x00},
+{0x3620, 0x67},
+{0x3633, 0x78},
+{0x3662, 0x65},
+{0x3664, 0xb0},
+{0x3666, 0x70},
+{0x3670, 0x68},
+{0x3674, 0x10},
+{0x3675, 0x00},
+{0x367e, 0x90},
+{0x3680, 0x84},
+{0x36a2, 0x04},
+{0x36a3, 0x80},
+{0x36b0, 0x00},
+{0x3700, 0x35},
+{0x3704, 0x39},
+{0x370a, 0x50},
+{0x3712, 0x00},
+{0x3713, 0x02},
+{0x3778, 0x00},
+{0x379b, 0x01},
+{0x379c, 0x10},
+{0x3800, 0x00},
+{0x3801, 0x00},
+{0x3802, 0x00},
+{0x3803, 0x00},
+{0x3804, 0x06},
+{0x3805, 0x4f},
+{0x3806, 0x05},
+{0x3807, 0x23},
+{0x3808, OV2311_MAX_WIDTH >> 8},
+{0x3809, OV2311_MAX_WIDTH & 0xff},
+{0x380a, OV2311_MAX_HEIGHT >> 8},
+{0x380b, OV2311_MAX_HEIGHT & 0xff},
+{0x380c, 0x03},
+{0x380d, 0xa8},
+{0x380e, 0x05},
+{0x380f, 0x88},
+{0x3810, OV2311_X_START >> 8},
+{0x3811, OV2311_X_START & 0xff},
+{0x3812, OV2311_Y_START >> 8},
+{0x3813, OV2311_X_START & 0xff},
+{0x3814, 0x11},
+{0x3815, 0x11},
+{0x3816, 0x00},
+{0x3817, 0x01},
+{0x3818, 0x00},
+{0x3819, 0x05},
+{0x3820, 0x00},
+{0x3821, 0x00},
+{0x382b, 0x5a},
+{0x382c, 0x0a},
+{0x382d, 0xf8},
+{0x3881, 0x44},
+{0x3882, 0x02},
+{0x3883, 0x8c},
+{0x3885, 0x07},
+{0x389d, 0x03},
+{0x38a6, 0x00},
+{0x38a7, 0x01},
+{0x38b3, 0x07},
+{0x38b1, 0x00},
+{0x38e5, 0x02},
+{0x38e7, 0x00},
+{0x38e8, 0x00},
+{0x3910, 0xff},
+{0x3911, 0xff},
+{0x3912, 0x08},
+{0x3913, 0x00},
+{0x3914, 0x00},
+{0x3915, 0x00},
+{0x391c, 0x00},
+{0x3920, 0xff},
+{0x3921, 0x80},
+{0x3922, 0x00},
+{0x3923, 0x00},
+{0x3924, 0x05},
+{0x3925, 0x00},
+{0x3926, 0x00},
+{0x3927, 0x00},
+{0x3928, 0x1a},
+{0x392d, 0x03},
+{0x392e, 0xa8},
+{0x392f, 0x08},
+{0x4001, 0x00},
+{0x4003, 0x40},
+{0x4008, 0x04},
+{0x4009, 0x1b},
+{0x400c, 0x04},
+{0x400d, 0x1b},
+{0x4010, 0xf4},
+{0x4011, 0x00},
+{0x4016, 0x00},
+{0x4017, 0x04},
+{0x4042, 0x11},
+{0x4043, 0x70},
+{0x4045, 0x00},
+{0x4409, 0x5f},
+{0x4509, 0x00},
+{0x450b, 0x00},
+{0x4600, 0x00},
+{0x4601, 0xa0},
+{0x4708, 0x09},
+{0x470c, 0x81},
+{0x4710, 0x06},
+{0x4711, 0x00},
+{0x4800, 0x00},
+{0x481f, 0x30},
+{0x4837, 0x14},
+{0x4f00, 0x00},
+{0x4f07, 0x00},
+{0x4f08, 0x03},
+{0x4f09, 0x08},
+{0x4f0c, 0x05},
+{0x4f0d, 0xb4},
+{0x4f10, 0x00},
+{0x4f11, 0x00},
+{0x4f12, 0x07},
+{0x4f13, 0xe2},
+{0x5000, 0x9f},
+{0x5001, 0x20},
+{0x5026, 0x00},
+{0x5c00, 0x00},
+{0x5c01, 0x2c},
+{0x5c02, 0x00},
+{0x5c03, 0x7f},
+{0x5e00, 0x00},
+{0x5e01, 0x41},
+{0x38b1, 0x02},
+{0x3880, 0x00},
+
+#if 1  /* Y8 mode */
+{0x3016, 0xF1},
+{0x0100, 0x01},
+{0x4814, 0x6A}, //; dt_man en, both embed/image data type are 0x2A
+{0x3218, 0x32},
+{0x3216, 0x01},
+{0x3208, 0x04},
+{0x3D81, 0x01},
+{0x4605, 0x02},
+{0x4816, 0x0A},
+{0x3208, 0x14},
+{0x3662, 0x67}, //; [1] raw8
+{0x366F, 0x1A}, //; [6] MSB
+//{0x3674, 0x11}, //; [0] embed_en, add embed data before normal image
+{0x3674, 0x10}, //; [0] embed_dis, add embed data before normal image
+{0x3016, 0xF0},
+#endif
+
+{0x0100, 0x01},
+};
diff --git a/drivers/media/i2c/imagers/ov490.c b/drivers/media/i2c/imagers/ov490.c
new file mode 100644
index 0000000..2d384f5
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov490.c
@@ -0,0 +1,1075 @@
+/*
+ * OmniVision ov490-ov10640 sensor camera driver
+ *
+ * Copyright (C) 2016-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov490.h"
+
+#define OV490_I2C_ADDR		0x24
+
+#define OV490_PID_REGA		0x300a
+#define OV490_PID_REGB		0x300b
+#define OV490_PID		0x0490
+
+#define OV490_ISP_HSIZE_LOW	0x60
+#define OV490_ISP_HSIZE_HIGH	0x61
+#define OV490_ISP_VSIZE_LOW	0x62
+#define OV490_ISP_VSIZE_HIGH	0x63
+
+#define OV490_MEDIA_BUS_FMT		MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov490_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	int				red;
+	int				green_r;
+	int				green_b;
+	int				blue;
+	int				awb;
+	int				dvp_order;
+	int				group;
+	int				vsync;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+	int				reset_gpio;
+	int				active_low_resetb;
+};
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static int group = 0;
+module_param(group, int, 0644);
+MODULE_PARM_DESC(group, " group number (0 - does not apply)");
+
+static int dvp_order = 0;
+module_param(dvp_order, int, 0644);
+MODULE_PARM_DESC(dvp_order, " DVP bus bits order");
+
+static int reset_gpio = 0;
+module_param(reset_gpio, int, 0644);
+MODULE_PARM_DESC(reset_gpio, " serializer gpio number on imager RESETB");
+
+static int vsync = 0;
+module_param(vsync, int, 0644);
+MODULE_PARM_DESC(vsync, " VSYNC invertion (default: 0 - not inverted)");
+
+static inline struct ov490_priv *to_ov490(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov490_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov490_priv, hdl)->sd;
+}
+
+static void ov490_reset(struct i2c_client *client)
+{
+	struct ov490_priv *priv = to_ov490(client);
+
+	switch (get_des_id(client)) {
+	case MAX9286_ID:
+	case MAX9288_ID:
+	case MAX9296A_ID:
+	case MAX96712_ID:
+		reg8_write_addr(client, priv->ser_addr, 0x0f, (0xfe & ~BIT(priv->reset_gpio))); /* set GPIOn value to reset */
+		usleep_range(2000, 2500);
+		reg8_write_addr(client, priv->ser_addr, 0x0f, 0xfe | BIT(priv->reset_gpio)); /* set GPIOn value to un-reset */
+		usleep_range(2000, 2500);
+		break;
+	case UB960_ID:
+		reg8_write_addr(client, get_des_addr(client), 0x6e, 0x8a);	/* set GPIO1 value to reset */
+		usleep_range(2000, 2500);
+		reg8_write_addr(client, get_des_addr(client), 0x6e, 0x9a);	/* set GPIO1 value to un-reset */
+		usleep_range(2000, 2500);
+		break;
+	}
+}
+
+static int ov490_set_regs(struct i2c_client *client,
+			  const struct ov490_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100 us */
+			reg16_write(client, regs[i].reg, regs[i].val);
+		}
+
+		if (regs[i].reg == 0xFFFE)
+			usleep_range(100, 150); /* wait 100 us */
+	}
+
+	return 0;
+}
+
+static u8 ov490_ov10640_read(struct i2c_client *client, u16 addr)
+{
+	u8 reg_val = 0;
+
+	reg16_write(client, 0xFFFD, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0xFFFE, 0x19);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x5000, 0x01); /* read operation */
+	reg16_write(client, 0x5001, addr >> 8);
+	reg16_write(client, 0x5002, addr & 0xff);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x00C0, 0xc1);
+	reg16_write(client, 0xFFFE, 0x19);
+	usleep_range(1000, 1500); /* wait 1 ms */
+	reg16_read(client, 0x5000, &reg_val);
+
+	return reg_val;
+}
+
+static void ov490_ov10640_write(struct i2c_client *client, u16 addr, u8 val)
+{
+	reg16_write(client, 0xFFFD, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0xFFFE, 0x19);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x5000, 0x00); /* write operation */
+	reg16_write(client, 0x5001, addr >> 8);
+	reg16_write(client, 0x5002, addr & 0xff);
+	reg16_write(client, 0x5003, val);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x00C0, 0xc1);
+}
+
+static void ov490_otp_id_read(struct i2c_client *client)
+{
+	struct ov490_priv *priv = to_ov490(client);
+	int i;
+	int otp_bank0_allzero = 1;
+#if 0
+	/* read camera id from ov490 OTP memory */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x28);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0xE084, 0x40); /* manual mode, bank#0 */
+	reg16_write(client, 0xE081, 1); /* start OTP read */
+
+	usleep_range(25000, 26000); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0xe000 + i + 4, &priv->id[i]);
+#else
+	/* read camera id from ov10640 OTP memory */
+	ov490_ov10640_write(client, 0x349C, 1);
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++) {
+		/* first 6 bytes are equal on all ov10640 */
+		priv->id[i] = ov490_ov10640_read(client, 0x349e + i + 6);
+		if (priv->id[i])
+			otp_bank0_allzero = 0;
+	}
+
+	if (otp_bank0_allzero) {
+		ov490_ov10640_write(client, 0x3495, 0x41); /* bank#1 */
+		ov490_ov10640_write(client, 0x349C, 1);
+		usleep_range(25000, 25500); /* wait 25 ms */
+
+		for (i = 0; i < 6; i++)
+			priv->id[i] = ov490_ov10640_read(client, 0x34ae + i);
+	}
+#endif
+}
+
+static int ov490_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov490_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV490_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov490_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV490_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov490_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV490_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov490_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV490_PID >> 8;
+	edid->edid[9] = OV490_PID & 0xff;
+
+	return 0;
+}
+
+static int ov490_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ov490_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov490_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov490_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 val = 0;
+
+	ret = reg16_read(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ov490_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = reg16_write(client, (u16)reg->reg, (u8)reg->val);
+	if ((u8)reg->reg == 0xFFFD)
+		usleep_range(100, 150); /* wait 100 us */
+	if ((u8)reg->reg == 0xFFFE)
+		usleep_range(100, 150); /* wait 100 us */
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov490_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov490_g_register,
+	.s_register = ov490_s_register,
+#endif
+};
+
+static int ov490_s_gamma(int a, int ref)
+{
+	if ((a + ref) > 0xff)
+		return 0xff;
+
+	if ((a + ref) < 0)
+		return 0;
+
+	return a + ref;
+}
+
+static int ov490_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		/* SDE (rough) brightness */
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00);
+		ret |= reg16_write(client, 0x5001, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf1);
+		break;
+	case V4L2_CID_CONTRAST:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xfd);
+		break;
+	case V4L2_CID_SATURATION:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf3);
+		break;
+	case V4L2_CID_HUE:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf5);
+		break;
+	case V4L2_CID_GAMMA:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ov490_s_gamma(ctrl->val, 0x12));
+		ret |= reg16_write(client, 0x5001, ov490_s_gamma(ctrl->val, 0x20));
+		ret |= reg16_write(client, 0x5002, ov490_s_gamma(ctrl->val, 0x3b));
+		ret |= reg16_write(client, 0x5003, ov490_s_gamma(ctrl->val, 0x5d));
+		ret |= reg16_write(client, 0x5004, ov490_s_gamma(ctrl->val, 0x6a));
+		ret |= reg16_write(client, 0x5005, ov490_s_gamma(ctrl->val, 0x76));
+		ret |= reg16_write(client, 0x5006, ov490_s_gamma(ctrl->val, 0x81));
+		ret |= reg16_write(client, 0x5007, ov490_s_gamma(ctrl->val, 0x8b));
+		ret |= reg16_write(client, 0x5008, ov490_s_gamma(ctrl->val, 0x96));
+		ret |= reg16_write(client, 0x5009, ov490_s_gamma(ctrl->val, 0x9e));
+		ret |= reg16_write(client, 0x500a, ov490_s_gamma(ctrl->val, 0xae));
+		ret |= reg16_write(client, 0x500b, ov490_s_gamma(ctrl->val, 0xbc));
+		ret |= reg16_write(client, 0x500c, ov490_s_gamma(ctrl->val, 0xcf));
+		ret |= reg16_write(client, 0x500d, ov490_s_gamma(ctrl->val, 0xde));
+		ret |= reg16_write(client, 0x500e, ov490_s_gamma(ctrl->val, 0xec));
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xf9);
+		break;
+	case V4L2_CID_SHARPNESS:
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xfb);
+		break;
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		if (ctrl->id == V4L2_CID_AUTOGAIN)
+			priv->autogain = ctrl->val;
+		if (ctrl->id == V4L2_CID_GAIN)
+			priv->gain = ctrl->val;
+		if (ctrl->id == V4L2_CID_EXPOSURE)
+			priv->exposure = ctrl->val;
+
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, !priv->autogain);
+		ret |= reg16_write(client, 0x5001, priv->exposure >> 8);
+		ret |= reg16_write(client, 0x5002, priv->exposure & 0xff);
+		ret |= reg16_write(client, 0x5003, priv->exposure >> 8);
+		ret |= reg16_write(client, 0x5004, priv->exposure & 0xff);
+		ret |= reg16_write(client, 0x5005, priv->exposure >> 8);
+		ret |= reg16_write(client, 0x5006, priv->exposure & 0xff);
+		ret |= reg16_write(client, 0x5007, priv->gain >> 8);
+		ret |= reg16_write(client, 0x5008, priv->gain & 0xff);
+		ret |= reg16_write(client, 0x5009, priv->gain >> 8);
+		ret |= reg16_write(client, 0x500a, priv->gain & 0xff);
+		ret |= reg16_write(client, 0x500b, priv->gain >> 8);
+		ret |= reg16_write(client, 0x500c, priv->gain & 0xff);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xea);
+		break;
+	case V4L2_CID_AUTO_WHITE_BALANCE:
+	case V4L2_CID_RED_BALANCE:
+	case V4L2_CID_BLUE_BALANCE:
+		if (ctrl->id == V4L2_CID_AUTO_WHITE_BALANCE)
+			priv->awb = ctrl->val;
+		if (ctrl->id == V4L2_CID_RED_BALANCE) {
+			priv->red = ctrl->val;
+			priv->red <<= 8;
+			priv->green_r = priv->red / 2;
+		}
+		if (ctrl->id == V4L2_CID_BLUE_BALANCE) {
+			priv->blue = ctrl->val;
+			priv->blue <<= 8;
+			priv->green_b = priv->blue / 2;
+		}
+
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, !priv->awb);
+		ret |= reg16_write(client, 0x5001, priv->red >> 8);
+		ret |= reg16_write(client, 0x5002, priv->red & 0xff);
+		ret |= reg16_write(client, 0x5003, priv->green_r >> 8);
+		ret |= reg16_write(client, 0x5004, priv->green_r & 0xff);
+		ret |= reg16_write(client, 0x5005, priv->green_b >> 8);
+		ret |= reg16_write(client, 0x5006, priv->green_b & 0xff);
+		ret |= reg16_write(client, 0x5007, priv->blue >> 8);
+		ret |= reg16_write(client, 0x5008, priv->blue & 0xff);
+		ret |= reg16_write(client, 0x5009, priv->red >> 8);
+		ret |= reg16_write(client, 0x500a, priv->red & 0xff);
+		ret |= reg16_write(client, 0x500b, priv->green_r >> 8);
+		ret |= reg16_write(client, 0x500c, priv->green_r & 0xff);
+		ret |= reg16_write(client, 0x500d, priv->green_b >> 8);
+		ret |= reg16_write(client, 0x500e, priv->green_b & 0xff);
+		ret |= reg16_write(client, 0x500f, priv->blue >> 8);
+		ret |= reg16_write(client, 0x5010, priv->blue & 0xff);
+		ret |= reg16_write(client, 0x5011, priv->red >> 8);
+		ret |= reg16_write(client, 0x5012, priv->red & 0xff);
+		ret |= reg16_write(client, 0x5013, priv->green_r >> 8);
+		ret |= reg16_write(client, 0x5014, priv->green_r & 0xff);
+		ret |= reg16_write(client, 0x5015, priv->green_b >> 8);
+		ret |= reg16_write(client, 0x5016, priv->green_b & 0xff);
+		ret |= reg16_write(client, 0x5017, priv->blue >> 8);
+		ret |= reg16_write(client, 0x5018, priv->blue & 0xff);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xeb);
+		break;
+	case V4L2_CID_HFLIP:
+#if 1
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0x5001, 0x00);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xdc);
+#else
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 0);
+		val |= (ctrl->val << 0);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 1);
+		val |= (ctrl->val << 1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 2);
+		val |= (ctrl->val << 2);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+#endif
+		break;
+	case V4L2_CID_VFLIP:
+#if 1
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, ctrl->val);
+		ret |= reg16_write(client, 0x5001, 0x01);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xdc);
+#else
+		ret = reg16_write(client, 0xFFFD, 0x80);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 1);
+		val |= (ctrl->val << 1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3128
+		ret |= reg16_write(client, 0x5001, 0x31);
+		ret |= reg16_write(client, 0x5002, 0x28);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 2);
+		val |= (ctrl->val << 2);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3291
+		ret |= reg16_write(client, 0x5001, 0x32);
+		ret |= reg16_write(client, 0x5002, 0x91);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x01); // read 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_read(client, 0x5000, &val);
+		val &= ~(0x1 << 3);
+		val |= (ctrl->val << 3);
+		ret |= reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x5000, 0x00); // write 0x3090
+		ret |= reg16_write(client, 0x5001, 0x30);
+		ret |= reg16_write(client, 0x5002, 0x90);
+		ret |= reg16_write(client, 0x5003, val);
+		ret |= reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x00C0, 0xc1);
+#endif
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov490_ctrl_ops = {
+	.s_ctrl = ov490_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov490_video_ops = {
+	.s_stream	= ov490_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov490_subdev_pad_ops = {
+	.get_edid	= ov490_get_edid,
+	.enum_mbus_code	= ov490_enum_mbus_code,
+	.get_selection	= ov490_get_selection,
+	.set_selection	= ov490_set_selection,
+	.get_fmt	= ov490_get_fmt,
+	.set_fmt	= ov490_set_fmt,
+	.get_mbus_config	= ov490_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ov490_subdev_ops = {
+	.core	= &ov490_core_ops,
+	.video	= &ov490_video_ops,
+	.pad	= &ov490_subdev_pad_ops,
+};
+
+static ssize_t ov490_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov490_priv *priv = to_ov490(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov490, S_IRUGO, ov490_otp_id_show, NULL);
+
+static int ov490_initialize(struct i2c_client *client)
+{
+	struct ov490_priv *priv = to_ov490(client);
+	u8 val = 0;
+	u16 pid = 0;
+	int timeout, retry_timeout = 3;
+
+	setup_i2c_translator(client, priv->ser_addr, OV490_I2C_ADDR);
+
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV490_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV490_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV490_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+	if (unlikely(conf_link))
+		goto out;
+again:
+	/* Check if firmware booted by reading stream-on status */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x29);
+	usleep_range(100, 150); /* wait 100 us */
+	for (timeout = 300; timeout > 0; timeout--) {
+		reg16_read(client, 0xd000, &val);
+		if (val == 0x0c)
+			break;
+		mdelay(1);
+	}
+
+	/* wait firmware apps started by reading OV10640 ID */
+	for (;timeout > 0; timeout--) {
+		reg16_write(client, 0xFFFD, 0x80);
+		reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0x5000, 0x01);
+		reg16_write(client, 0x5001, 0x30);
+		reg16_write(client, 0x5002, 0x0a);
+		reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0xC0, 0xc1);
+		reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(1000, 1500); /* wait 1 ms */
+		reg16_read(client, 0x5000, &val);
+		if (val == 0xa6)
+			break;
+		mdelay(1);
+	}
+
+	if (!timeout) {
+		dev_err(&client->dev, "Timeout firmware boot wait, retrying\n");
+		/* reset OV10640 using RESETB pin controlled by OV490 GPIO0 */
+		reg16_write(client, 0xFFFD, 0x80);
+		reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0x0050, 0x01);
+		reg16_write(client, 0x0054, 0x01);
+		reg16_write(client, 0x0058, 0x00);
+		mdelay(10);
+		reg16_write(client, 0x0058, 0x01);
+		/* reset OV490 using RESETB pin controlled by serializer */
+		ov490_reset(client);
+		if (retry_timeout--)
+			goto again;
+	}
+
+	if (priv->group) {
+		/* switch to group# */
+		reg16_write(client, 0xFFFD, 0x80);
+		reg16_write(client, 0xFFFE, 0x19);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0x5000, priv->group);
+		reg16_write(client, 0xFFFE, 0x80);
+		usleep_range(100, 150); /* wait 100 us */
+		reg16_write(client, 0xc0, 0x3f);
+
+		mdelay(30);
+	}
+
+	/* read resolution used by current firmware */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x82);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV490_ISP_HSIZE_HIGH, &val);
+	priv->max_width = val;
+	reg16_read(client, OV490_ISP_HSIZE_LOW, &val);
+	priv->max_width = (priv->max_width << 8) | val;
+	reg16_read(client, OV490_ISP_VSIZE_HIGH, &val);
+	priv->max_height = val;
+	reg16_read(client, OV490_ISP_VSIZE_LOW, &val);
+	priv->max_height = (priv->max_height << 8) | val;
+	/* Program wizard registers */
+	ov490_set_regs(client, ov490_regs, ARRAY_SIZE(ov490_regs));
+	/* Set DVP bit swap */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x28);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x6009, priv->dvp_order << 4);
+	/* Set VSYNC inversion */
+	reg16_write(client, 0x6008, priv->vsync ? 0x2 : 0x0);
+	/* Read OTP IDs */
+	ov490_otp_id_read(client);
+
+out:
+	dev_info(&client->dev, "PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov490_parse_dt(struct device_node *np, struct ov490_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	if (of_property_read_u32(np, "dvp-order", &priv->dvp_order))
+		priv->dvp_order = 0;
+	if (of_property_read_u32(np, "reset-gpio", &priv->reset_gpio))
+		priv->reset_gpio = 1;
+	if (of_property_read_u32(np, "group", &priv->group))
+		priv->group = 0;
+	if (of_property_read_u32(np, "vsync", &priv->group))
+		priv->vsync = 0;
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	/* module params override dts */
+	if (dvp_order)
+		priv->dvp_order = dvp_order;
+	if (group)
+		priv->group = group;
+	if (vsync)
+		priv->vsync = vsync;
+
+	return 0;
+}
+
+static int ov490_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ov490_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov490_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	priv->red = 0x400;
+	priv->blue = 0x400;
+	priv->green_r = priv->red / 2;
+	priv->green_b = priv->blue / 2;
+	priv->awb = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_AUTO_WHITE_BALANCE, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_RED_BALANCE, 2, 0xf, 1, priv->red >> 8);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_BLUE_BALANCE, 2, 0xf, 1, priv->blue >> 8);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 1);
+	v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov490_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov490_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov490_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov490) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov490_remove(struct i2c_client *client)
+{
+	struct ov490_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov490);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov490_id[] = {
+	{ "ov490", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov490_id);
+
+static const struct of_device_id ov490_of_ids[] = {
+	{ .compatible = "ovti,ov490", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov490_of_ids);
+
+static struct i2c_driver ov490_i2c_driver = {
+	.driver	= {
+		.name		= "ov490",
+		.of_match_table	= ov490_of_ids,
+	},
+	.probe		= ov490_probe,
+	.remove		= ov490_remove,
+	.id_table	= ov490_id,
+};
+
+module_i2c_driver(ov490_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV490-10640");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov490.h b/drivers/media/i2c/imagers/ov490.h
new file mode 100644
index 0000000..dae9372
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov490.h
@@ -0,0 +1,101 @@
+/*
+ * OmniVision ov490-ov10640 sensor camera setup 1280x1080@30/UYVY/BT601/8bit
+ *
+ * Copyright (C) 2016-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+//#define OV490_DISPLAY_PATTERN
+
+struct ov490_reg {
+	u16	reg;
+	u8	val;
+};
+
+static const struct ov490_reg ov490_regs[] = {
+/* The following registers should match firmware */
+{0xfffd, 0x80},
+{0xfffe, 0x82},
+{0x0071, 0x11},
+{0x0075, 0x11},
+{0xfffe, 0x29},
+{0x6010, 0x01},
+/* ov490 EMB line disable in YUV and RAW data, NOTE: EMB line is still used in ISP and sensor */
+{0xe000, 0x14},
+#if 0 /* do not disable EMB line in ISP! */
+{0x4017, 0x00},
+#endif
+{0xfffe, 0x28},
+{0x6000, 0x04},
+{0x6004, 0x00},
+{0x6008, 0x00}, // PCLK polarity - useless due to silicon bug -> use 0x808000bb register
+{0xfffe, 0x80},
+{0x0091, 0x00},
+{0x00bb, 0x1d}, // bit[3]=0 - PCLK polarity workaround
+/* ov10640 EMB line disable */
+#if 0 /* do not disable EMB line in sensor! */
+{0xfffe, 0x19},
+{0x5000, 0x00},
+{0x5001, 0x30},
+{0x5002, 0x91},
+{0x5003, 0x08},
+{0xfffe, 0x80},
+{0x00c0, 0xc1},
+#endif
+/* Ov490 FSIN: app_fsin_from_fsync */
+{0xfffe, 0x85},
+{0x0008, 0x00},
+{0x0009, 0x01},
+{0x000A, 0x05}, // fsin0 src
+{0x000B, 0x00},
+{0x0030, 0x02}, // fsin0_delay
+{0x0031, 0x00},
+{0x0032, 0x00},
+{0x0033, 0x00},
+{0x0038, 0x02}, // fsin1_delay
+{0x0039, 0x00},
+{0x003A, 0x00},
+{0x003B, 0x00},
+{0x0070, 0x2C}, // fsin0_length
+{0x0071, 0x01},
+{0x0072, 0x00},
+{0x0073, 0x00},
+{0x0074, 0x64}, // fsin1_length
+{0x0075, 0x00},
+{0x0076, 0x00},
+{0x0077, 0x00},
+{0x0000, 0x14},
+{0x0001, 0x00},
+{0x0002, 0x00},
+{0x0003, 0x00},
+{0x0004, 0x32}, // load fsin0,load fsin1,load other, it will be cleared automatically.
+{0x0005, 0x00},
+{0x0006, 0x00},
+{0x0007, 0x00},
+{0xfffe, 0x80},
+{0x0081, 0x00}, // 03;SENSOR FSIN
+/* ov10640 FSIN */
+{0xfffe, 0x19},
+{0x5000, 0x00},
+{0x5001, 0x30},
+{0x5002, 0x8c},
+{0x5003, 0xb2},
+{0xfffe, 0x80},
+{0x00c0, 0xc1},
+/* ov10640 HFLIP=1 by default */
+{0xfffe, 0x19},
+{0x5000, 0x01},
+{0x5001, 0x00},
+{0xfffe, 0x80},
+{0x00c0, 0xdc},
+#ifdef OV490_DISPLAY_PATTERN
+{0xfffe, 0x19},
+{0x5000, 0x02},
+{0xfffe, 0x80},
+{0x00c0, 0xd6},
+#endif
+};
diff --git a/drivers/media/i2c/imagers/ov495.c b/drivers/media/i2c/imagers/ov495.c
new file mode 100644
index 0000000..96b2199
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov495.c
@@ -0,0 +1,622 @@
+/*
+ * OmniVision ov495-2775 sensor camera glue
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/of_graph.h>
+#include <linux/videodev2.h>
+
+#include <media/v4l2-async.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-fwnode.h>
+#include <media/v4l2-subdev.h>
+
+#include "../gmsl/common.h"
+#include "ov495.h"
+
+#define OV495_I2C_ADDR		0x24
+
+#define OV495_PID_REGA		0x300a
+#define OV495_PID_REGB		0x300b
+#define OV495_PID		0x0495
+
+#define OV495_ISP_HSIZE_LOW	0x60
+#define OV495_ISP_HSIZE_HIGH	0x61
+#define OV495_ISP_VSIZE_LOW	0x62
+#define OV495_ISP_VSIZE_HIGH	0x63
+
+#define OV495_MEDIA_BUS_FMT	MEDIA_BUS_FMT_UYVY8_2X8
+
+struct ov495_priv {
+	struct v4l2_subdev		sd;
+	struct v4l2_ctrl_handler	hdl;
+	struct media_pad		pad;
+	struct v4l2_rect		rect;
+	int				max_width;
+	int				max_height;
+	int				init_complete;
+	u8				id[6];
+	int				exposure;
+	int				gain;
+	int				autogain;
+	/* serializers */
+	int				ser_addr;
+	int				des_addr;
+};
+
+static int conf_link;
+module_param(conf_link, int, 0644);
+MODULE_PARM_DESC(conf_link, " Force configuration link. Used only if robust firmware flashing required (f.e. recovery)");
+
+static inline struct ov495_priv *to_ov495(const struct i2c_client *client)
+{
+	return container_of(i2c_get_clientdata(client), struct ov495_priv, sd);
+}
+
+static inline struct v4l2_subdev *to_sd(struct v4l2_ctrl *ctrl)
+{
+	return &container_of(ctrl->handler, struct ov495_priv, hdl)->sd;
+}
+
+static int ov495_set_regs(struct i2c_client *client,
+			  const struct ov495_reg *regs, int nr_regs)
+{
+	int i;
+
+	for (i = 0; i < nr_regs; i++) {
+		if (reg16_write(client, regs[i].reg, regs[i].val)) {
+			usleep_range(100, 150); /* wait 100 us */
+			reg16_write(client, regs[i].reg, regs[i].val);
+		}
+	}
+
+	return 0;
+}
+
+static void ov495_otp_id_read(struct i2c_client *client)
+{
+	struct ov495_priv *priv = to_ov495(client);
+	int i;
+
+#if 0
+	/* read camera id from ov495 OTP memory */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x20);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_write(client, 0x7384, 0x40); /* manual mode, bank#0 */
+	reg16_write(client, 0x7381, 1); /* start OTP read */
+
+	usleep_range(25000, 26000); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++)
+		reg16_read(client, 0x7300 + i + 4, &priv->id[i]);
+#else
+	/* read camera id from ov2775 OTP memory */
+	reg16_write(client, 0x3516, 0x00); /* unlock write */
+	reg16_write(client, 0x0FFC, 0);
+	reg16_write(client, 0x0500, 0x00); /* write 0x34a1 -> 1 */
+	reg16_write(client, 0x0501, 0x34);
+	reg16_write(client, 0x0502, 0xa1);
+	reg16_write(client, 0x0503, 1);
+	reg16_write(client, 0x30C0, 0xc1);
+
+	usleep_range(25000, 25500); /* wait 25 ms */
+
+	for (i = 0; i < 6; i++) {
+		reg16_write(client, 0x3516, 0x00); /* unlock write */
+		reg16_write(client, 0x0500, 0x01); /* read (0x7a00 + i) */
+		reg16_write(client, 0x0501, 0x7a);
+		reg16_write(client, 0x0502, 0x00 + i + (i < 3 ? 11 : 3)); /* take bytes 11,12,13,6,7,8 */
+		reg16_write(client, 0x30C0, 0xc1);
+		usleep_range(1000, 1500); /* wait 1 ms */
+		reg16_read(client, 0x0500, &priv->id[i]);
+	}
+#endif
+}
+
+static int ov495_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	return 0;
+}
+
+static int ov495_get_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	if (format->pad)
+		return -EINVAL;
+
+	mf->width = priv->rect.width;
+	mf->height = priv->rect.height;
+	mf->code = OV495_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	return 0;
+}
+
+static int ov495_set_fmt(struct v4l2_subdev *sd,
+			 struct v4l2_subdev_pad_config *cfg,
+			 struct v4l2_subdev_format *format)
+{
+	struct v4l2_mbus_framefmt *mf = &format->format;
+
+	mf->code = OV495_MEDIA_BUS_FMT;
+	mf->colorspace = V4L2_COLORSPACE_SMPTE170M;
+	mf->field = V4L2_FIELD_NONE;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		cfg->try_fmt = *mf;
+
+	return 0;
+}
+
+static int ov495_enum_mbus_code(struct v4l2_subdev *sd,
+				struct v4l2_subdev_pad_config *cfg,
+				struct v4l2_subdev_mbus_code_enum *code)
+{
+	if (code->pad || code->index > 0)
+		return -EINVAL;
+
+	code->code = OV495_MEDIA_BUS_FMT;
+
+	return 0;
+}
+
+static int ov495_get_edid(struct v4l2_subdev *sd, struct v4l2_edid *edid)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	memcpy(edid->edid, priv->id, 6);
+
+	edid->edid[6] = 0xff;
+	edid->edid[7] = client->addr;
+	edid->edid[8] = OV495_PID >> 8;
+	edid->edid[9] = OV495_PID & 0xff;
+
+	return 0;
+}
+
+static int ov495_set_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct v4l2_rect *rect = &sel->r;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE ||
+	    sel->target != V4L2_SEL_TGT_CROP)
+		return -EINVAL;
+
+	rect->left = ALIGN(rect->left, 2);
+	rect->top = ALIGN(rect->top, 2);
+	rect->width = ALIGN(rect->width, 2);
+	rect->height = ALIGN(rect->height, 2);
+
+	if ((rect->left + rect->width > priv->max_width) ||
+	    (rect->top + rect->height > priv->max_height))
+		*rect = priv->rect;
+
+	priv->rect.left = rect->left;
+	priv->rect.top = rect->top;
+	priv->rect.width = rect->width;
+	priv->rect.height = rect->height;
+
+	return 0;
+}
+
+static int ov495_get_selection(struct v4l2_subdev *sd,
+			       struct v4l2_subdev_pad_config *cfg,
+			       struct v4l2_subdev_selection *sel)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	if (sel->which != V4L2_SUBDEV_FORMAT_ACTIVE)
+		return -EINVAL;
+
+	switch (sel->target) {
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		sel->r.left = 0;
+		sel->r.top = 0;
+		sel->r.width = priv->max_width;
+		sel->r.height = priv->max_height;
+		return 0;
+	case V4L2_SEL_TGT_CROP:
+		sel->r = priv->rect;
+		return 0;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int ov495_g_mbus_config(struct v4l2_subdev *sd, unsigned int pad,
+			       struct v4l2_mbus_config *cfg)
+{
+	cfg->flags = V4L2_MBUS_CSI2_1_LANE | V4L2_MBUS_CSI2_CHANNEL_0 |
+		     V4L2_MBUS_CSI2_CONTINUOUS_CLOCK;
+	cfg->type = V4L2_MBUS_CSI2_DPHY;
+
+	return 0;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int ov495_g_register(struct v4l2_subdev *sd,
+			    struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+	u8 val = 0;
+
+	ret = reg16_read(client, (u16)reg->reg, &val);
+	if (ret < 0)
+		return ret;
+
+	reg->val = val;
+	reg->size = sizeof(u16);
+
+	return 0;
+}
+
+static int ov495_s_register(struct v4l2_subdev *sd,
+			    const struct v4l2_dbg_register *reg)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	int ret;
+
+	ret = reg16_write(client, (u16)reg->reg, (u8)reg->val);
+	if ((u8)reg->reg == 0xFFFD)
+		usleep_range(100, 150); /* wait 100 us */
+	if ((u8)reg->reg == 0xFFFE)
+		usleep_range(100, 150); /* wait 100 us */
+	return ret;
+}
+#endif
+
+static struct v4l2_subdev_core_ops ov495_core_ops = {
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.g_register = ov495_g_register,
+	.s_register = ov495_s_register,
+#endif
+};
+
+static int ov495_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct v4l2_subdev *sd = to_sd(ctrl);
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+	int ret = -EINVAL;
+
+	if (!priv->init_complete)
+		return 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		break;
+	case V4L2_CID_CONTRAST:
+		break;
+	case V4L2_CID_SATURATION:
+		break;
+	case V4L2_CID_HUE:
+		break;
+	case V4L2_CID_GAMMA:
+		break;
+	case V4L2_CID_SHARPNESS:
+		break;
+	case V4L2_CID_AUTOGAIN:
+	case V4L2_CID_GAIN:
+	case V4L2_CID_EXPOSURE:
+		break;
+	case V4L2_CID_HFLIP:
+		ret = reg16_write(client, 0x3516, 0x00);
+		ret |= reg16_write(client, 0x0ffc, 0x00);
+		ret |= reg16_write(client, 0x0500, ctrl->val);
+		ret |= reg16_write(client, 0x0501, 0x00);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x30C0, 0xdc);
+		ret |= reg16_write(client, 0x3516, 0x01);
+		break;
+	case V4L2_CID_VFLIP:
+		ret = reg16_write(client, 0x3516, 0x00);
+		ret |= reg16_write(client, 0x0ffc, 0x00);
+		ret |= reg16_write(client, 0x0500, ctrl->val);
+		ret |= reg16_write(client, 0x0501, 0x01);
+		usleep_range(100, 150); /* wait 100 us */
+		ret |= reg16_write(client, 0x30C0, 0xdc);
+		ret |= reg16_write(client, 0x3516, 0x01);
+		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		ret = 0;
+		break;
+	}
+
+	return ret;
+}
+
+static const struct v4l2_ctrl_ops ov495_ctrl_ops = {
+	.s_ctrl = ov495_s_ctrl,
+};
+
+static struct v4l2_subdev_video_ops ov495_video_ops = {
+	.s_stream	= ov495_s_stream,
+};
+
+static const struct v4l2_subdev_pad_ops ov495_subdev_pad_ops = {
+	.get_edid	= ov495_get_edid,
+	.enum_mbus_code	= ov495_enum_mbus_code,
+	.get_selection	= ov495_get_selection,
+	.set_selection	= ov495_set_selection,
+	.get_fmt	= ov495_get_fmt,
+	.set_fmt	= ov495_set_fmt,
+	.get_mbus_config	= ov495_g_mbus_config,
+};
+
+static struct v4l2_subdev_ops ov495_subdev_ops = {
+	.core	= &ov495_core_ops,
+	.video	= &ov495_video_ops,
+	.pad	= &ov495_subdev_pad_ops,
+};
+
+static ssize_t ov495_otp_id_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(to_i2c_client(dev));
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct ov495_priv *priv = to_ov495(client);
+
+	return snprintf(buf, 32, "%02x:%02x:%02x:%02x:%02x:%02x\n",
+			priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+}
+
+static DEVICE_ATTR(otp_id_ov495, S_IRUGO, ov495_otp_id_show, NULL);
+
+static int ov495_initialize(struct i2c_client *client)
+{
+	struct ov495_priv *priv = to_ov495(client);
+	u8 val = 0;
+	u16 pid = 0;
+
+	setup_i2c_translator(client, priv->ser_addr, OV495_I2C_ADDR);
+
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x80);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV495_PID_REGA, &val);
+	pid = val;
+	reg16_read(client, OV495_PID_REGB, &val);
+	pid = (pid << 8) | val;
+
+	if (pid != OV495_PID) {
+		dev_dbg(&client->dev, "Product ID error %x\n", pid);
+		return -ENODEV;
+	}
+
+#if 0
+	/* setup XCLK */
+	tmp_addr = client->addr;
+	if (priv->ti9x4_addr) {
+		/* CLK_OUT=22.5792*160*M/N/CLKDIV -> CLK_OUT=25MHz: CLKDIV=4, M=7, N=253: 22.5792*160/4*7/253=24.989MHz=CLK_OUT */
+		client->addr = priv->ti9x3_addr;			/* Serializer I2C address */
+		reg8_write(client, 0x06, 0x47);				/* Set CLKDIV and M */
+		reg8_write(client, 0x07, 0xfd);				/* Set N */
+	}
+	client->addr = tmp_addr;
+#endif
+
+	if (unlikely(conf_link))
+		goto out;
+
+#if 0
+	/* read resolution used by current firmware */
+	reg16_write(client, 0xFFFD, 0x80);
+	reg16_write(client, 0xFFFE, 0x82);
+	usleep_range(100, 150); /* wait 100 us */
+	reg16_read(client, OV495_ISP_HSIZE_HIGH, &val);
+	priv->max_width = val;
+	reg16_read(client, OV495_ISP_HSIZE_LOW, &val);
+	priv->max_width = (priv->max_width << 8) | val;
+	reg16_read(client, OV495_ISP_VSIZE_HIGH, &val);
+	priv->max_height = val;
+	reg16_read(client, OV495_ISP_VSIZE_LOW, &val);
+	priv->max_height = (priv->max_height << 8) | val;
+#else
+	priv->max_width = 1920;
+	priv->max_height = 1080;
+#endif
+	/* set virtual channel */
+//	ov495_regs[3].val = 0x1e | (priv->port << 6);
+	/* Program wizard registers */
+	ov495_set_regs(client, ov495_regs, ARRAY_SIZE(ov495_regs));
+	/* Read OTP IDs */
+	ov495_otp_id_read(client);
+
+out:
+	dev_info(&client->dev, "PID %x, res %dx%d, OTP_ID %02x:%02x:%02x:%02x:%02x:%02x\n",
+		 pid, priv->max_width, priv->max_height, priv->id[0], priv->id[1], priv->id[2], priv->id[3], priv->id[4], priv->id[5]);
+	return 0;
+}
+
+static int ov495_parse_dt(struct device_node *np, struct ov495_priv *priv)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(&priv->sd);
+	struct fwnode_handle *ep;
+	u32 addrs[2], naddrs;
+
+	naddrs = of_property_count_elems_of_size(np, "reg", sizeof(u32));
+	if (naddrs != 2) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	if (of_property_read_u32_array(client->dev.of_node, "reg", addrs, naddrs) < 0) {
+		dev_err(&client->dev, "Invalid DT reg property\n");
+		return -EINVAL;
+	}
+
+	priv->ser_addr = addrs[1];
+
+	ep = fwnode_graph_get_next_endpoint(dev_fwnode(&client->dev), NULL);
+	if (!ep) {
+		dev_err(&client->dev, "Unable to get endpoint in node %pOF: %ld\n",
+				      client->dev.of_node, PTR_ERR(ep));
+		return -ENOENT;
+	}
+	priv->sd.fwnode = ep;
+
+	return 0;
+}
+
+static int ov495_probe(struct i2c_client *client,
+		       const struct i2c_device_id *did)
+{
+	struct ov495_priv *priv;
+	struct v4l2_ctrl *ctrl;
+	int ret;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	v4l2_i2c_subdev_init(&priv->sd, client, &ov495_subdev_ops);
+	priv->sd.flags = V4L2_SUBDEV_FL_HAS_DEVNODE;
+
+	priv->exposure = 0x100;
+	priv->gain = 0x100;
+	priv->autogain = 1;
+	v4l2_ctrl_handler_init(&priv->hdl, 4);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_BRIGHTNESS, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_CONTRAST, 0, 16, 1, 7);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_SATURATION, 0, 7, 1, 2);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_HUE, 0, 23, 1, 12);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_GAMMA, -128, 128, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_SHARPNESS, 0, 10, 1, 3);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_AUTOGAIN, 0, 1, 1, priv->autogain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_GAIN, 0, 0xffff, 1, priv->gain);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_EXPOSURE, 0, 0xffff, 1, priv->exposure);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_HFLIP, 0, 1, 1, 0);
+	v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_VFLIP, 0, 1, 1, 0);
+	ctrl = v4l2_ctrl_new_std(&priv->hdl, &ov495_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 9);
+	if (ctrl)
+		ctrl->flags &= ~V4L2_CTRL_FLAG_READ_ONLY;
+	priv->sd.ctrl_handler = &priv->hdl;
+
+	ret = priv->hdl.error;
+	if (ret)
+		goto cleanup;
+
+	v4l2_ctrl_handler_setup(&priv->hdl);
+
+	priv->sd.entity.function = MEDIA_ENT_F_CAM_SENSOR;
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	ret = media_entity_pads_init(&priv->sd.entity, 1, &priv->pad);
+	if (ret < 0)
+		goto cleanup;
+
+	ret = ov495_parse_dt(client->dev.of_node, priv);
+	if (ret)
+		goto cleanup;
+
+	ret = ov495_initialize(client);
+	if (ret < 0)
+		goto cleanup;
+
+	priv->rect.left = 0;
+	priv->rect.top = 0;
+	priv->rect.width = priv->max_width;
+	priv->rect.height = priv->max_height;
+
+	ret = v4l2_async_register_subdev(&priv->sd);
+	if (ret)
+		goto cleanup;
+
+	if (device_create_file(&client->dev, &dev_attr_otp_id_ov495) != 0) {
+		dev_err(&client->dev, "sysfs otp_id entry creation failed\n");
+		goto cleanup;
+	}
+
+	priv->init_complete = 1;
+
+	return 0;
+
+cleanup:
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+	return ret;
+}
+
+static int ov495_remove(struct i2c_client *client)
+{
+	struct ov495_priv *priv = i2c_get_clientdata(client);
+
+	device_remove_file(&client->dev, &dev_attr_otp_id_ov495);
+	v4l2_async_unregister_subdev(&priv->sd);
+	media_entity_cleanup(&priv->sd.entity);
+	v4l2_ctrl_handler_free(&priv->hdl);
+	v4l2_device_unregister_subdev(&priv->sd);
+
+	return 0;
+}
+
+static const struct i2c_device_id ov495_id[] = {
+	{ "ov495", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, ov495_id);
+
+static const struct of_device_id ov495_of_ids[] = {
+	{ .compatible = "ovti,ov495", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ov495_of_ids);
+
+static struct i2c_driver ov495_i2c_driver = {
+	.driver	= {
+		.name		= "ov495",
+		.of_match_table	= ov495_of_ids,
+	},
+	.probe		= ov495_probe,
+	.remove		= ov495_remove,
+	.id_table	= ov495_id,
+};
+
+module_i2c_driver(ov495_i2c_driver);
+
+MODULE_DESCRIPTION("Camera glue driver for OV495-2775");
+MODULE_AUTHOR("Vladimir Barinov");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/i2c/imagers/ov495.h b/drivers/media/i2c/imagers/ov495.h
new file mode 100644
index 0000000..18ec0e4
--- /dev/null
+++ b/drivers/media/i2c/imagers/ov495.h
@@ -0,0 +1,23 @@
+/*
+ * OmniVision ov495-ov2775 sensor camera setup 1920x1080@30/UYVY/MIPI
+ *
+ * Copyright (C) 2017-2020 Cogent Embedded, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+struct ov495_reg {
+	u16	reg;
+	u8	val;
+};
+
+static struct ov495_reg ov495_regs[] = {
+{0x3516, 0x00}, /* unlock write */
+{0xFFFD, 0x80},
+{0xFFFE, 0x20},
+{0x8017, 0x1e | (0 << 6)},
+{0x7c10, 0x01}, /* UYVY */
+};
-- 
2.7.4

